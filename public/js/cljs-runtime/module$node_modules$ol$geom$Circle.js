shadow$provide.module$node_modules$ol$geom$Circle = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent");
  global = require("module$node_modules$ol$geom$SimpleGeometry");
  var require$_DOT__SLASH_flat_SLASH_deflate_DOT_js = require("module$node_modules$ol$geom$flat$deflate"), require$_DOT__SLASH_flat_SLASH_transform_DOT_js = require("module$node_modules$ol$geom$flat$transform");
  require = require.esmDefault(global);
  class Circle extends require.default {
    constructor(center, radius, layout) {
      super();
      void 0 !== layout && void 0 === radius ? this.setFlatCoordinates(layout, center) : this.setCenterAndRadius(center, radius ? radius : 0, layout);
    }
    clone() {
      const circle = new Circle(this.flatCoordinates.slice(), void 0, this.layout);
      circle.applyProperties(this);
      return circle;
    }
    closestPointXY(x, y, closestPoint, minSquaredDistance) {
      const flatCoordinates = this.flatCoordinates;
      x -= flatCoordinates[0];
      const dy = y - flatCoordinates[1];
      y = x * x + dy * dy;
      if (y < minSquaredDistance) {
        if (0 === y) {
          for (minSquaredDistance = 0; minSquaredDistance < this.stride; ++minSquaredDistance) {
            closestPoint[minSquaredDistance] = flatCoordinates[minSquaredDistance];
          }
        } else {
          for (minSquaredDistance = this.getRadius() / Math.sqrt(y), closestPoint[0] = flatCoordinates[0] + minSquaredDistance * x, closestPoint[1] = flatCoordinates[1] + minSquaredDistance * dy, minSquaredDistance = 2; minSquaredDistance < this.stride; ++minSquaredDistance) {
            closestPoint[minSquaredDistance] = flatCoordinates[minSquaredDistance];
          }
        }
        closestPoint.length = this.stride;
        return y;
      }
      return minSquaredDistance;
    }
    containsXY(x, y) {
      const flatCoordinates = this.flatCoordinates;
      x -= flatCoordinates[0];
      y -= flatCoordinates[1];
      return x * x + y * y <= this.getRadiusSquared_();
    }
    getCenter() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    computeExtent(extent) {
      const flatCoordinates = this.flatCoordinates, radius = flatCoordinates[this.stride] - flatCoordinates[0];
      return (0,require$_DOT__DOT__SLASH_extent_DOT_js.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
    }
    getRadius() {
      return Math.sqrt(this.getRadiusSquared_());
    }
    getRadiusSquared_() {
      const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0], dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
      return dx * dx + dy * dy;
    }
    getType() {
      return "Circle";
    }
    intersectsExtent(extent) {
      var circleExtent = this.getExtent();
      return (0,require$_DOT__DOT__SLASH_extent_DOT_js.intersects)(extent, circleExtent) ? (circleExtent = this.getCenter(), extent[0] <= circleExtent[0] && extent[2] >= circleExtent[0] || extent[1] <= circleExtent[1] && extent[3] >= circleExtent[1] ? !0 : (0,require$_DOT__DOT__SLASH_extent_DOT_js.forEachCorner)(extent, this.intersectsCoordinate.bind(this))) : !1;
    }
    setCenter(center) {
      const stride = this.stride;
      var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
      const flatCoordinates = center.slice();
      flatCoordinates[stride] = flatCoordinates[0] + radius;
      for (radius = 1; radius < stride; ++radius) {
        flatCoordinates[stride + radius] = center[radius];
      }
      this.setFlatCoordinates(this.layout, flatCoordinates);
      this.changed();
    }
    setCenterAndRadius(center, radius, layout) {
      this.setLayout(layout, center, 0);
      this.flatCoordinates || (this.flatCoordinates = []);
      layout = this.flatCoordinates;
      center = (0,require$_DOT__SLASH_flat_SLASH_deflate_DOT_js.deflateCoordinate)(layout, 0, center, this.stride);
      layout[center++] = layout[0] + radius;
      for (let i = 1, ii = this.stride; i < ii; ++i) {
        layout[center++] = layout[i];
      }
      layout.length = center;
      this.changed();
    }
    getCoordinates() {
      return null;
    }
    setCoordinates(coordinates, layout) {
    }
    setRadius(radius) {
      this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
      this.changed();
    }
    rotate(angle, anchor) {
      const center = this.getCenter(), stride = this.getStride();
      this.setCenter((0,require$_DOT__SLASH_flat_SLASH_transform_DOT_js.rotate)(center, 0, center.length, stride, angle, anchor, center));
      this.changed();
    }
  }
  Circle.prototype.transform;
  const $$default = Circle;
};

//# sourceMappingURL=module$node_modules$ol$geom$Circle.js.map
