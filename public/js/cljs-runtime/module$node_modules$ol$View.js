shadow$provide.module$node_modules$ol$View = function(global, require, module, exports) {
  function animationCallback(callback, returnValue) {
    setTimeout(function() {
      callback(returnValue);
    }, 0);
  }
  function createCenterConstraint(options) {
    if (void 0 !== options.extent) {
      return (0,require$_DOT__SLASH_centerconstraint_DOT_js.createExtent)(options.extent, options.constrainOnlyCenter, void 0 !== options.smoothExtentConstraint ? options.smoothExtentConstraint : !0);
    }
    const projection = (0,require$_DOT__SLASH_proj_DOT_js.createProjection)(options.projection, "EPSG:3857");
    return !0 !== options.multiWorld && projection.isGlobal() ? (options = projection.getExtent().slice(), options[0] = -Infinity, options[2] = Infinity, (0,require$_DOT__SLASH_centerconstraint_DOT_js.createExtent)(options, !1, !1)) : require$_DOT__SLASH_centerconstraint_DOT_js.none;
  }
  function createResolutionConstraint(options) {
    let minZoom = void 0 !== options.minZoom ? options.minZoom : 0, maxZoom = void 0 !== options.maxZoom ? options.maxZoom : 28;
    const zoomFactor = void 0 !== options.zoomFactor ? options.zoomFactor : 2;
    var maxResolution = void 0 !== options.multiWorld ? options.multiWorld : !1;
    const smooth = void 0 !== options.smoothResolutionConstraint ? options.smoothResolutionConstraint : !0, showFullExtent = void 0 !== options.showFullExtent ? options.showFullExtent : !1;
    var minResolution = (0,require$_DOT__SLASH_proj_DOT_js.createProjection)(options.projection, "EPSG:3857");
    var projExtent = minResolution.getExtent();
    let constrainOnlyCenter = options.constrainOnlyCenter, extent = options.extent;
    maxResolution || extent || !minResolution.isGlobal() || (constrainOnlyCenter = !1, extent = projExtent);
    if (void 0 !== options.resolutions) {
      projExtent = options.resolutions, maxResolution = projExtent[minZoom], minResolution = void 0 !== projExtent[maxZoom] ? projExtent[maxZoom] : projExtent[projExtent.length - 1], options = options.constrainResolution ? (0,require$_DOT__SLASH_resolutionconstraint_DOT_js.createSnapToResolutions)(projExtent, smooth, !constrainOnlyCenter && extent, showFullExtent) : (0,require$_DOT__SLASH_resolutionconstraint_DOT_js.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && 
      extent, showFullExtent);
    } else {
      projExtent = (projExtent ? Math.max((0,require$_DOT__SLASH_extent_DOT_js.getWidth)(projExtent), (0,require$_DOT__SLASH_extent_DOT_js.getHeight)(projExtent)) : 360 * require$_DOT__SLASH_proj_DOT_js.METERS_PER_UNIT.degrees / minResolution.getMetersPerUnit()) / require$_DOT__SLASH_tilegrid_SLASH_common_DOT_js.DEFAULT_TILE_SIZE / Math.pow(2, 0);
      const defaultMinResolution = projExtent / Math.pow(2, 28);
      maxResolution = options.maxResolution;
      void 0 !== maxResolution ? minZoom = 0 : maxResolution = projExtent / Math.pow(zoomFactor, minZoom);
      minResolution = options.minResolution;
      void 0 === minResolution && (minResolution = void 0 !== options.maxZoom ? void 0 !== options.maxResolution ? maxResolution / Math.pow(zoomFactor, maxZoom) : projExtent / Math.pow(zoomFactor, maxZoom) : defaultMinResolution);
      maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
      options = options.constrainResolution ? (0,require$_DOT__SLASH_resolutionconstraint_DOT_js.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent) : (0,require$_DOT__SLASH_resolutionconstraint_DOT_js.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
    return {constraint:options, maxResolution, minResolution, minZoom, zoomFactor};
  }
  function createRotationConstraint(options) {
    return (void 0 !== options.enableRotation ? options.enableRotation : 1) ? (options = options.constrainRotation, void 0 === options || !0 === options ? (0,require$_DOT__SLASH_rotationconstraint_DOT_js.createSnapToZero)() : !1 === options ? require$_DOT__SLASH_rotationconstraint_DOT_js.none : "number" === typeof options ? (0,require$_DOT__SLASH_rotationconstraint_DOT_js.createSnapToN)(options) : require$_DOT__SLASH_rotationconstraint_DOT_js.none) : require$_DOT__SLASH_rotationconstraint_DOT_js.disable;
  }
  function isNoopAnimation(animation) {
    return animation.sourceCenter && animation.targetCenter && !(0,require$_DOT__SLASH_coordinate_DOT_js.equals)(animation.sourceCenter, animation.targetCenter) || animation.sourceResolution !== animation.targetResolution || animation.sourceRotation !== animation.targetRotation ? !1 : !0;
  }
  function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    const cosAngle = Math.cos(-rotation);
    rotation = Math.sin(-rotation);
    let rotX = coordinate[0] * cosAngle - coordinate[1] * rotation;
    coordinate = coordinate[1] * cosAngle + coordinate[0] * rotation;
    rotX += (size[0] / 2 - position[0]) * resolution;
    coordinate += (position[1] - size[1] / 2) * resolution;
    rotation = -rotation;
    return [rotX * cosAngle - coordinate * rotation, coordinate * cosAngle + rotX * rotation];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, createCenterConstraint:{enumerable:!0, get:function() {
    return createCenterConstraint;
  }}, createResolutionConstraint:{enumerable:!0, get:function() {
    return createResolutionConstraint;
  }}, createRotationConstraint:{enumerable:!0, get:function() {
    return createRotationConstraint;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}, isNoopAnimation:{enumerable:!0, get:function() {
    return isNoopAnimation;
  }}});
  exports = require("module$node_modules$ol$Object");
  global = require("module$node_modules$ol$ViewHint");
  module = require("module$node_modules$ol$ViewProperty");
  var require$_DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__SLASH_asserts_DOT_js = require("module$node_modules$ol$asserts"), require$_DOT__SLASH_centerconstraint_DOT_js = require("module$node_modules$ol$centerconstraint"), require$_DOT__SLASH_coordinate_DOT_js = require("module$node_modules$ol$coordinate"), require$_DOT__SLASH_easing_DOT_js = require("module$node_modules$ol$easing"), require$_DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), 
  require$_DOT__SLASH_functions_DOT_js = require("module$node_modules$ol$functions"), require$_DOT__SLASH_geom_SLASH_Polygon_DOT_js = require("module$node_modules$ol$geom$Polygon"), require$_DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj"), require$_DOT__SLASH_resolutionconstraint_DOT_js = require("module$node_modules$ol$resolutionconstraint"), require$_DOT__SLASH_rotationconstraint_DOT_js = require("module$node_modules$ol$rotationconstraint"), 
  require$_DOT__SLASH_tilegrid_SLASH_common_DOT_js = require("module$node_modules$ol$tilegrid$common");
  exports = require.esmDefault(exports);
  var default$$require$_DOT__SLASH_ViewProperty_DOT_js = require.esmDefault(module), default$$require$_DOT__SLASH_ViewHint_DOT_js = require.esmDefault(global);
  class View extends exports.default {
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      options = Object.assign({}, options);
      this.hints_ = [0, 0];
      this.animations_ = [];
      this.updateAnimationKey_;
      this.projection_ = (0,require$_DOT__SLASH_proj_DOT_js.createProjection)(options.projection, "EPSG:3857");
      this.viewportSize_ = [100, 100];
      this.targetCenter_ = null;
      this.targetResolution_;
      this.targetRotation_;
      this.nextCenter_ = null;
      this.nextResolution_;
      this.nextRotation_;
      this.cancelAnchor_ = void 0;
      options.projection && (0,require$_DOT__SLASH_proj_DOT_js.disableCoordinateWarning)();
      options.center && (options.center = (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(options.center, this.projection_));
      options.extent && (options.extent = (0,require$_DOT__SLASH_proj_DOT_js.fromUserExtent)(options.extent, this.projection_));
      this.applyOptions_(options);
    }
    applyOptions_(options) {
      var properties = Object.assign({}, options);
      for (var key in default$$require$_DOT__SLASH_ViewProperty_DOT_js.default) {
        delete properties[key];
      }
      this.setProperties(properties, !0);
      key = createResolutionConstraint(options);
      this.maxResolution_ = key.maxResolution;
      this.minResolution_ = key.minResolution;
      this.zoomFactor_ = key.zoomFactor;
      this.resolutions_ = options.resolutions;
      this.padding_ = options.padding;
      this.minZoom_ = key.minZoom;
      properties = createCenterConstraint(options);
      key = key.constraint;
      const rotationConstraint = createRotationConstraint(options);
      this.constraints_ = {center:properties, resolution:key, rotation:rotationConstraint};
      this.setRotation(void 0 !== options.rotation ? options.rotation : 0);
      this.setCenterInternal(void 0 !== options.center ? options.center : null);
      void 0 !== options.resolution ? this.setResolution(options.resolution) : void 0 !== options.zoom && this.setZoom(options.zoom);
    }
    get padding() {
      return this.padding_;
    }
    set padding(padding) {
      let oldPadding = this.padding_;
      this.padding_ = padding;
      const center = this.getCenterInternal();
      if (center) {
        padding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        const resolution = this.getResolution();
        this.setCenterInternal([center[0] + resolution / 2 * (padding[3] - oldPadding[3] + oldPadding[1] - padding[1]), center[1] - resolution / 2 * (padding[0] - oldPadding[0] + oldPadding[2] - padding[2])]);
      }
    }
    getUpdatedOptions_(newOptions) {
      const options = this.getProperties();
      void 0 !== options.resolution ? options.resolution = this.getResolution() : options.zoom = this.getZoom();
      options.center = this.getCenterInternal();
      options.rotation = this.getRotation();
      return Object.assign({}, options, newOptions);
    }
    animate(var_args) {
      this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
      const args = Array(arguments.length);
      for (let i = 0; i < args.length; ++i) {
        let options = arguments[i];
        options.center && (options = Object.assign({}, options), options.center = (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(options.center, this.getProjection()));
        options.anchor && (options = Object.assign({}, options), options.anchor = (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(options.anchor, this.getProjection()));
        args[i] = options;
      }
      this.animateInternal.apply(this, args);
    }
    animateInternal(var_args) {
      let animationCount = arguments.length, callback;
      1 < animationCount && "function" === typeof arguments[animationCount - 1] && (callback = arguments[animationCount - 1], --animationCount);
      let i = 0;
      for (; i < animationCount && !this.isDef(); ++i) {
        var state = arguments[i];
        state.center && this.setCenterInternal(state.center);
        void 0 !== state.zoom ? this.setZoom(state.zoom) : state.resolution && this.setResolution(state.resolution);
        void 0 !== state.rotation && this.setRotation(state.rotation);
      }
      if (i === animationCount) {
        callback && animationCallback(callback, !0);
      } else {
        state = Date.now();
        for (var center = this.targetCenter_.slice(), resolution = this.targetResolution_, rotation = this.targetRotation_, series = []; i < animationCount; ++i) {
          var options = arguments[i];
          const animation = {start:state, complete:!1, anchor:options.anchor, duration:void 0 !== options.duration ? options.duration : 1000, easing:options.easing || require$_DOT__SLASH_easing_DOT_js.inAndOut, callback};
          options.center && (animation.sourceCenter = center, animation.targetCenter = options.center.slice(), center = animation.targetCenter);
          void 0 !== options.zoom ? (animation.sourceResolution = resolution, animation.targetResolution = this.getResolutionForZoom(options.zoom), resolution = animation.targetResolution) : options.resolution && (animation.sourceResolution = resolution, animation.targetResolution = options.resolution, resolution = animation.targetResolution);
          void 0 !== options.rotation && (animation.sourceRotation = rotation, options = (0,require$_DOT__SLASH_math_DOT_js.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI, animation.targetRotation = rotation + options, rotation = animation.targetRotation);
          isNoopAnimation(animation) ? animation.complete = !0 : state += animation.duration;
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(default$$require$_DOT__SLASH_ViewHint_DOT_js.default.ANIMATING, 1);
        this.updateAnimations_();
      }
    }
    getAnimating() {
      return 0 < this.hints_[default$$require$_DOT__SLASH_ViewHint_DOT_js.default.ANIMATING];
    }
    getInteracting() {
      return 0 < this.hints_[default$$require$_DOT__SLASH_ViewHint_DOT_js.default.INTERACTING];
    }
    cancelAnimations() {
      this.setHint(default$$require$_DOT__SLASH_ViewHint_DOT_js.default.ANIMATING, -this.hints_[default$$require$_DOT__SLASH_ViewHint_DOT_js.default.ANIMATING]);
      let anchor;
      for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
        const series = this.animations_[i];
        series[0].callback && animationCallback(series[0].callback, !1);
        if (!anchor) {
          for (let j = 0, jj = series.length; j < jj; ++j) {
            const animation = series[j];
            if (!animation.complete) {
              anchor = animation.anchor;
              break;
            }
          }
        }
      }
      this.animations_.length = 0;
      this.cancelAnchor_ = anchor;
      this.nextCenter_ = null;
      this.nextRotation_ = this.nextResolution_ = NaN;
    }
    updateAnimations_() {
      void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0);
      if (this.getAnimating()) {
        var now = Date.now(), more = !1;
        for (let i = this.animations_.length - 1; 0 <= i; --i) {
          var series = this.animations_[i];
          let seriesComplete = !0;
          for (let j = 0, jj = series.length; j < jj; ++j) {
            const animation = series[j];
            if (!animation.complete) {
              more = now - animation.start;
              more = 0 < animation.duration ? more / animation.duration : 1;
              1 <= more ? (animation.complete = !0, more = 1) : seriesComplete = !1;
              more = animation.easing(more);
              if (animation.sourceCenter) {
                var x0 = animation.sourceCenter[0], y0 = animation.sourceCenter[1];
                const x1 = animation.targetCenter[0], y1 = animation.targetCenter[1];
                this.nextCenter_ = animation.targetCenter;
                this.targetCenter_ = [x0 + more * (x1 - x0), y0 + more * (y1 - y0)];
              }
              animation.sourceResolution && animation.targetResolution && (x0 = 1 === more ? animation.targetResolution : animation.sourceResolution + more * (animation.targetResolution - animation.sourceResolution), animation.anchor && (y0 = this.getViewportSize_(this.getRotation()), y0 = this.constraints_.resolution(x0, 0, y0, !0), this.targetCenter_ = this.calculateCenterZoom(y0, animation.anchor)), this.nextResolution_ = animation.targetResolution, this.targetResolution_ = x0, this.applyTargetState_(!0));
              void 0 !== animation.sourceRotation && void 0 !== animation.targetRotation && (more = 1 === more ? (0,require$_DOT__SLASH_math_DOT_js.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + more * (animation.targetRotation - animation.sourceRotation), animation.anchor && (x0 = this.constraints_.rotation(more, !0), this.targetCenter_ = this.calculateCenterRotate(x0, animation.anchor)), this.nextRotation_ = animation.targetRotation, this.targetRotation_ = 
              more);
              this.applyTargetState_(!0);
              more = !0;
              if (!animation.complete) {
                break;
              }
            }
          }
          seriesComplete && (this.animations_[i] = null, this.setHint(default$$require$_DOT__SLASH_ViewHint_DOT_js.default.ANIMATING, -1), this.nextCenter_ = null, this.nextRotation_ = this.nextResolution_ = NaN, (series = series[0].callback) && animationCallback(series, !0));
        }
        this.animations_ = this.animations_.filter(Boolean);
        more && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)));
      }
    }
    calculateCenterRotate(rotation, anchor) {
      let center;
      const currentCenter = this.getCenterInternal();
      void 0 !== currentCenter && (center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]], (0,require$_DOT__SLASH_coordinate_DOT_js.rotate)(center, rotation - this.getRotation()), (0,require$_DOT__SLASH_coordinate_DOT_js.add)(center, anchor));
      return center;
    }
    calculateCenterZoom(resolution, anchor) {
      let center;
      const currentCenter = this.getCenterInternal(), currentResolution = this.getResolution();
      void 0 !== currentCenter && void 0 !== currentResolution && (center = [anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution, anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution]);
      return center;
    }
    getViewportSize_(rotation) {
      var size = this.viewportSize_;
      if (rotation) {
        const w = size[0];
        size = size[1];
        return [Math.abs(w * Math.cos(rotation)) + Math.abs(size * Math.sin(rotation)), Math.abs(w * Math.sin(rotation)) + Math.abs(size * Math.cos(rotation))];
      }
      return size;
    }
    setViewportSize(size) {
      this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
      this.getAnimating() || this.resolveConstraints(0);
    }
    getCenter() {
      const center = this.getCenterInternal();
      return center ? (0,require$_DOT__SLASH_proj_DOT_js.toUserCoordinate)(center, this.getProjection()) : center;
    }
    getCenterInternal() {
      return this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.CENTER);
    }
    getConstraints() {
      return this.constraints_;
    }
    getConstrainResolution() {
      return this.get("constrainResolution");
    }
    getHints(hints) {
      return void 0 !== hints ? (hints[0] = this.hints_[0], hints[1] = this.hints_[1], hints) : this.hints_.slice();
    }
    calculateExtent(size) {
      size = this.calculateExtentInternal(size);
      return (0,require$_DOT__SLASH_proj_DOT_js.toUserExtent)(size, this.getProjection());
    }
    calculateExtentInternal(size) {
      size = size || this.getViewportSizeMinusPadding_();
      const center = this.getCenterInternal();
      (0,require$_DOT__SLASH_asserts_DOT_js.assert)(center, "The view center is not defined");
      const resolution = this.getResolution();
      (0,require$_DOT__SLASH_asserts_DOT_js.assert)(void 0 !== resolution, "The view resolution is not defined");
      const rotation = this.getRotation();
      (0,require$_DOT__SLASH_asserts_DOT_js.assert)(void 0 !== rotation, "The view rotation is not defined");
      return (0,require$_DOT__SLASH_extent_DOT_js.getForViewAndSize)(center, resolution, rotation, size);
    }
    getMaxResolution() {
      return this.maxResolution_;
    }
    getMinResolution() {
      return this.minResolution_;
    }
    getMaxZoom() {
      return this.getZoomForResolution(this.minResolution_);
    }
    setMaxZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({maxZoom:zoom}));
    }
    getMinZoom() {
      return this.getZoomForResolution(this.maxResolution_);
    }
    setMinZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({minZoom:zoom}));
    }
    setConstrainResolution(enabled) {
      this.applyOptions_(this.getUpdatedOptions_({constrainResolution:enabled}));
    }
    getProjection() {
      return this.projection_;
    }
    getResolution() {
      return this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.RESOLUTION);
    }
    getResolutions() {
      return this.resolutions_;
    }
    getResolutionForExtent(extent, size) {
      return this.getResolutionForExtentInternal((0,require$_DOT__SLASH_proj_DOT_js.fromUserExtent)(extent, this.getProjection()), size);
    }
    getResolutionForExtentInternal(extent, size) {
      size = size || this.getViewportSizeMinusPadding_();
      const xResolution = (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(extent) / size[0];
      extent = (0,require$_DOT__SLASH_extent_DOT_js.getHeight)(extent) / size[1];
      return Math.max(xResolution, extent);
    }
    getResolutionForValueFunction(power) {
      power = power || 2;
      const maxResolution = this.getConstrainedResolution(this.maxResolution_), max = Math.log(maxResolution / this.minResolution_) / Math.log(power);
      return function(value) {
        return maxResolution / Math.pow(power, value * max);
      };
    }
    getRotation() {
      return this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.ROTATION);
    }
    getValueForResolutionFunction(power) {
      const logPower = Math.log(power || 2), maxResolution = this.getConstrainedResolution(this.maxResolution_), max = Math.log(maxResolution / this.minResolution_) / logPower;
      return function(resolution) {
        return Math.log(maxResolution / resolution) / logPower / max;
      };
    }
    getViewportSizeMinusPadding_(rotation) {
      rotation = this.getViewportSize_(rotation);
      const padding = this.padding_;
      padding && (rotation = [rotation[0] - padding[1] - padding[3], rotation[1] - padding[0] - padding[2]]);
      return rotation;
    }
    getState() {
      const projection = this.getProjection(), resolution = this.getResolution(), rotation = this.getRotation();
      let center = this.getCenterInternal();
      const padding = this.padding_;
      if (padding) {
        const reducedSize = this.getViewportSizeMinusPadding_();
        center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      }
      return {center:center.slice(0), projection:void 0 !== projection ? projection : null, resolution, nextCenter:this.nextCenter_, nextResolution:this.nextResolution_, nextRotation:this.nextRotation_, rotation, zoom:this.getZoom()};
    }
    getViewStateAndExtent() {
      return {viewState:this.getState(), extent:this.calculateExtent()};
    }
    getZoom() {
      let zoom;
      const resolution = this.getResolution();
      void 0 !== resolution && (zoom = this.getZoomForResolution(resolution));
      return zoom;
    }
    getZoomForResolution(resolution) {
      let offset = this.minZoom_ || 0, max;
      var zoomFactor;
      this.resolutions_ ? (offset = zoomFactor = (0,require$_DOT__SLASH_array_DOT_js.linearFindNearest)(this.resolutions_, resolution, 1), max = this.resolutions_[zoomFactor], zoomFactor = zoomFactor == this.resolutions_.length - 1 ? 2 : max / this.resolutions_[zoomFactor + 1]) : (max = this.maxResolution_, zoomFactor = this.zoomFactor_);
      return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    getResolutionForZoom(zoom) {
      if (this.resolutions_?.length) {
        if (1 === this.resolutions_.length) {
          return this.resolutions_[0];
        }
        const baseLevel = (0,require$_DOT__SLASH_math_DOT_js.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
        return this.resolutions_[baseLevel] / Math.pow(this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1], (0,require$_DOT__SLASH_math_DOT_js.clamp)(zoom - baseLevel, 0, 1));
      }
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
    fit(geometryOrExtent, options) {
      (0,require$_DOT__SLASH_asserts_DOT_js.assert)(Array.isArray(geometryOrExtent) || "function" === typeof geometryOrExtent.getSimplifiedGeometry, "Invalid extent or geometry provided as `geometry`");
      if (Array.isArray(geometryOrExtent)) {
        (0,require$_DOT__SLASH_asserts_DOT_js.assert)(!(0,require$_DOT__SLASH_extent_DOT_js.isEmpty)(geometryOrExtent), "Cannot fit empty extent provided as `geometry`"), geometryOrExtent = (0,require$_DOT__SLASH_proj_DOT_js.fromUserExtent)(geometryOrExtent, this.getProjection()), geometryOrExtent = (0,require$_DOT__SLASH_geom_SLASH_Polygon_DOT_js.fromExtent)(geometryOrExtent);
      } else if ("Circle" === geometryOrExtent.getType()) {
        var extent = (0,require$_DOT__SLASH_proj_DOT_js.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
        geometryOrExtent = (0,require$_DOT__SLASH_geom_SLASH_Polygon_DOT_js.fromExtent)(extent);
        geometryOrExtent.rotate(this.getRotation(), (0,require$_DOT__SLASH_extent_DOT_js.getCenter)(extent));
      } else {
        geometryOrExtent = (extent = (0,require$_DOT__SLASH_proj_DOT_js.getUserProjection)()) ? geometryOrExtent.clone().transform(extent, this.getProjection()) : geometryOrExtent;
      }
      this.fitInternal(geometryOrExtent, options);
    }
    rotatedExtentForGeometry(geometry) {
      var rotation = this.getRotation();
      const cosAngle = Math.cos(rotation);
      rotation = Math.sin(-rotation);
      const coords = geometry.getFlatCoordinates();
      geometry = geometry.getStride();
      let minRotX = Infinity, minRotY = Infinity, maxRotX = -Infinity, maxRotY = -Infinity;
      for (let i = 0, ii = coords.length; i < ii; i += geometry) {
        const rotX = coords[i] * cosAngle - coords[i + 1] * rotation, rotY = coords[i] * rotation + coords[i + 1] * cosAngle;
        minRotX = Math.min(minRotX, rotX);
        minRotY = Math.min(minRotY, rotY);
        maxRotX = Math.max(maxRotX, rotX);
        maxRotY = Math.max(maxRotY, rotY);
      }
      return [minRotX, minRotY, maxRotX, maxRotY];
    }
    fitInternal(geometry, options) {
      options = options || {};
      var size = options.size;
      size || (size = this.getViewportSizeMinusPadding_());
      var padding = void 0 !== options.padding ? options.padding : [0, 0, 0, 0], nearest = void 0 !== options.nearest ? options.nearest : !1;
      var minResolution = void 0 !== options.minResolution ? options.minResolution : void 0 !== options.maxZoom ? this.getResolutionForZoom(options.maxZoom) : 0;
      geometry = this.rotatedExtentForGeometry(geometry);
      size = this.getResolutionForExtentInternal(geometry, [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
      size = isNaN(size) ? minResolution : Math.max(size, minResolution);
      size = this.getConstrainedResolution(size, nearest ? 0 : 1);
      minResolution = this.getRotation();
      nearest = Math.sin(minResolution);
      minResolution = Math.cos(minResolution);
      geometry = (0,require$_DOT__SLASH_extent_DOT_js.getCenter)(geometry);
      geometry[0] += (padding[1] - padding[3]) / 2 * size;
      geometry[1] += (padding[0] - padding[2]) / 2 * size;
      padding = this.getConstrainedCenter([geometry[0] * minResolution - geometry[1] * nearest, geometry[1] * minResolution + geometry[0] * nearest], size);
      geometry = options.callback ? options.callback : require$_DOT__SLASH_functions_DOT_js.VOID;
      void 0 !== options.duration ? this.animateInternal({resolution:size, center:padding, duration:options.duration, easing:options.easing}, geometry) : (this.targetResolution_ = size, this.targetCenter_ = padding, this.applyTargetState_(!1, !0), animationCallback(geometry, !0));
    }
    centerOn(coordinate, size, position) {
      this.centerOnInternal((0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
    }
    centerOnInternal(coordinate, size, position) {
      this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }
    calculateCenterShift(center, resolution, rotation, size) {
      const padding = this.padding_;
      if (padding && center) {
        var centerShift = this.getViewportSizeMinusPadding_(-rotation);
        resolution = calculateCenterOn(center, size, [centerShift[0] / 2 + padding[3], centerShift[1] / 2 + padding[0]], resolution, rotation);
        centerShift = [center[0] - resolution[0], center[1] - resolution[1]];
      }
      return centerShift;
    }
    isDef() {
      return !!this.getCenterInternal() && void 0 !== this.getResolution();
    }
    adjustCenter(deltaCoordinates) {
      const center = (0,require$_DOT__SLASH_proj_DOT_js.toUserCoordinate)(this.targetCenter_, this.getProjection());
      this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
    }
    adjustCenterInternal(deltaCoordinates) {
      const center = this.targetCenter_;
      this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
    }
    adjustResolution(ratio, anchor) {
      anchor = anchor && (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(anchor, this.getProjection());
      this.adjustResolutionInternal(ratio, anchor);
    }
    adjustResolutionInternal(ratio, anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      const size = this.getViewportSize_(this.getRotation());
      isMoving = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
      anchor && (this.targetCenter_ = this.calculateCenterZoom(isMoving, anchor));
      this.targetResolution_ *= ratio;
      this.applyTargetState_();
    }
    adjustZoom(delta, anchor) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    adjustRotation(delta, anchor) {
      anchor && (anchor = (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(anchor, this.getProjection()));
      this.adjustRotationInternal(delta, anchor);
    }
    adjustRotationInternal(delta, anchor) {
      var isMoving = this.getAnimating() || this.getInteracting();
      isMoving = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
      anchor && (this.targetCenter_ = this.calculateCenterRotate(isMoving, anchor));
      this.targetRotation_ += delta;
      this.applyTargetState_();
    }
    setCenter(center) {
      this.setCenterInternal(center ? (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(center, this.getProjection()) : center);
    }
    setCenterInternal(center) {
      this.targetCenter_ = center;
      this.applyTargetState_();
    }
    setHint(hint, delta) {
      this.hints_[hint] += delta;
      this.changed();
      return this.hints_[hint];
    }
    setResolution(resolution) {
      this.targetResolution_ = resolution;
      this.applyTargetState_();
    }
    setRotation(rotation) {
      this.targetRotation_ = rotation;
      this.applyTargetState_();
    }
    setZoom(zoom) {
      this.setResolution(this.getResolutionForZoom(zoom));
    }
    applyTargetState_(doNotCancelAnims, forceMoving) {
      var isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
      forceMoving = this.constraints_.rotation(this.targetRotation_, isMoving);
      const size = this.getViewportSize_(forceMoving), newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
      isMoving = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, forceMoving, size));
      this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.ROTATION) !== forceMoving && this.set(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.ROTATION, forceMoving);
      this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.RESOLUTION) !== newResolution && (this.set(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.RESOLUTION, newResolution), this.set("zoom", this.getZoom(), !0));
      isMoving && this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.CENTER) && (0,require$_DOT__SLASH_coordinate_DOT_js.equals)(this.get(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.CENTER), isMoving) || this.set(default$$require$_DOT__SLASH_ViewProperty_DOT_js.default.CENTER, isMoving);
      this.getAnimating() && !doNotCancelAnims && this.cancelAnimations();
      this.cancelAnchor_ = void 0;
    }
    resolveConstraints(duration, resolutionDirection, anchor) {
      duration = void 0 !== duration ? duration : 200;
      var direction = resolutionDirection || 0;
      resolutionDirection = this.constraints_.rotation(this.targetRotation_);
      var size = this.getViewportSize_(resolutionDirection);
      direction = this.constraints_.resolution(this.targetResolution_, direction, size);
      size = this.constraints_.center(this.targetCenter_, direction, size, !1, this.calculateCenterShift(this.targetCenter_, direction, resolutionDirection, size));
      0 !== duration || this.cancelAnchor_ ? (anchor = anchor || (0 === duration ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, this.getResolution() === direction && this.getRotation() === resolutionDirection && this.getCenterInternal() && (0,require$_DOT__SLASH_coordinate_DOT_js.equals)(this.getCenterInternal(), size) || (this.getAnimating() && this.cancelAnimations(), this.animateInternal({rotation:resolutionDirection, center:size, resolution:direction, duration, easing:require$_DOT__SLASH_easing_DOT_js.easeOut, 
      anchor}))) : (this.targetResolution_ = direction, this.targetRotation_ = resolutionDirection, this.targetCenter_ = size, this.applyTargetState_());
    }
    beginInteraction() {
      this.resolveConstraints(0);
      this.setHint(default$$require$_DOT__SLASH_ViewHint_DOT_js.default.INTERACTING, 1);
    }
    endInteraction(duration, resolutionDirection, anchor) {
      anchor = anchor && (0,require$_DOT__SLASH_proj_DOT_js.fromUserCoordinate)(anchor, this.getProjection());
      this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    endInteractionInternal(duration, resolutionDirection, anchor) {
      this.getInteracting() && (this.setHint(default$$require$_DOT__SLASH_ViewHint_DOT_js.default.INTERACTING, -1), this.resolveConstraints(duration, resolutionDirection, anchor));
    }
    getConstrainedCenter(targetCenter, targetResolution) {
      const size = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }
    getConstrainedZoom(targetZoom, direction) {
      targetZoom = this.getResolutionForZoom(targetZoom);
      return this.getZoomForResolution(this.getConstrainedResolution(targetZoom, direction));
    }
    getConstrainedResolution(targetResolution, direction) {
      direction = direction || 0;
      const size = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(targetResolution, direction, size);
    }
  }
  const $$default = View;
};

//# sourceMappingURL=module$node_modules$ol$View.js.map
