shadow$provide.module$node_modules$ol$source$Vector = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, VectorSourceEvent:{enumerable:!0, get:function() {
    return VectorSourceEvent;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  exports = require("module$node_modules$ol$Collection");
  var require$_DOT__DOT__SLASH_CollectionEventType_DOT_js = require("module$node_modules$ol$CollectionEventType"), require$_DOT__DOT__SLASH_ObjectEventType_DOT_js = require("module$node_modules$ol$ObjectEventType"), require$_DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH_asserts_DOT_js = require("module$node_modules$ol$asserts"), require$_DOT__DOT__SLASH_events_SLASH_Event_DOT_js = require("module$node_modules$ol$events$Event");
  global = require("module$node_modules$ol$events$EventType");
  var require$_DOT__DOT__SLASH_events_DOT_js = require("module$node_modules$ol$events"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_featureloader_DOT_js = require("module$node_modules$ol$featureloader"), require$_DOT__DOT__SLASH_functions_DOT_js = require("module$node_modules$ol$functions"), require$_DOT__DOT__SLASH_loadingstrategy_DOT_js = require("module$node_modules$ol$loadingstrategy"), require$_DOT__DOT__SLASH_obj_DOT_js = require("module$node_modules$ol$obj"), 
  require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js = require("module$node_modules$ol$render$Feature"), require$_DOT__DOT__SLASH_structs_SLASH_RBush_DOT_js = require("module$node_modules$ol$structs$RBush"), require$_DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util");
  module = require("module$node_modules$ol$source$Source");
  var require$_DOT__SLASH_VectorEventType_DOT_js = require("module$node_modules$ol$source$VectorEventType"), default$$require$_DOT__DOT__SLASH_CollectionEventType_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_CollectionEventType_DOT_js), default$$require$_DOT__SLASH_VectorEventType_DOT_js = require.esmDefault(require$_DOT__SLASH_VectorEventType_DOT_js), default$$require$_DOT__DOT__SLASH_Collection_DOT_js = require.esmDefault(exports), default$$require$_DOT__DOT__SLASH_structs_SLASH_RBush_DOT_js = 
  require.esmDefault(require$_DOT__DOT__SLASH_structs_SLASH_RBush_DOT_js), default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js), default$$require$_DOT__DOT__SLASH_ObjectEventType_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_ObjectEventType_DOT_js);
  exports = require.esmDefault(require$_DOT__DOT__SLASH_events_SLASH_Event_DOT_js);
  module = require.esmDefault(module);
  var default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js = require.esmDefault(global);
  class VectorSourceEvent extends exports.default {
    constructor(type, feature, features) {
      super(type);
      this.feature = feature;
      this.features = features;
    }
  }
  class VectorSource extends module.default {
    constructor(options) {
      options = options || {};
      super({attributions:options.attributions, interpolate:!0, projection:void 0, state:"ready", wrapX:void 0 !== options.wrapX ? options.wrapX : !0});
      this.on;
      this.once;
      this.un;
      this.loader_ = require$_DOT__DOT__SLASH_functions_DOT_js.VOID;
      this.format_ = options.format || null;
      this.overlaps_ = void 0 === options.overlaps ? !0 : options.overlaps;
      this.url_ = options.url;
      void 0 !== options.loader ? this.loader_ = options.loader : void 0 !== this.url_ && ((0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(this.format_, "`format` must be set when `url` is set"), this.loader_ = (0,require$_DOT__DOT__SLASH_featureloader_DOT_js.xhr)(this.url_, this.format_));
      this.strategy_ = void 0 !== options.strategy ? options.strategy : require$_DOT__DOT__SLASH_loadingstrategy_DOT_js.all;
      const useSpatialIndex = void 0 !== options.useSpatialIndex ? options.useSpatialIndex : !0;
      this.featuresRtree_ = useSpatialIndex ? new default$$require$_DOT__DOT__SLASH_structs_SLASH_RBush_DOT_js.default() : null;
      this.loadedExtentsRtree_ = new default$$require$_DOT__DOT__SLASH_structs_SLASH_RBush_DOT_js.default();
      this.loadingExtentsCount_ = 0;
      this.nullGeometryFeatures_ = {};
      this.idIndex_ = {};
      this.uidIndex_ = {};
      this.featureChangeKeys_ = {};
      this.featuresCollection_ = null;
      let collection, features;
      Array.isArray(options.features) ? features = options.features : options.features && (collection = options.features, features = collection.getArray());
      useSpatialIndex || void 0 !== collection || (collection = new default$$require$_DOT__DOT__SLASH_Collection_DOT_js.default(features));
      void 0 !== features && this.addFeaturesInternal(features);
      void 0 !== collection && this.bindFeaturesCollection_(collection);
    }
    addFeature(feature) {
      this.addFeatureInternal(feature);
      this.changed();
    }
    addFeatureInternal(feature) {
      var featureKey = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(feature);
      if (this.addToIndex_(featureKey, feature)) {
        this.setupChangeEvents_(featureKey, feature);
        var geometry = feature.getGeometry();
        geometry ? (featureKey = geometry.getExtent(), this.featuresRtree_ && this.featuresRtree_.insert(featureKey, feature)) : this.nullGeometryFeatures_[featureKey] = feature;
        this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.ADDFEATURE, feature));
      } else {
        this.featuresCollection_ && this.featuresCollection_.remove(feature);
      }
    }
    setupChangeEvents_(featureKey, feature) {
      feature instanceof default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js.default || (this.featureChangeKeys_[featureKey] = [(0,require$_DOT__DOT__SLASH_events_DOT_js.listen)(feature, default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE, this.handleFeatureChange_, this), (0,require$_DOT__DOT__SLASH_events_DOT_js.listen)(feature, default$$require$_DOT__DOT__SLASH_ObjectEventType_DOT_js.default.PROPERTYCHANGE, this.handleFeatureChange_, this)]);
    }
    addToIndex_(featureKey, feature) {
      let valid = !0;
      if (void 0 !== feature.getId()) {
        const id = String(feature.getId());
        if (id in this.idIndex_) {
          if (feature instanceof default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js.default) {
            const indexedFeature = this.idIndex_[id];
            indexedFeature instanceof default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js.default ? Array.isArray(indexedFeature) ? indexedFeature.push(feature) : this.idIndex_[id] = [indexedFeature, feature] : valid = !1;
          } else {
            valid = !1;
          }
        } else {
          this.idIndex_[id] = feature;
        }
      }
      valid && ((0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(!(featureKey in this.uidIndex_), "The passed `feature` was already added to the source"), this.uidIndex_[featureKey] = feature);
      return valid;
    }
    addFeatures(features) {
      this.addFeaturesInternal(features);
      this.changed();
    }
    addFeaturesInternal(features) {
      const extents = [], newFeatures = [], geometryFeatures = [];
      for (let i = 0, length = features.length; i < length; i++) {
        var feature = features[i], featureKey = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(feature);
        this.addToIndex_(featureKey, feature) && newFeatures.push(feature);
      }
      for (let i = 0, length = newFeatures.length; i < length; i++) {
        features = newFeatures[i], feature = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(features), this.setupChangeEvents_(feature, features), (featureKey = features.getGeometry()) ? (feature = featureKey.getExtent(), extents.push(feature), geometryFeatures.push(features)) : this.nullGeometryFeatures_[feature] = features;
      }
      this.featuresRtree_ && this.featuresRtree_.load(extents, geometryFeatures);
      if (this.hasListener(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.ADDFEATURE)) {
        for (let i = 0, length = newFeatures.length; i < length; i++) {
          this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.ADDFEATURE, newFeatures[i]));
        }
      }
    }
    bindFeaturesCollection_(collection) {
      let modifyingCollection = !1;
      this.addEventListener(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.ADDFEATURE, function(evt) {
        modifyingCollection || (modifyingCollection = !0, collection.push(evt.feature), modifyingCollection = !1);
      });
      this.addEventListener(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.REMOVEFEATURE, function(evt) {
        modifyingCollection || (modifyingCollection = !0, collection.remove(evt.feature), modifyingCollection = !1);
      });
      collection.addEventListener(default$$require$_DOT__DOT__SLASH_CollectionEventType_DOT_js.default.ADD, evt => {
        modifyingCollection || (modifyingCollection = !0, this.addFeature(evt.element), modifyingCollection = !1);
      });
      collection.addEventListener(default$$require$_DOT__DOT__SLASH_CollectionEventType_DOT_js.default.REMOVE, evt => {
        modifyingCollection || (modifyingCollection = !0, this.removeFeature(evt.element), modifyingCollection = !1);
      });
      this.featuresCollection_ = collection;
    }
    clear(fast) {
      if (fast) {
        for (const featureId in this.featureChangeKeys_) {
          this.featureChangeKeys_[featureId].forEach(require$_DOT__DOT__SLASH_events_DOT_js.unlistenByKey);
        }
        this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.forEach(feature => {
            this.removeFeatureInternal(feature);
          });
          for (const id in this.nullGeometryFeatures_) {
            this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
          }
        }
      }
      this.featuresCollection_ && this.featuresCollection_.clear();
      this.featuresRtree_ && this.featuresRtree_.clear();
      this.nullGeometryFeatures_ = {};
      fast = new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.CLEAR);
      this.dispatchEvent(fast);
      this.changed();
    }
    forEachFeature(callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEach(callback);
      }
      this.featuresCollection_ && this.featuresCollection_.forEach(callback);
    }
    forEachFeatureAtCoordinateDirect(coordinate, callback) {
      return this.forEachFeatureInExtent([coordinate[0], coordinate[1], coordinate[0], coordinate[1]], function(feature) {
        const geometry = feature.getGeometry();
        if (geometry instanceof default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js.default || geometry.intersectsCoordinate(coordinate)) {
          return callback(feature);
        }
      });
    }
    forEachFeatureInExtent(extent, callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEachInExtent(extent, callback);
      }
      this.featuresCollection_ && this.featuresCollection_.forEach(callback);
    }
    forEachFeatureIntersectingExtent(extent, callback) {
      return this.forEachFeatureInExtent(extent, function(feature) {
        const geometry = feature.getGeometry();
        if (geometry instanceof default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js.default || geometry.intersectsExtent(extent)) {
          if (feature = callback(feature)) {
            return feature;
          }
        }
      });
    }
    getFeaturesCollection() {
      return this.featuresCollection_;
    }
    getFeatures() {
      let features;
      this.featuresCollection_ ? features = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (features = this.featuresRtree_.getAll(), (0,require$_DOT__DOT__SLASH_obj_DOT_js.isEmpty)(this.nullGeometryFeatures_) || (0,require$_DOT__DOT__SLASH_array_DOT_js.extend)(features, Object.values(this.nullGeometryFeatures_)));
      return features;
    }
    getFeaturesAtCoordinate(coordinate) {
      const features = [];
      this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
        features.push(feature);
      });
      return features;
    }
    getFeaturesInExtent(extent, projection) {
      if (this.featuresRtree_) {
        if (!(projection && projection.canWrapX() && this.getWrapX())) {
          return this.featuresRtree_.getInExtent(extent);
        }
        extent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.wrapAndSliceX)(extent, projection);
        return [].concat(...extent.map(anExtent => this.featuresRtree_.getInExtent(anExtent)));
      }
      return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
    }
    getClosestFeatureToCoordinate(coordinate, filter) {
      const x = coordinate[0], y = coordinate[1];
      let closestFeature = null;
      const closestPoint = [NaN, NaN];
      let minSquaredDistance = Infinity;
      const extent = [-Infinity, -Infinity, Infinity, Infinity];
      filter = filter ? filter : require$_DOT__DOT__SLASH_functions_DOT_js.TRUE;
      this.featuresRtree_.forEachInExtent(extent, function(feature) {
        if (filter(feature)) {
          const geometry = feature.getGeometry(), previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry instanceof default$$require$_DOT__DOT__SLASH_render_SLASH_Feature_DOT_js.default ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
          minSquaredDistance < previousMinSquaredDistance && (closestFeature = feature, feature = Math.sqrt(minSquaredDistance), extent[0] = x - feature, extent[1] = y - feature, extent[2] = x + feature, extent[3] = y + feature);
        }
      });
      return closestFeature;
    }
    getExtent(extent) {
      return this.featuresRtree_.getExtent(extent);
    }
    getFeatureById(id) {
      id = this.idIndex_[id.toString()];
      return void 0 !== id ? id : null;
    }
    getFeatureByUid(uid) {
      uid = this.uidIndex_[uid];
      return void 0 !== uid ? uid : null;
    }
    getFormat() {
      return this.format_;
    }
    getOverlaps() {
      return this.overlaps_;
    }
    getUrl() {
      return this.url_;
    }
    handleFeatureChange_(event) {
      event = event.target;
      var featureKey = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(event), geometry = event.getGeometry();
      geometry ? (geometry = geometry.getExtent(), featureKey in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[featureKey], this.featuresRtree_ && this.featuresRtree_.insert(geometry, event)) : this.featuresRtree_ && this.featuresRtree_.update(geometry, event)) : featureKey in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(event), this.nullGeometryFeatures_[featureKey] = event);
      geometry = event.getId();
      void 0 !== geometry ? (featureKey = geometry.toString(), this.idIndex_[featureKey] !== event && (this.removeFromIdIndex_(event), this.idIndex_[featureKey] = event)) : (this.removeFromIdIndex_(event), this.uidIndex_[featureKey] = event);
      this.changed();
      this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.CHANGEFEATURE, event));
    }
    hasFeature(feature) {
      const id = feature.getId();
      return void 0 !== id ? id in this.idIndex_ : (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(feature) in this.uidIndex_;
    }
    isEmpty() {
      return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && (0,require$_DOT__DOT__SLASH_obj_DOT_js.isEmpty)(this.nullGeometryFeatures_) : this.featuresCollection_ ? 0 === this.featuresCollection_.getLength() : !0;
    }
    loadFeatures(extent, resolution, projection) {
      const loadedExtentsRtree = this.loadedExtentsRtree_;
      extent = this.strategy_(extent, resolution, projection);
      for (let i = 0, ii = extent.length; i < ii; ++i) {
        const extentToLoad = extent[i];
        loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {
          return (0,require$_DOT__DOT__SLASH_extent_DOT_js.containsExtent)(object.extent, extentToLoad);
        }) || (++this.loadingExtentsCount_, this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.FEATURESLOADSTART)), this.loader_.call(this, extentToLoad, resolution, projection, features => {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.FEATURESLOADEND, void 0, features));
        }, () => {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.FEATURESLOADERROR));
        }), loadedExtentsRtree.insert(extentToLoad, {extent:extentToLoad.slice()}));
      }
      this.loading = 4 > this.loader_.length ? !1 : 0 < this.loadingExtentsCount_;
    }
    refresh() {
      this.clear(!0);
      this.loadedExtentsRtree_.clear();
      super.refresh();
    }
    removeLoadedExtent(extent) {
      const loadedExtentsRtree = this.loadedExtentsRtree_, obj = loadedExtentsRtree.forEachInExtent(extent, function(object) {
        if ((0,require$_DOT__DOT__SLASH_extent_DOT_js.equals)(object.extent, extent)) {
          return object;
        }
      });
      obj && loadedExtentsRtree.remove(obj);
    }
    removeFeatures(features) {
      let removed = !1;
      for (let i = 0, ii = features.length; i < ii; ++i) {
        removed = this.removeFeatureInternal(features[i]) || removed;
      }
      removed && this.changed();
    }
    removeFeature(feature) {
      feature && this.removeFeatureInternal(feature) && this.changed();
    }
    removeFeatureInternal(feature) {
      const featureKey = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(feature);
      if (!(featureKey in this.uidIndex_)) {
        return !1;
      }
      featureKey in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[featureKey] : this.featuresRtree_ && this.featuresRtree_.remove(feature);
      this.featureChangeKeys_[featureKey]?.forEach(require$_DOT__DOT__SLASH_events_DOT_js.unlistenByKey);
      delete this.featureChangeKeys_[featureKey];
      var id = feature.getId();
      if (void 0 !== id) {
        id = id.toString();
        const indexedFeature = this.idIndex_[id];
        indexedFeature === feature ? delete this.idIndex_[id] : Array.isArray(indexedFeature) && (indexedFeature.splice(indexedFeature.indexOf(feature), 1), 1 === indexedFeature.length && (this.idIndex_[id] = indexedFeature[0]));
      }
      delete this.uidIndex_[featureKey];
      this.hasListener(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.REMOVEFEATURE) && this.dispatchEvent(new VectorSourceEvent(default$$require$_DOT__SLASH_VectorEventType_DOT_js.default.REMOVEFEATURE, feature));
      return !0;
    }
    removeFromIdIndex_(feature) {
      for (const id in this.idIndex_) {
        if (this.idIndex_[id] === feature) {
          delete this.idIndex_[id];
          break;
        }
      }
    }
    setLoader(loader) {
      this.loader_ = loader;
    }
    setUrl(url) {
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(this.format_, "`format` must be set when `url` is set");
      this.url_ = url;
      this.setLoader((0,require$_DOT__DOT__SLASH_featureloader_DOT_js.xhr)(url, this.format_));
    }
    setOverlaps(overlaps) {
      this.overlaps_ = overlaps;
      this.changed();
    }
  }
  const $$default = VectorSource;
};

//# sourceMappingURL=module$node_modules$ol$source$Vector.js.map
