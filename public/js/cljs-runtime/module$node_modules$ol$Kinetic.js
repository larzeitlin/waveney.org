shadow$provide.module$node_modules$ol$Kinetic = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  class Kinetic {
    constructor(decay, minVelocity, delay) {
      this.decay_ = decay;
      this.minVelocity_ = minVelocity;
      this.delay_ = delay;
      this.points_ = [];
      this.initialVelocity_ = this.angle_ = 0;
    }
    begin() {
      this.initialVelocity_ = this.angle_ = this.points_.length = 0;
    }
    update(x, y) {
      this.points_.push(x, y, Date.now());
    }
    end() {
      if (6 > this.points_.length) {
        return !1;
      }
      var delay = Date.now() - this.delay_, lastIndex = this.points_.length - 3;
      if (this.points_[lastIndex + 2] < delay) {
        return !1;
      }
      let firstIndex = lastIndex - 3;
      for (; 0 < firstIndex && this.points_[firstIndex + 2] > delay;) {
        firstIndex -= 3;
      }
      delay = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
      if (delay < 1000 / 60) {
        return !1;
      }
      const dx = this.points_[lastIndex] - this.points_[firstIndex];
      lastIndex = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
      this.angle_ = Math.atan2(lastIndex, dx);
      this.initialVelocity_ = Math.sqrt(dx * dx + lastIndex * lastIndex) / delay;
      return this.initialVelocity_ > this.minVelocity_;
    }
    getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    getAngle() {
      return this.angle_;
    }
  }
  const $$default = Kinetic;
};

//# sourceMappingURL=module$node_modules$ol$Kinetic.js.map
