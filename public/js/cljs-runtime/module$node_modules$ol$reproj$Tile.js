shadow$provide.module$node_modules$ol$reproj$Tile = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$Tile");
  module = require("module$node_modules$ol$TileState");
  var require$_DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom");
  exports = require("module$node_modules$ol$events$EventType");
  var require$_DOT__DOT__SLASH_events_DOT_js = require("module$node_modules$ol$events"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH_reproj_DOT_js = require("module$node_modules$ol$reproj"), require$_DOT__SLASH_Triangulation_DOT_js = require("module$node_modules$ol$reproj$Triangulation"), require$_DOT__SLASH_common_DOT_js = require("module$node_modules$ol$reproj$common"), 
  default$$require$_DOT__DOT__SLASH_TileState_DOT_js = require.esmDefault(module), default$$require$_DOT__SLASH_Triangulation_DOT_js = require.esmDefault(require$_DOT__SLASH_Triangulation_DOT_js), default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js = require.esmDefault(exports);
  require = require.esmDefault(global);
  class ReprojTile extends require.default {
    constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
      super(tileCoord, default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.IDLE, options);
      this.renderEdges_ = void 0 !== renderEdges ? renderEdges : !1;
      this.pixelRatio_ = pixelRatio;
      this.gutter_ = gutter;
      this.canvas_ = null;
      this.sourceTileGrid_ = sourceTileGrid;
      this.targetTileGrid_ = targetTileGrid;
      this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
      this.sourceTiles_ = [];
      this.sourcesListenerKeys_ = null;
      this.sourceZ_ = 0;
      this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
      wrappedTileCoord = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
      gutter = this.targetTileGrid_.getExtent();
      tileCoord = this.sourceTileGrid_.getExtent();
      gutter = gutter ? (0,require$_DOT__DOT__SLASH_extent_DOT_js.getIntersection)(wrappedTileCoord, gutter) : wrappedTileCoord;
      if (0 === (0,require$_DOT__DOT__SLASH_extent_DOT_js.getArea)(gutter)) {
        this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY;
      } else {
        if ((wrappedTileCoord = sourceProj.getExtent()) && (tileCoord = tileCoord ? (0,require$_DOT__DOT__SLASH_extent_DOT_js.getIntersection)(tileCoord, wrappedTileCoord) : wrappedTileCoord), targetTileGrid = targetTileGrid.getResolution(this.wrappedTileCoord_[0]), renderEdges = (0,require$_DOT__DOT__SLASH_reproj_DOT_js.calculateSourceExtentResolution)(sourceProj, targetProj, gutter, targetTileGrid), !isFinite(renderEdges) || 0 >= renderEdges) {
          this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY;
        } else {
          if (this.triangulation_ = new default$$require$_DOT__SLASH_Triangulation_DOT_js.default(sourceProj, targetProj, gutter, tileCoord, renderEdges * (void 0 !== errorThreshold ? errorThreshold : require$_DOT__SLASH_common_DOT_js.ERROR_THRESHOLD), targetTileGrid), 0 === this.triangulation_.getTriangles().length) {
            this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY;
          } else {
            if (this.sourceZ_ = sourceTileGrid.getZForResolution(renderEdges), targetProj = this.triangulation_.calculateSourceExtent(), tileCoord && (sourceProj.canWrapX() ? (targetProj[1] = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(targetProj[1], tileCoord[1], tileCoord[3]), targetProj[3] = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(targetProj[3], tileCoord[1], tileCoord[3])) : targetProj = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getIntersection)(targetProj, tileCoord)), (0,require$_DOT__DOT__SLASH_extent_DOT_js.getArea)(targetProj)) {
              let worldWidth = 0, worldsAway = 0;
              sourceProj.canWrapX() && (worldWidth = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(wrappedTileCoord), worldsAway = Math.floor((targetProj[0] - wrappedTileCoord[0]) / worldWidth));
              (0,require$_DOT__DOT__SLASH_extent_DOT_js.wrapAndSliceX)(targetProj.slice(), sourceProj, !0).forEach(extent => {
                extent = sourceTileGrid.getTileRangeForExtentAndZ(extent, this.sourceZ_);
                for (let srcX = extent.minX; srcX <= extent.maxX; srcX++) {
                  for (let srcY = extent.minY; srcY <= extent.maxY; srcY++) {
                    const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
                    tile && this.sourceTiles_.push({tile, offset:worldsAway * worldWidth});
                  }
                }
                ++worldsAway;
              });
              0 === this.sourceTiles_.length && (this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY);
            } else {
              this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY;
            }
          }
        }
      }
    }
    getImage() {
      return this.canvas_;
    }
    reproject_() {
      const sources = [];
      this.sourceTiles_.forEach(source => {
        const tile = source.tile;
        if (tile && tile.getState() == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.LOADED) {
          const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
          extent[0] += source.offset;
          extent[2] += source.offset;
          const clipExtent = this.clipExtent_?.slice();
          clipExtent && (clipExtent[0] += source.offset, clipExtent[2] += source.offset);
          sources.push({extent, clipExtent, image:tile.getImage()});
        }
      });
      this.sourceTiles_.length = 0;
      if (0 === sources.length) {
        this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.ERROR;
      } else {
        var z = this.wrappedTileCoord_[0], size = this.targetTileGrid_.getTileSize(z);
        const width = "number" === typeof size ? size : size[0];
        size = "number" === typeof size ? size : size[1];
        z = this.targetTileGrid_.getResolution(z);
        const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_), targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        this.canvas_ = (0,require$_DOT__DOT__SLASH_reproj_DOT_js.render)(width, size, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), z, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
        this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.LOADED;
      }
      this.changed();
    }
    load() {
      if (this.state == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.IDLE) {
        this.state = default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.LOADING;
        this.changed();
        let leftToLoad = 0;
        this.sourcesListenerKeys_ = [];
        this.sourceTiles_.forEach(({tile}) => {
          const state = tile.getState();
          if (state == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.IDLE || state == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.LOADING) {
            leftToLoad++;
            const sourceListenKey = (0,require$_DOT__DOT__SLASH_events_DOT_js.listen)(tile, default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE, e => {
              e = tile.getState();
              if (e == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.LOADED || e == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.ERROR || e == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY) {
                (0,require$_DOT__DOT__SLASH_events_DOT_js.unlistenByKey)(sourceListenKey), leftToLoad--, 0 === leftToLoad && (this.unlistenSources_(), this.reproject_());
              }
            });
            this.sourcesListenerKeys_.push(sourceListenKey);
          }
        });
        0 === leftToLoad ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({tile}, i, arr) {
          tile.getState() == default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.IDLE && tile.load();
        });
      }
    }
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(require$_DOT__DOT__SLASH_events_DOT_js.unlistenByKey);
      this.sourcesListenerKeys_ = null;
    }
    release() {
      this.canvas_ && ((0,require$_DOT__DOT__SLASH_dom_DOT_js.releaseCanvas)(this.canvas_.getContext("2d")), require$_DOT__DOT__SLASH_reproj_DOT_js.canvasPool.push(this.canvas_), this.canvas_ = null);
      super.release();
    }
  }
  const $$default = ReprojTile;
};

//# sourceMappingURL=module$node_modules$ol$reproj$Tile.js.map
