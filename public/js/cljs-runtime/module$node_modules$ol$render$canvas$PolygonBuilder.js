shadow$provide.module$node_modules$ol$render$canvas$PolygonBuilder = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_simplify_DOT_js = require("module$node_modules$ol$geom$flat$simplify"), require$_DOT__DOT__SLASH_canvas_DOT_js = require("module$node_modules$ol$render$canvas");
  global = require("module$node_modules$ol$render$canvas$Builder");
  var require$_DOT__SLASH_Instruction_DOT_js = require("module$node_modules$ol$render$canvas$Instruction"), default$$require$_DOT__SLASH_Instruction_DOT_js = require.esmDefault(require$_DOT__SLASH_Instruction_DOT_js);
  require = require.esmDefault(global);
  class CanvasPolygonBuilder extends require.default {
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
    }
    drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
      var state = this.state;
      const fill = void 0 !== state.fillStyle;
      state = void 0 !== state.strokeStyle;
      const numEnds = ends.length;
      this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.beginPathInstruction);
      this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.beginPathInstruction);
      for (let i = 0; i < numEnds; ++i) {
        const end = ends[i], myBegin = this.coordinates.length;
        offset = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, !0, !state);
        offset = [default$$require$_DOT__SLASH_Instruction_DOT_js.default.MOVE_TO_LINE_TO, myBegin, offset];
        this.instructions.push(offset);
        this.hitDetectionInstructions.push(offset);
        state && (this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.closePathInstruction), this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.closePathInstruction));
        offset = end;
      }
      fill && (this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.fillInstruction), this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.fillInstruction));
      state && (this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.strokeInstruction), this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.strokeInstruction));
      return offset;
    }
    drawCircle(circleGeometry, feature, index) {
      const state = this.state;
      var strokeStyle = state.strokeStyle;
      if (void 0 !== state.fillStyle || void 0 !== strokeStyle) {
        this.setFillStrokeStyles_(), this.beginGeometry(circleGeometry, feature, index), void 0 !== state.fillStyle && this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_FILL_STYLE, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle]), void 0 !== state.strokeStyle && this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, 
        require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset]), index = circleGeometry.getFlatCoordinates(), circleGeometry = circleGeometry.getStride(), strokeStyle = this.coordinates.length, this.appendFlatLineCoordinates(index, 0, index.length, circleGeometry, !1, !1), circleGeometry = [default$$require$_DOT__SLASH_Instruction_DOT_js.default.CIRCLE, strokeStyle], this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.beginPathInstruction, 
        circleGeometry), this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.beginPathInstruction, circleGeometry), void 0 !== state.fillStyle && (this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.fillInstruction), this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.fillInstruction)), void 0 !== state.strokeStyle && (this.instructions.push(require$_DOT__SLASH_Instruction_DOT_js.strokeInstruction), this.hitDetectionInstructions.push(require$_DOT__SLASH_Instruction_DOT_js.strokeInstruction)), 
        this.endGeometry(feature);
      }
    }
    drawPolygon(polygonGeometry, feature, index) {
      var state = this.state;
      const strokeStyle = state.strokeStyle;
      if (void 0 !== state.fillStyle || void 0 !== strokeStyle) {
        this.setFillStrokeStyles_(), this.beginGeometry(polygonGeometry, feature, index), void 0 !== state.fillStyle && this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_FILL_STYLE, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle]), void 0 !== state.strokeStyle && this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, 
        require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset]), index = polygonGeometry.getEnds(), state = polygonGeometry.getOrientedFlatCoordinates(), polygonGeometry = polygonGeometry.getStride(), this.drawFlatCoordinatess_(state, 0, index, polygonGeometry), this.endGeometry(feature);
      }
    }
    drawMultiPolygon(multiPolygonGeometry, feature, index) {
      var state = this.state, strokeStyle = state.strokeStyle;
      if (void 0 !== state.fillStyle || void 0 !== strokeStyle) {
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature, index);
        void 0 !== state.fillStyle && this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_FILL_STYLE, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle]);
        void 0 !== state.strokeStyle && this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset]);
        index = multiPolygonGeometry.getEndss();
        state = multiPolygonGeometry.getOrientedFlatCoordinates();
        multiPolygonGeometry = multiPolygonGeometry.getStride();
        strokeStyle = 0;
        for (let i = 0, ii = index.length; i < ii; ++i) {
          strokeStyle = this.drawFlatCoordinatess_(state, strokeStyle, index[i], multiPolygonGeometry);
        }
        this.endGeometry(feature);
      }
    }
    finish() {
      this.reverseHitDetectionInstructions();
      this.state = null;
      const tolerance = this.tolerance;
      if (0 !== tolerance) {
        const coordinates = this.coordinates;
        for (let i = 0, ii = coordinates.length; i < ii; ++i) {
          coordinates[i] = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_simplify_DOT_js.snap)(coordinates[i], tolerance);
        }
      }
      return super.finish();
    }
    setFillStrokeStyles_() {
      const state = this.state;
      void 0 !== state.fillStyle && this.updateFillStyle(state, this.createFill);
      void 0 !== state.strokeStyle && this.updateStrokeStyle(state, this.applyStroke);
    }
  }
  const $$default = CanvasPolygonBuilder;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$PolygonBuilder.js.map
