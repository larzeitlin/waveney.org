shadow$provide.module$node_modules$ol$source$TileImage = function(global, require, module, exports) {
  function defaultTileLoadFunction(imageTile, src) {
    imageTile.getImage().src = src;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  module = require("module$node_modules$ol$ImageTile");
  exports = require("module$node_modules$ol$TileState");
  global = require("module$node_modules$ol$events$EventType");
  var require$_DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj"), require$_DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js = require("module$node_modules$ol$reproj$Tile"), require$_DOT__DOT__SLASH_tilegrid_DOT_js = require("module$node_modules$ol$tilegrid"), require$_DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util"), require$_DOT__SLASH_UrlTile_DOT_js = require("module$node_modules$ol$source$UrlTile"), default$$require$_DOT__DOT__SLASH_ImageTile_DOT_js = require.esmDefault(module), 
  default$$require$_DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js), default$$require$_DOT__DOT__SLASH_TileState_DOT_js = require.esmDefault(exports);
  module = require.esmDefault(require$_DOT__SLASH_UrlTile_DOT_js);
  var default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js = require.esmDefault(global);
  class TileImage extends module.default {
    constructor(options) {
      super({attributions:options.attributions, cacheSize:options.cacheSize, projection:options.projection, state:options.state, tileGrid:options.tileGrid, tileLoadFunction:options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction, tilePixelRatio:options.tilePixelRatio, tileUrlFunction:options.tileUrlFunction, url:options.url, urls:options.urls, wrapX:options.wrapX, transition:options.transition, interpolate:void 0 !== options.interpolate ? options.interpolate : !0, key:options.key, 
      attributionsCollapsible:options.attributionsCollapsible, zDirection:options.zDirection});
      this.crossOrigin = void 0 !== options.crossOrigin ? options.crossOrigin : null;
      this.tileClass = void 0 !== options.tileClass ? options.tileClass : default$$require$_DOT__DOT__SLASH_ImageTile_DOT_js.default;
      this.tileGridForProjection = {};
      this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
      this.renderReprojectionEdges_ = !1;
    }
    getGutterForProjection(projection) {
      return this.getProjection() && projection && !(0,require$_DOT__DOT__SLASH_proj_DOT_js.equivalent)(this.getProjection(), projection) ? 0 : this.getGutter();
    }
    getGutter() {
      return 0;
    }
    getKey() {
      let key = super.getKey();
      this.getInterpolate() || (key += ":disable-interpolation");
      return key;
    }
    getTileGridForProjection(projection) {
      var thisProj = this.getProjection();
      if (this.tileGrid && (!thisProj || (0,require$_DOT__DOT__SLASH_proj_DOT_js.equivalent)(thisProj, projection))) {
        return this.tileGrid;
      }
      thisProj = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(projection);
      thisProj in this.tileGridForProjection || (this.tileGridForProjection[thisProj] = (0,require$_DOT__DOT__SLASH_tilegrid_DOT_js.getForProjection)(projection));
      return this.tileGridForProjection[thisProj];
    }
    createTile_(z, x, y, pixelRatio, projection, key) {
      z = [z, x, y];
      pixelRatio = (x = this.getTileCoordForTileUrlFunction(z, projection)) ? this.tileUrlFunction(x, pixelRatio, projection) : void 0;
      pixelRatio = new this.tileClass(z, void 0 !== pixelRatio ? default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.IDLE : default$$require$_DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY, void 0 !== pixelRatio ? pixelRatio : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
      pixelRatio.key = key;
      pixelRatio.addEventListener(default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE, this.handleTileChange.bind(this));
      return pixelRatio;
    }
    getTile(z, x, y, pixelRatio, projection) {
      const sourceProjection = this.getProjection();
      if (!sourceProjection || !projection || (0,require$_DOT__DOT__SLASH_proj_DOT_js.equivalent)(sourceProjection, projection)) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
      }
      x = [z, x, y];
      z = this.getKey();
      y = this.getTileGridForProjection(sourceProjection);
      const targetTileGrid = this.getTileGridForProjection(projection), wrappedTileCoord = this.getTileCoordForTileUrlFunction(x, projection);
      pixelRatio = new default$$require$_DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js.default(sourceProjection, y, projection, targetTileGrid, x, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), (z, x, y, pixelRatio) => this.getTileInternal(z, x, y, pixelRatio, sourceProjection), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.tileOptions);
      pixelRatio.key = z;
      return pixelRatio;
    }
    getTileInternal(z, x, y, pixelRatio, projection) {
      const key = this.getKey();
      return this.createTile_(z, x, y, pixelRatio, projection, key);
    }
    setRenderReprojectionEdges(render) {
      this.renderReprojectionEdges_ != render && (this.renderReprojectionEdges_ = render, this.changed());
    }
    setTileGridForProjection(projection, tilegrid) {
      if (projection = (0,require$_DOT__DOT__SLASH_proj_DOT_js.get)(projection)) {
        projection = (0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(projection), projection in this.tileGridForProjection || (this.tileGridForProjection[projection] = tilegrid);
      }
    }
  }
  const $$default = TileImage;
};

//# sourceMappingURL=module$node_modules$ol$source$TileImage.js.map
