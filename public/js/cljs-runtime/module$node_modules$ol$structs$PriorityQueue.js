shadow$provide.module$node_modules$ol$structs$PriorityQueue = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DROP:{enumerable:!0, get:function() {
    return Infinity;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_asserts_DOT_js = require("module$node_modules$ol$asserts"), require$_DOT__DOT__SLASH_obj_DOT_js = require("module$node_modules$ol$obj");
  class PriorityQueue {
    constructor(priorityFunction, keyFunction) {
      this.priorityFunction_ = priorityFunction;
      this.keyFunction_ = keyFunction;
      this.elements_ = [];
      this.priorities_ = [];
      this.queuedElements_ = {};
    }
    clear() {
      this.elements_.length = 0;
      this.priorities_.length = 0;
      (0,require$_DOT__DOT__SLASH_obj_DOT_js.clear)(this.queuedElements_);
    }
    dequeue() {
      var elements = this.elements_;
      const priorities = this.priorities_, element = elements[0];
      1 == elements.length ? (elements.length = 0, priorities.length = 0) : (elements[0] = elements.pop(), priorities[0] = priorities.pop(), this.siftUp_(0));
      elements = this.keyFunction_(element);
      delete this.queuedElements_[elements];
      return element;
    }
    enqueue(element) {
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(!(this.keyFunction_(element) in this.queuedElements_), "Tried to enqueue an `element` that was already added to the queue");
      const priority = this.priorityFunction_(element);
      return Infinity != priority ? (this.elements_.push(element), this.priorities_.push(priority), this.queuedElements_[this.keyFunction_(element)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
    }
    getCount() {
      return this.elements_.length;
    }
    getLeftChildIndex_(index) {
      return 2 * index + 1;
    }
    getRightChildIndex_(index) {
      return 2 * index + 2;
    }
    getParentIndex_(index) {
      return index - 1 >> 1;
    }
    heapify_() {
      let i;
      for (i = (this.elements_.length >> 1) - 1; 0 <= i; i--) {
        this.siftUp_(i);
      }
    }
    isEmpty() {
      return 0 === this.elements_.length;
    }
    isKeyQueued(key) {
      return key in this.queuedElements_;
    }
    isQueued(element) {
      return this.isKeyQueued(this.keyFunction_(element));
    }
    siftUp_(index) {
      const elements = this.elements_, priorities = this.priorities_, count = elements.length, element = elements[index], priority = priorities[index], startIndex = index;
      for (; index < count >> 1;) {
        var lIndex = this.getLeftChildIndex_(index);
        const rIndex = this.getRightChildIndex_(index);
        lIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
        elements[index] = elements[lIndex];
        priorities[index] = priorities[lIndex];
        index = lIndex;
      }
      elements[index] = element;
      priorities[index] = priority;
      this.siftDown_(startIndex, index);
    }
    siftDown_(startIndex, index) {
      const elements = this.elements_, priorities = this.priorities_, element = elements[index], priority = priorities[index];
      for (; index > startIndex;) {
        const parentIndex = this.getParentIndex_(index);
        if (priorities[parentIndex] > priority) {
          elements[index] = elements[parentIndex], priorities[index] = priorities[parentIndex], index = parentIndex;
        } else {
          break;
        }
      }
      elements[index] = element;
      priorities[index] = priority;
    }
    reprioritize() {
      const priorityFunction = this.priorityFunction_, elements = this.elements_, priorities = this.priorities_;
      let index = 0;
      const n = elements.length;
      let element, i, priority;
      for (i = 0; i < n; ++i) {
        element = elements[i], priority = priorityFunction(element), Infinity == priority ? delete this.queuedElements_[this.keyFunction_(element)] : (priorities[index] = priority, elements[index++] = element);
      }
      elements.length = index;
      priorities.length = index;
      this.heapify_();
    }
  }
  const $$default = PriorityQueue;
};

//# sourceMappingURL=module$node_modules$ol$structs$PriorityQueue.js.map
