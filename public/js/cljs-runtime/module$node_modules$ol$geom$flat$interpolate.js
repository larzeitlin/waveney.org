shadow$provide.module$node_modules$ol$geom$flat$interpolate = function(global, require, module, exports) {
  function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
    let t;
    var n = (end - offset) / stride;
    if (1 === n) {
      var o = offset;
    } else if (2 === n) {
      o = offset, t = fraction;
    } else if (0 !== n) {
      n = flatCoordinates[offset];
      let y1 = flatCoordinates[offset + 1], length = 0;
      o = [0];
      for (let i = offset + stride; i < end; i += stride) {
        const x2 = flatCoordinates[i], y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - n) * (x2 - n) + (y2 - y1) * (y2 - y1));
        o.push(length);
        n = x2;
        y1 = y2;
      }
      end = fraction * length;
      fraction = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.binarySearch)(o, end);
      0 > fraction ? (t = (end - o[-fraction - 2]) / (o[-fraction - 1] - o[-fraction - 2]), o = offset + (-fraction - 2) * stride) : o = offset + fraction * stride;
    }
    dimension = 1 < dimension ? dimension : 2;
    dest = dest ? dest : Array(dimension);
    for (offset = 0; offset < dimension; ++offset) {
      dest[offset] = void 0 === o ? NaN : void 0 === t ? flatCoordinates[o + offset] : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(flatCoordinates[o + offset], flatCoordinates[o + stride + offset], t);
    }
    return dest;
  }
  function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) {
      return null;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return extrapolate ? (end = flatCoordinates.slice(offset, offset + stride), end[stride - 1] = m, end) : null;
    }
    if (flatCoordinates[end - 1] < m) {
      return extrapolate ? (end = flatCoordinates.slice(end - stride, end), end[stride - 1] = m, end) : null;
    }
    if (m == flatCoordinates[offset + stride - 1]) {
      return flatCoordinates.slice(offset, offset + stride);
    }
    offset /= stride;
    for (end /= stride; offset < end;) {
      extrapolate = offset + end >> 1, m < flatCoordinates[(extrapolate + 1) * stride - 1] ? end = extrapolate : offset = extrapolate + 1;
    }
    end = flatCoordinates[offset * stride - 1];
    if (m == end) {
      return flatCoordinates.slice((offset - 1) * stride, (offset - 1) * stride + stride);
    }
    extrapolate = (m - end) / (flatCoordinates[(offset + 1) * stride - 1] - end);
    end = [];
    for (let i = 0; i < stride - 1; ++i) {
      end.push((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(flatCoordinates[(offset - 1) * stride + i], flatCoordinates[offset * stride + i], extrapolate));
    }
    end.push(m);
    return end;
  }
  function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) {
      return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    }
    if (m < flatCoordinates[stride - 1]) {
      return extrapolate ? (flatCoordinates = flatCoordinates.slice(0, stride), flatCoordinates[stride - 1] = m, flatCoordinates) : null;
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
      return extrapolate ? (flatCoordinates = flatCoordinates.slice(flatCoordinates.length - stride), flatCoordinates[stride - 1] = m, flatCoordinates) : null;
    }
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      if (extrapolate = ends[i], offset != extrapolate) {
        if (m < flatCoordinates[offset + stride - 1]) {
          break;
        }
        if (m <= flatCoordinates[extrapolate - 1]) {
          return lineStringCoordinateAtM(flatCoordinates, offset, extrapolate, stride, m, !1);
        }
        offset = extrapolate;
      }
    }
    return null;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, interpolatePoint:{enumerable:!0, get:function() {
    return interpolatePoint;
  }}, lineStringCoordinateAtM:{enumerable:!0, get:function() {
    return lineStringCoordinateAtM;
  }}, lineStringsCoordinateAtM:{enumerable:!0, get:function() {
    return lineStringsCoordinateAtM;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math");
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$interpolate.js.map
