shadow$provide.module$node_modules$ol$reproj$Triangulation = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj"), require$_DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform");
  class Triangulation {
    constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution, sourceMatrix) {
      this.sourceProj_ = sourceProj;
      this.targetProj_ = targetProj;
      let transformInvCache = {};
      const transformInv = sourceMatrix ? (0,require$_DOT__DOT__SLASH_proj_DOT_js.createTransformFromCoordinateTransform)(input => (0,require$_DOT__DOT__SLASH_transform_DOT_js.apply)(sourceMatrix, (0,require$_DOT__DOT__SLASH_proj_DOT_js.transform)(input, this.targetProj_, this.sourceProj_))) : (0,require$_DOT__DOT__SLASH_proj_DOT_js.getTransform)(this.targetProj_, this.sourceProj_);
      this.transformInv_ = function(c) {
        const key = c[0] + "/" + c[1];
        transformInvCache[key] || (transformInvCache[key] = transformInv(c));
        return transformInvCache[key];
      };
      this.maxSourceExtent_ = maxSourceExtent;
      this.errorThresholdSquared_ = errorThreshold * errorThreshold;
      this.triangles_ = [];
      this.wrapsXInSource_ = !1;
      this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(maxSourceExtent) >= (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(this.sourceProj_.getExtent());
      this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(this.sourceProj_.getExtent()) : null;
      this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(this.targetProj_.getExtent()) : null;
      sourceProj = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getTopLeft)(targetExtent);
      targetProj = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getTopRight)(targetExtent);
      maxSourceExtent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getBottomRight)(targetExtent);
      errorThreshold = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getBottomLeft)(targetExtent);
      const sourceTopLeft = this.transformInv_(sourceProj), sourceTopRight = this.transformInv_(targetProj), sourceBottomRight = this.transformInv_(maxSourceExtent), sourceBottomLeft = this.transformInv_(errorThreshold);
      targetExtent = 10 + (destinationResolution ? Math.max(0, Math.ceil(Math.log2((0,require$_DOT__DOT__SLASH_extent_DOT_js.getArea)(targetExtent) / (destinationResolution * destinationResolution * 65536)))) : 0);
      this.addQuad_(sourceProj, targetProj, maxSourceExtent, errorThreshold, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, targetExtent);
      if (this.wrapsXInSource_) {
        let leftBound = Infinity;
        this.triangles_.forEach(function(triangle, i, arr) {
          leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
        });
        this.triangles_.forEach(triangle => {
          if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
            const newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
            newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2 && (newTriangle[0][0] -= this.sourceWorldWidth_);
            newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2 && (newTriangle[1][0] -= this.sourceWorldWidth_);
            newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2 && (newTriangle[2][0] -= this.sourceWorldWidth_);
            Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]) - Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]) < this.sourceWorldWidth_ / 2 && (triangle.source = newTriangle);
          }
        });
      }
      transformInvCache = {};
    }
    addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
      this.triangles_.push({source:[aSrc, bSrc, cSrc], target:[a, b, c]});
    }
    addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
      var sourceQuadExtent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
      const sourceCoverageX = this.sourceWorldWidth_ ? (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
      var sourceWorldWidth = this.sourceWorldWidth_, wrapsX = this.sourceProj_.canWrapX() && 0.5 < sourceCoverageX && 1 > sourceCoverageX, needsSubdivision = !1;
      if (0 < maxSubdivision) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          const targetQuadExtent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.boundingExtent)([a, b, c, d]);
          needsSubdivision = 0.25 < (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(targetQuadExtent) / this.targetWorldWidth_ || needsSubdivision;
        }
        !wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX && (needsSubdivision = 0.25 < sourceCoverageX || needsSubdivision);
      }
      if (needsSubdivision || !this.maxSourceExtent_ || !(isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) || (0,require$_DOT__DOT__SLASH_extent_DOT_js.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
        sourceQuadExtent = 0;
        if (!(needsSubdivision || isFinite(aSrc[0]) && isFinite(aSrc[1]) && isFinite(bSrc[0]) && isFinite(bSrc[1]) && isFinite(cSrc[0]) && isFinite(cSrc[1]) && isFinite(dSrc[0]) && isFinite(dSrc[1]))) {
          if (0 < maxSubdivision) {
            needsSubdivision = !0;
          } else {
            if (sourceQuadExtent = (isFinite(aSrc[0]) && isFinite(aSrc[1]) ? 0 : 8) + (isFinite(bSrc[0]) && isFinite(bSrc[1]) ? 0 : 4) + (isFinite(cSrc[0]) && isFinite(cSrc[1]) ? 0 : 2) + (isFinite(dSrc[0]) && isFinite(dSrc[1]) ? 0 : 1), 1 != sourceQuadExtent && 2 != sourceQuadExtent && 4 != sourceQuadExtent && 8 != sourceQuadExtent) {
              return;
            }
          }
        }
        if (0 < maxSubdivision && (needsSubdivision || (needsSubdivision = this.transformInv_([(a[0] + c[0]) / 2, (a[1] + c[1]) / 2]), sourceWorldWidth = wrapsX ? ((0,require$_DOT__DOT__SLASH_math_DOT_js.modulo)(aSrc[0], sourceWorldWidth) + (0,require$_DOT__DOT__SLASH_math_DOT_js.modulo)(cSrc[0], sourceWorldWidth)) / 2 - (0,require$_DOT__DOT__SLASH_math_DOT_js.modulo)(needsSubdivision[0], sourceWorldWidth) : (aSrc[0] + cSrc[0]) / 2 - needsSubdivision[0], needsSubdivision = (aSrc[1] + cSrc[1]) / 2 - 
        needsSubdivision[1], needsSubdivision = sourceWorldWidth * sourceWorldWidth + needsSubdivision * needsSubdivision > this.errorThresholdSquared_), needsSubdivision)) {
          Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1]) ? (wrapsX = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2], sourceWorldWidth = this.transformInv_(wrapsX), needsSubdivision = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2], sourceQuadExtent = this.transformInv_(needsSubdivision), this.addQuad_(a, b, wrapsX, needsSubdivision, aSrc, bSrc, sourceWorldWidth, sourceQuadExtent, maxSubdivision - 1), this.addQuad_(needsSubdivision, wrapsX, c, d, sourceQuadExtent, sourceWorldWidth, cSrc, dSrc, maxSubdivision - 1)) : 
          (wrapsX = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2], sourceWorldWidth = this.transformInv_(wrapsX), needsSubdivision = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2], sourceQuadExtent = this.transformInv_(needsSubdivision), this.addQuad_(a, wrapsX, needsSubdivision, d, aSrc, sourceWorldWidth, sourceQuadExtent, dSrc, maxSubdivision - 1), this.addQuad_(wrapsX, b, c, needsSubdivision, sourceWorldWidth, bSrc, cSrc, sourceQuadExtent, maxSubdivision - 1));
          return;
        }
        if (wrapsX) {
          if (!this.canWrapXInSource_) {
            return;
          }
          this.wrapsXInSource_ = !0;
        }
        0 == (sourceQuadExtent & 11) && this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
        0 == (sourceQuadExtent & 14) && this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
        sourceQuadExtent && (0 == (sourceQuadExtent & 13) && this.addTriangle_(b, d, a, bSrc, dSrc, aSrc), 0 == (sourceQuadExtent & 7) && this.addTriangle_(b, d, c, bSrc, dSrc, cSrc));
      }
    }
    calculateSourceExtent() {
      const extent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.createEmpty)();
      this.triangles_.forEach(function(triangle, i, arr) {
        triangle = triangle.source;
        (0,require$_DOT__DOT__SLASH_extent_DOT_js.extendCoordinate)(extent, triangle[0]);
        (0,require$_DOT__DOT__SLASH_extent_DOT_js.extendCoordinate)(extent, triangle[1]);
        (0,require$_DOT__DOT__SLASH_extent_DOT_js.extendCoordinate)(extent, triangle[2]);
      });
      return extent;
    }
    getTriangles() {
      return this.triangles_;
    }
  }
  const $$default = Triangulation;
};

//# sourceMappingURL=module$node_modules$ol$reproj$Triangulation.js.map
