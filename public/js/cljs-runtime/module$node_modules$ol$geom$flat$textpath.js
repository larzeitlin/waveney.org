shadow$provide.module$node_modules$ol$geom$flat$textpath = function(global, require, module, exports) {
  function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation, keepUpright = !0) {
    function advance() {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    let x2 = flatCoordinates[offset], y2 = flatCoordinates[offset + 1], x1 = 0, y1 = 0, segmentLength = 0, segmentM = 0;
    do {
      advance();
    } while (offset < end - stride && segmentM + segmentLength < startM);
    var interpolate = 0 === segmentLength ? 0 : (startM - segmentM) / segmentLength, beginX = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(x1, x2, interpolate), beginY = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(y1, y2, interpolate), startOffset = offset - stride, startLength = segmentM;
    const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
    for (; offset < end - stride && segmentM + segmentLength < endM;) {
      advance();
    }
    interpolate = 0 === segmentLength ? 0 : (endM - segmentM) / segmentLength;
    const endX = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(x1, x2, interpolate);
    interpolate = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(y1, y2, interpolate);
    var reverse = !1;
    keepUpright && (rotation ? (reverse = [beginX, beginY, endX, interpolate], (0,require$_DOT__SLASH_transform_DOT_js.rotate)(reverse, 0, 4, 2, rotation, reverse, reverse), reverse = reverse[0] > reverse[2]) : reverse = beginX > endX);
    rotation = Math.PI;
    keepUpright = [];
    const singleSegment = startOffset + stride === offset;
    offset = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (singleSegment) {
      advance();
      var previousAngle = Math.atan2(y2 - y1, x2 - x1);
      reverse && (previousAngle += 0 < previousAngle ? -rotation : rotation);
      keepUpright[0] = [(endX + beginX) / 2, (interpolate + beginY) / 2, (endM - startM) / 2, previousAngle, text];
      return keepUpright;
    }
    text = text.replace(/\n/g, " ");
    for (let i = 0, ii = text.length; i < ii;) {
      advance();
      beginX = Math.atan2(y2 - y1, x2 - x1);
      reverse && (beginX += 0 < beginX ? -rotation : rotation);
      if (void 0 !== previousAngle && (previousAngle = beginX - previousAngle, previousAngle += previousAngle > rotation ? -2 * rotation : previousAngle < -rotation ? 2 * rotation : 0, Math.abs(previousAngle) > maxAngle)) {
        return null;
      }
      previousAngle = beginX;
      interpolate = i;
      for (beginY = 0; i < ii; ++i) {
        startOffset = scale * measureAndCacheTextWidth(font, text[reverse ? ii - i - 1 : i], cache);
        if (offset + stride < end && segmentM + segmentLength < startM + beginY + startOffset / 2) {
          break;
        }
        beginY += startOffset;
      }
      i !== interpolate && (startOffset = reverse ? text.substring(ii - interpolate, ii - i) : text.substring(interpolate, i), interpolate = 0 === segmentLength ? 0 : (startM + beginY / 2 - segmentM) / segmentLength, startLength = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(x1, x2, interpolate), interpolate = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(y1, y2, interpolate), keepUpright.push([startLength, interpolate, beginY / 2, beginX, startOffset]), startM += 
      beginY);
    }
    return keepUpright;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, drawTextOnPath:{enumerable:!0, get:function() {
    return drawTextOnPath;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$geom$flat$transform");
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$textpath.js.map
