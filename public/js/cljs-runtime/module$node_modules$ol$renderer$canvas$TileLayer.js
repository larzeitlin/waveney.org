shadow$provide.module$node_modules$ol$renderer$canvas$TileLayer = function(global, require, module, exports) {
  function addTileToLookup(tilesByZ, tile, z) {
    if (!(z in tilesByZ)) {
      return tilesByZ[z] = new Set([tile]), !0;
    }
    tilesByZ = tilesByZ[z];
    (z = tilesByZ.has(tile)) || tilesByZ.add(tile);
    return !z;
  }
  function removeTileFromLookup(tilesByZ, tile, z) {
    return (tilesByZ = tilesByZ[z]) ? tilesByZ.delete(tile) : !1;
  }
  function getRenderExtent(frameState, extent) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    layerState.extent && (extent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getIntersection)(extent, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.fromUserExtent)(layerState.extent, frameState.viewState.projection)));
    layerState = layerState.layer.getRenderSource();
    layerState.getWrapX() || (frameState = layerState.getTileGridForProjection(frameState.viewState.projection).getExtent()) && (extent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getIntersection)(extent, frameState));
    return extent;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js = require("module$node_modules$ol$DataTile");
  module = require("module$node_modules$ol$ImageTile");
  exports = require("module$node_modules$ol$TileRange");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js = require("module$node_modules$ol$TileState"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js = require("module$node_modules$ol$reproj$Tile"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_size_DOT_js = require("module$node_modules$ol$size");
  global = require("module$node_modules$ol$structs$LRUCache");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_tilecoord_DOT_js = require("module$node_modules$ol$tilecoord"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util"), require$_DOT__SLASH_Layer_DOT_js = require("module$node_modules$ol$renderer$canvas$Layer"), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js), 
  default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileRange_DOT_js = require.esmDefault(exports), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ImageTile_DOT_js = require.esmDefault(module);
  module = require.esmDefault(require$_DOT__SLASH_Layer_DOT_js);
  var default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_structs_SLASH_LRUCache_DOT_js = require.esmDefault(global);
  class CanvasTileLayerRenderer extends module.default {
    constructor(tileLayer, options) {
      super(tileLayer);
      options = options || {};
      this.extentChanged = !0;
      this.renderComplete = !1;
      this.renderedExtent_ = null;
      this.renderedPixelRatio;
      this.renderedProjection = null;
      this.renderedRevision_;
      this.renderedTiles = [];
      this.renderedSourceKey_;
      this.renderedSourceRevision_;
      this.tempExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createEmpty)();
      this.tempTileRange_ = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileRange_DOT_js.default(0, 0, 0, 0);
      this.tempTileCoord_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_tilecoord_DOT_js.createOrUpdate)(0, 0, 0);
      tileLayer = void 0 !== options.cacheSize ? options.cacheSize : 512;
      this.tileCache_ = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_structs_SLASH_LRUCache_DOT_js.default(tileLayer);
      this.maxStaleKeys = 0.5 * tileLayer;
    }
    getTileCache() {
      return this.tileCache_;
    }
    getOrCreateTile(z, x, y, frameState) {
      const tileCache = this.tileCache_, tileSource = this.getLayer().getSource();
      var JSCompiler_inline_result = `${tileSource.getKey()},${(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_tilecoord_DOT_js.getKeyZXY)(z, x, y)}`;
      if (tileCache.containsKey(JSCompiler_inline_result)) {
        z = tileCache.get(JSCompiler_inline_result);
      } else {
        z = tileSource.getTile(z, x, y, frameState.pixelRatio, frameState.viewState.projection);
        if (!z) {
          return null;
        }
        tileCache.set(JSCompiler_inline_result, z);
      }
      return z;
    }
    getTile(z, x, y, frameState) {
      return (z = this.getOrCreateTile(z, x, y, frameState)) ? z : null;
    }
    getData(pixel) {
      var frameState = this.frameState;
      if (!frameState) {
        return null;
      }
      var layer = this.getLayer();
      pixel = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      var layerExtent = layer.getExtent();
      if (layerExtent && !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(layerExtent, pixel)) {
        return null;
      }
      layerExtent = frameState.viewState;
      layer = layer.getRenderSource();
      const tileGrid = layer.getTileGridForProjection(layerExtent.projection), tilePixelRatio = layer.getTilePixelRatio(frameState.pixelRatio);
      for (let z = tileGrid.getZForResolution(layerExtent.resolution); z >= tileGrid.getMinZoom(); --z) {
        const tileCoord = tileGrid.getTileCoordForCoordAndZ(pixel, z);
        var tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);
        if (!tile || tile.getState() !== default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.LOADED) {
          continue;
        }
        const tileOrigin = tileGrid.getOrigin(z), tileSize = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_size_DOT_js.toSize)(tileGrid.getTileSize(z)), tileResolution = tileGrid.getResolution(z);
        if (tile instanceof default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ImageTile_DOT_js.default || tile instanceof default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_reproj_SLASH_Tile_DOT_js.default) {
          tile = tile.getImage();
        } else if (tile instanceof default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js.default) {
          if (tile = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js.asImageLike)(tile.getData()), !tile) {
            continue;
          }
        } else {
          continue;
        }
        frameState = Math.floor(tilePixelRatio * ((pixel[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
        pixel = Math.floor(tilePixelRatio * ((tileOrigin[1] - pixel[1]) / tileResolution - tileCoord[2] * tileSize[1]));
        layerExtent = Math.round(tilePixelRatio * layer.getGutterForProjection(layerExtent.projection));
        return this.getImageData(tile, frameState + layerExtent, pixel + layerExtent);
      }
      return null;
    }
    prepareFrame(frameState) {
      this.renderedProjection ? frameState.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = frameState.viewState.projection) : this.renderedProjection = frameState.viewState.projection;
      frameState = this.getLayer().getSource();
      if (!frameState) {
        return !1;
      }
      const sourceRevision = frameState.getRevision();
      this.renderedRevision_ ? this.renderedRevision_ !== sourceRevision && (this.renderedRevision_ = sourceRevision, this.renderedSourceKey_ === frameState.getKey() && this.tileCache_.clear()) : this.renderedRevision_ = sourceRevision;
      return !0;
    }
    enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
      var viewState = frameState.viewState, tileLayer = this.getLayer(), tileSource = tileLayer.getRenderSource();
      const tileGrid = tileSource.getTileGridForProjection(viewState.projection), tileSourceKey = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(tileSource);
      tileSourceKey in frameState.wantedTiles || (frameState.wantedTiles[tileSourceKey] = {});
      const wantedTiles = frameState.wantedTiles[tileSourceKey];
      var map = tileLayer.getMapInternal();
      preload = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));
      for (viewState = (tileLayer = viewState.rotation) ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getRotatedViewport)(viewState.center, viewState.resolution, tileLayer, frameState.size) : void 0; initialZ >= preload; --initialZ) {
        tileSource = tileGrid.getTileRangeForExtentAndZ(extent, initialZ, this.tempTileRange_);
        map = tileGrid.getResolution(initialZ);
        for (let x = tileSource.minX; x <= tileSource.maxX; ++x) {
          for (let y = tileSource.minY; y <= tileSource.maxY; ++y) {
            if (tileLayer && !tileGrid.tileCoordIntersectsViewport([initialZ, x, y], viewState)) {
              continue;
            }
            const tile = this.getTile(initialZ, x, y, frameState);
            if (tile && addTileToLookup(tilesByZ, tile, initialZ)) {
              var tileQueueKey = tile.getKey();
              wantedTiles[tileQueueKey] = !0;
              tile.getState() !== default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.IDLE || frameState.tileQueue.isKeyQueued(tileQueueKey) || (tileQueueKey = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_tilecoord_DOT_js.createOrUpdate)(initialZ, x, y, this.tempTileCoord_), frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileQueueKey), map]));
            }
          }
        }
      }
    }
    findStaleTile_(tileCoord, tilesByZ) {
      const tileCache = this.tileCache_, z = tileCoord[0], x = tileCoord[1];
      tileCoord = tileCoord[2];
      const staleKeys = this.getStaleKeys();
      for (let i = 0; i < staleKeys.length; ++i) {
        var cacheKey = `${staleKeys[i]},${(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_tilecoord_DOT_js.getKeyZXY)(z, x, tileCoord)}`;
        if (tileCache.containsKey(cacheKey) && (cacheKey = tileCache.peek(cacheKey), cacheKey.getState() === default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.LOADED)) {
          return cacheKey.endTransition((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(this)), addTileToLookup(tilesByZ, cacheKey, z), !0;
        }
      }
      return !1;
    }
    findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
      tileGrid = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
      if (!tileGrid) {
        return !1;
      }
      tileCoord = !0;
      const tileCache = this.tileCache_, sourceKey = this.getLayer().getRenderSource().getKey();
      for (let x = tileGrid.minX; x <= tileGrid.maxX; ++x) {
        for (let y = tileGrid.minY; y <= tileGrid.maxY; ++y) {
          var cacheKey = `${sourceKey},${(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_tilecoord_DOT_js.getKeyZXY)(altZ, x, y)}`;
          let loaded = !1;
          tileCache.containsKey(cacheKey) && (cacheKey = tileCache.peek(cacheKey), cacheKey.getState() === default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.LOADED && (addTileToLookup(tilesByZ, cacheKey, altZ), loaded = !0));
          loaded || (tileCoord = !1);
        }
      }
      return tileCoord;
    }
    renderFrame(frameState, target) {
      let allTilesIdle = !0;
      this.renderComplete = !0;
      const layerState = frameState.layerStatesArray[frameState.layerIndex];
      var viewState = frameState.viewState;
      const projection = viewState.projection;
      var viewResolution = viewState.resolution, viewCenter = viewState.center;
      const pixelRatio = frameState.pixelRatio;
      var tileLayer = this.getLayer();
      const tileSource = tileLayer.getSource(), tileGrid = tileSource.getTileGridForProjection(projection), z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection), tileResolution = tileGrid.getResolution(z);
      var sourceKey = tileSource.getKey();
      this.renderedSourceKey_ ? this.renderedSourceKey_ !== sourceKey && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = sourceKey) : this.renderedSourceKey_ = sourceKey;
      var frameExtent = frameState.extent;
      sourceKey = tileSource.getTilePixelRatio(pixelRatio);
      this.prepareContainer(frameState, target);
      target = this.context.canvas.width;
      var height = this.context.canvas.height, layerExtent = layerState.extent && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.fromUserExtent)(layerState.extent, projection);
      layerExtent && (frameExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getIntersection)(frameExtent, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.fromUserExtent)(layerState.extent, projection)));
      var dx = tileResolution * target / 2 / sourceKey, dy = tileResolution * height / 2 / sourceKey;
      viewCenter = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
      const tilesByZ = {};
      this.renderedTiles.length = 0;
      const preload = tileLayer.getPreload();
      frameState.nextExtent && (viewState = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection), tileLayer = getRenderExtent(frameState, frameState.nextExtent), this.enqueueTiles(frameState, tileLayer, viewState, tilesByZ, preload));
      const renderExtent = getRenderExtent(frameState, frameExtent);
      this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);
      0 < preload && setTimeout(() => {
        this.enqueueTiles(frameState, renderExtent, z - 1, tilesByZ, preload - 1);
      }, 0);
      if (!(z in tilesByZ)) {
        return this.container;
      }
      frameExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(this);
      viewState = frameState.time;
      for (var tile$jscomp$0 of tilesByZ[z]) {
        if (dx = tile$jscomp$0.getState(), dx !== default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.EMPTY) {
          if (tileLayer = tile$jscomp$0.tileCoord, dx === default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.LOADED && 1 === tile$jscomp$0.getAlpha(frameExtent, viewState)) {
            tile$jscomp$0.endTransition(frameExtent);
          } else {
            if (dx !== default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.IDLE && (allTilesIdle = !1), dx !== default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.ERROR && (this.renderComplete = !1), this.findStaleTile_(tileLayer, tilesByZ)) {
              removeTileFromLookup(tilesByZ, tile$jscomp$0, z), frameState.animate = !0;
            } else {
              if (!this.findAltTiles_(tileGrid, tileLayer, z + 1, tilesByZ)) {
                for (dx = tileGrid.getMinZoom(), dy = z - 1; dy >= dx && !this.findAltTiles_(tileGrid, tileLayer, dy, tilesByZ); --dy) {
                }
              }
            }
          }
        }
      }
      viewResolution = tileResolution / viewResolution * pixelRatio / sourceKey;
      tile$jscomp$0 = this.getRenderContext(frameState);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.compose)(this.tempTransform, target / 2, height / 2, viewResolution, viewResolution, 0, -target / 2, -height / 2);
      layerState.extent && this.clipUnrotated(tile$jscomp$0, frameState, layerExtent);
      tileSource.getInterpolate() || (tile$jscomp$0.imageSmoothingEnabled = !1);
      this.preRender(tile$jscomp$0, frameState);
      target = Object.keys(tilesByZ).map(Number);
      target.sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.ascending);
      height = [];
      layerExtent = [];
      for (frameExtent = target.length - 1; 0 <= frameExtent; --frameExtent) {
        viewState = target[frameExtent];
        dx = tileSource.getTilePixelSize(viewState, pixelRatio, projection);
        dy = tileGrid.getResolution(viewState) / tileResolution;
        tileLayer = dx[0] * dy * viewResolution;
        dx = dx[1] * dy * viewResolution;
        dy = tileGrid.getTileCoordForCoordAndZ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getTopLeft)(viewCenter), viewState);
        var originTileExtent = tileGrid.getTileCoordExtent(dy);
        originTileExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(this.tempTransform, [sourceKey * (originTileExtent[0] - viewCenter[0]) / tileResolution, sourceKey * (viewCenter[3] - originTileExtent[3]) / tileResolution]);
        const tileGutter = sourceKey * tileSource.getGutterForProjection(projection);
        for (const tile of tilesByZ[viewState]) {
          if (tile.getState() !== default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_TileState_DOT_js.default.LOADED) {
            continue;
          }
          var tileCoord = tile.tileCoord, xIndex = dy[1] - tileCoord[1];
          var currentClip = dy[2] - tileCoord[2];
          tileCoord = Math.round(originTileExtent[0] - xIndex * tileLayer);
          const y = Math.round(originTileExtent[1] - currentClip * dx);
          xIndex = Math.round(originTileExtent[0] - (xIndex - 1) * tileLayer) - tileCoord;
          const h = Math.round(originTileExtent[1] - (currentClip - 1) * dx) - y, transition = 1 === target.length;
          let contextSaved = !1;
          currentClip = [tileCoord, y, tileCoord + xIndex, y, tileCoord + xIndex, y + h, tileCoord, y + h];
          for (let i = 0, ii = height.length; i < ii; ++i) {
            if (!transition && viewState < layerExtent[i]) {
              const clip = height[i];
              (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)([tileCoord, y, tileCoord + xIndex, y + h], [clip[0], clip[3], clip[4], clip[7]]) && (contextSaved || (tile$jscomp$0.save(), contextSaved = !0), tile$jscomp$0.beginPath(), tile$jscomp$0.moveTo(currentClip[0], currentClip[1]), tile$jscomp$0.lineTo(currentClip[2], currentClip[3]), tile$jscomp$0.lineTo(currentClip[4], currentClip[5]), tile$jscomp$0.lineTo(currentClip[6], currentClip[7]), tile$jscomp$0.moveTo(clip[6], 
              clip[7]), tile$jscomp$0.lineTo(clip[4], clip[5]), tile$jscomp$0.lineTo(clip[2], clip[3]), tile$jscomp$0.lineTo(clip[0], clip[1]), tile$jscomp$0.clip());
            }
          }
          height.push(currentClip);
          layerExtent.push(viewState);
          this.drawTile(tile, frameState, tileCoord, y, xIndex, h, tileGutter, transition);
          contextSaved && tile$jscomp$0.restore();
          this.renderedTiles.unshift(tile);
          this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
        }
      }
      this.renderedResolution = tileResolution;
      this.extentChanged = !this.renderedExtent_ || !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.equals)(this.renderedExtent_, viewCenter);
      this.renderedExtent_ = viewCenter;
      this.renderedPixelRatio = pixelRatio;
      this.postRender(this.context, frameState);
      layerState.extent && tile$jscomp$0.restore();
      tile$jscomp$0.imageSmoothingEnabled = !0;
      this.renderComplete && frameState.postRenderFunctions.push((map, frameState) => {
        map = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(tileSource);
        frameState = (frameState = frameState.wantedTiles[map]) ? Object.keys(frameState).length : 0;
        this.updateCacheSize(frameState);
        this.tileCache_.expireCache();
      });
      this.renderComplete || allTilesIdle || (frameState.animate = !0);
      return this.container;
    }
    updateCacheSize(tileCount) {
      this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, 2 * tileCount);
    }
    drawTile(tile, frameState, x, y, w, h, gutter, transition) {
      let image;
      if (tile instanceof default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js.default) {
        if (image = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_DataTile_DOT_js.asImageLike)(tile.getData()), !image) {
          throw Error("Rendering array data is not yet supported");
        }
      } else {
        image = this.getTileImage(tile);
      }
      if (image) {
        var context = this.getRenderContext(frameState), uid = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(this), layerState = frameState.layerStatesArray[frameState.layerIndex], alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1), alphaChanged = alpha !== context.globalAlpha;
        alphaChanged && (context.save(), context.globalAlpha = alpha);
        context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
        alphaChanged && context.restore();
        alpha !== layerState.opacity ? frameState.animate = !0 : transition && tile.endTransition(uid);
      }
    }
    getImage() {
      const context = this.context;
      return context ? context.canvas : null;
    }
    getTileImage(tile) {
      return tile.getImage();
    }
    updateUsedTiles(usedTiles, tileSource, tile) {
      tileSource = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(tileSource);
      tileSource in usedTiles || (usedTiles[tileSource] = {});
      usedTiles[tileSource][tile.getKey()] = !0;
    }
  }
  const $$default = CanvasTileLayerRenderer;
};

//# sourceMappingURL=module$node_modules$ol$renderer$canvas$TileLayer.js.map
