shadow$provide.module$node_modules$ol$Overlay = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$MapEventType");
  module = require("module$node_modules$ol$Object");
  var require$_DOT__SLASH_css_DOT_js = require("module$node_modules$ol$css"), require$_DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__SLASH_events_DOT_js = require("module$node_modules$ol$events"), require$_DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent");
  module = require.esmDefault(module);
  var default$$require$_DOT__SLASH_MapEventType_DOT_js = require.esmDefault(global);
  class Overlay extends module.default {
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      this.options = options;
      this.id = options.id;
      this.insertFirst = void 0 !== options.insertFirst ? options.insertFirst : !0;
      this.stopEvent = void 0 !== options.stopEvent ? options.stopEvent : !0;
      this.element = document.createElement("div");
      this.element.className = void 0 !== options.className ? options.className : "ol-overlay-container " + require$_DOT__SLASH_css_DOT_js.CLASS_SELECTABLE;
      this.element.style.position = "absolute";
      this.element.style.pointerEvents = "auto";
      this.autoPan = !0 === options.autoPan ? {} : options.autoPan || void 0;
      this.rendered = {transform_:"", visible:!0};
      this.mapPostrenderListenerKey = null;
      this.addChangeListener("element", this.handleElementChanged);
      this.addChangeListener("map", this.handleMapChanged);
      this.addChangeListener("offset", this.handleOffsetChanged);
      this.addChangeListener("position", this.handlePositionChanged);
      this.addChangeListener("positioning", this.handlePositioningChanged);
      void 0 !== options.element && this.setElement(options.element);
      this.setOffset(void 0 !== options.offset ? options.offset : [0, 0]);
      this.setPositioning(options.positioning || "top-left");
      void 0 !== options.position && this.setPosition(options.position);
    }
    getElement() {
      return this.get("element");
    }
    getId() {
      return this.id;
    }
    getMap() {
      return this.get("map") || null;
    }
    getOffset() {
      return this.get("offset");
    }
    getPosition() {
      return this.get("position");
    }
    getPositioning() {
      return this.get("positioning");
    }
    handleElementChanged() {
      (0,require$_DOT__SLASH_dom_DOT_js.removeChildren)(this.element);
      const element = this.getElement();
      element && this.element.appendChild(element);
    }
    handleMapChanged() {
      this.mapPostrenderListenerKey && (this.element?.remove(), (0,require$_DOT__SLASH_events_DOT_js.unlistenByKey)(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
      var map = this.getMap();
      map && (this.mapPostrenderListenerKey = (0,require$_DOT__SLASH_events_DOT_js.listen)(map, default$$require$_DOT__SLASH_MapEventType_DOT_js.default.POSTRENDER, this.render, this), this.updatePixelPosition(), map = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer(), this.insertFirst ? map.insertBefore(this.element, map.childNodes[0] || null) : map.appendChild(this.element), this.performAutoPan());
    }
    render() {
      this.updatePixelPosition();
    }
    handleOffsetChanged() {
      this.updatePixelPosition();
    }
    handlePositionChanged() {
      this.updatePixelPosition();
      this.performAutoPan();
    }
    handlePositioningChanged() {
      this.updatePixelPosition();
    }
    setElement(element) {
      this.set("element", element);
    }
    setMap(map) {
      this.set("map", map);
    }
    setOffset(offset) {
      this.set("offset", offset);
    }
    setPosition(position) {
      this.set("position", position);
    }
    performAutoPan() {
      this.autoPan && this.panIntoView(this.autoPan);
    }
    panIntoView(panIntoViewOptions) {
      const map = this.getMap();
      if (map && map.getTargetElement() && this.get("position")) {
        var mapRect = this.getRect(map.getTargetElement(), map.getSize()), element = this.getElement(), overlayRect = this.getRect(element, [(0,require$_DOT__SLASH_dom_DOT_js.outerWidth)(element), (0,require$_DOT__SLASH_dom_DOT_js.outerHeight)(element)]);
        panIntoViewOptions = panIntoViewOptions || {};
        element = void 0 === panIntoViewOptions.margin ? 20 : panIntoViewOptions.margin;
        if (!(0,require$_DOT__SLASH_extent_DOT_js.containsExtent)(mapRect, overlayRect)) {
          const offsetLeft = overlayRect[0] - mapRect[0], offsetRight = mapRect[2] - overlayRect[2], offsetTop = overlayRect[1] - mapRect[1];
          overlayRect = mapRect[3] - overlayRect[3];
          mapRect = [0, 0];
          0 > offsetLeft ? mapRect[0] = offsetLeft - element : 0 > offsetRight && (mapRect[0] = Math.abs(offsetRight) + element);
          0 > offsetTop ? mapRect[1] = offsetTop - element : 0 > overlayRect && (mapRect[1] = Math.abs(overlayRect) + element);
          if (0 !== mapRect[0] || 0 !== mapRect[1]) {
            if (element = map.getView().getCenterInternal(), element = map.getPixelFromCoordinateInternal(element)) {
              element = [element[0] + mapRect[0], element[1] + mapRect[1]], panIntoViewOptions = panIntoViewOptions.animation || {}, map.getView().animateInternal({center:map.getCoordinateFromPixelInternal(element), duration:panIntoViewOptions.duration, easing:panIntoViewOptions.easing});
            }
          }
        }
      }
    }
    getRect(element, size) {
      var box = element.getBoundingClientRect();
      element = box.left + window.pageXOffset;
      box = box.top + window.pageYOffset;
      return [element, box, element + size[0], box + size[1]];
    }
    setPositioning(positioning) {
      this.set("positioning", positioning);
    }
    setVisible(visible) {
      this.rendered.visible !== visible && (this.element.style.display = visible ? "" : "none", this.rendered.visible = visible);
    }
    updatePixelPosition() {
      var map = this.getMap(), position = this.getPosition();
      map && map.isRendered() && position ? (position = map.getPixelFromCoordinate(position), map = map.getSize(), this.updateRenderedPosition(position, map)) : this.setVisible(!1);
    }
    updateRenderedPosition(pixel, mapSize) {
      mapSize = this.element.style;
      var offset = this.getOffset(), positioning = this.getPositioning();
      this.setVisible(!0);
      const x = Math.round(pixel[0] + offset[0]) + "px";
      pixel = Math.round(pixel[1] + offset[1]) + "px";
      let posY = offset = "0%";
      if ("bottom-right" == positioning || "center-right" == positioning || "top-right" == positioning) {
        offset = "-100%";
      } else if ("bottom-center" == positioning || "center-center" == positioning || "top-center" == positioning) {
        offset = "-50%";
      }
      if ("bottom-left" == positioning || "bottom-center" == positioning || "bottom-right" == positioning) {
        posY = "-100%";
      } else if ("center-left" == positioning || "center-center" == positioning || "center-right" == positioning) {
        posY = "-50%";
      }
      positioning = `translate(${offset}, ${posY}) translate(${x}, ${pixel})`;
      this.rendered.transform_ != positioning && (this.rendered.transform_ = positioning, mapSize.transform = positioning);
    }
    getOptions() {
      return this.options;
    }
  }
  const $$default = Overlay;
};

//# sourceMappingURL=module$node_modules$ol$Overlay.js.map
