shadow$provide.module$node_modules$ol$expr$expression = function(global, require, module, exports) {
  function typeName(type) {
    const names = [];
    for (const namedType of namedTypes) {
      includesType(type, namedType) && names.push(typeNames[namedType]);
    }
    return 0 === names.length ? "untyped" : 3 > names.length ? names.join(" or ") : names.slice(0, -1).join(", ") + ", or " + names[names.length - 1];
  }
  function includesType(broad, specific) {
    return (broad & specific) === specific;
  }
  function overlapsType(oneType, otherType) {
    return !!(oneType & otherType);
  }
  function isType(type, expected) {
    return type === expected;
  }
  function newParsingContext() {
    return {variables:new Set(), properties:new Set(), featureId:!1, geometryType:!1, mapState:!1};
  }
  function parse(encoded, expectedType, context) {
    switch(typeof encoded) {
      case "boolean":
        if (expectedType === StringType) {
          return new LiteralExpression(StringType, encoded ? "true" : "false");
        }
        if (!includesType(expectedType, BooleanType)) {
          throw Error(`got a boolean, but expected ${typeName(expectedType)}`);
        }
        return new LiteralExpression(BooleanType, encoded);
      case "number":
        if (expectedType === SizeType) {
          return new LiteralExpression(SizeType, (0,require$_DOT__DOT__SLASH_size_DOT_js.toSize)(encoded));
        }
        if (expectedType === BooleanType) {
          return new LiteralExpression(BooleanType, !!encoded);
        }
        if (expectedType === StringType) {
          return new LiteralExpression(StringType, encoded.toString());
        }
        if (!includesType(expectedType, NumberType)) {
          throw Error(`got a number, but expected ${typeName(expectedType)}`);
        }
        return new LiteralExpression(NumberType, encoded);
      case "string":
        if (expectedType === ColorType) {
          return new LiteralExpression(ColorType, (0,require$_DOT__DOT__SLASH_color_DOT_js.fromString)(encoded));
        }
        if (expectedType === BooleanType) {
          return new LiteralExpression(BooleanType, !!encoded);
        }
        if (!includesType(expectedType, StringType)) {
          throw Error(`got a string, but expected ${typeName(expectedType)}`);
        }
        return new LiteralExpression(StringType, encoded);
    }
    if (!Array.isArray(encoded)) {
      throw Error("expression must be an array or a primitive value");
    }
    if (0 === encoded.length) {
      throw Error("empty expression");
    }
    if ("string" === typeof encoded[0]) {
      var operator = encoded[0];
      const parser = parsers[operator];
      if (!parser) {
        throw Error(`unknown operator: ${operator}`);
      }
      return parser(encoded, expectedType, context);
    }
    for (operator of encoded) {
      if ("number" !== typeof operator) {
        throw Error("expected an array of numbers");
      }
    }
    if (expectedType === SizeType) {
      if (2 !== encoded.length) {
        throw Error(`expected an array of two values for a size, got ${encoded.length}`);
      }
      return new LiteralExpression(SizeType, encoded);
    }
    if (expectedType === ColorType) {
      if (3 === encoded.length) {
        return new LiteralExpression(ColorType, [...encoded, 1]);
      }
      if (4 === encoded.length) {
        return new LiteralExpression(ColorType, encoded);
      }
      throw Error(`expected an array of 3 or 4 values for a color, got ${encoded.length}`);
    }
    if (!includesType(expectedType, NumberArrayType)) {
      throw Error(`got an array of numbers, but expected ${typeName(expectedType)}`);
    }
    return new LiteralExpression(NumberArrayType, encoded);
  }
  function withGetArgs(encoded, returnType, context) {
    returnType = encoded.length - 1;
    const args = Array(returnType);
    for (let i = 0; i < returnType; ++i) {
      const key = encoded[i + 1];
      switch(typeof key) {
        case "number":
          args[i] = new LiteralExpression(NumberType, key);
          break;
        case "string":
          args[i] = new LiteralExpression(StringType, key);
          break;
        default:
          throw Error(`expected a string key or numeric array index for a get operation, got ${key}`);
      }
      0 === i && context.properties.add(String(key));
    }
    return args;
  }
  function usesMapState(encoded, returnType, context) {
    context.mapState = !0;
  }
  function withNoArgs(encoded, returnType, context) {
    returnType = encoded[0];
    if (1 !== encoded.length) {
      throw Error(`expected no arguments for ${returnType} operation`);
    }
    return [];
  }
  function hasArgsCount(minArgs, maxArgs) {
    return function(encoded, returnType, context) {
      returnType = encoded[0];
      encoded = encoded.length - 1;
      if (minArgs === maxArgs) {
        if (encoded !== minArgs) {
          throw Error(`expected ${minArgs} argument${1 === minArgs ? "" : "s"} for ${returnType}, got ${encoded}`);
        }
      } else if (encoded < minArgs || encoded > maxArgs) {
        throw Error(`expected ${Infinity === maxArgs ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`} arguments for ${returnType}, got ${encoded}`);
      }
    };
  }
  function withArgsOfReturnType(encoded, returnType, context) {
    const argCount = encoded.length - 1, args = Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse(encoded[i + 1], returnType, context);
      args[i] = expression;
    }
    return args;
  }
  function withArgsOfType(argType) {
    return function(encoded, returnType, context) {
      returnType = encoded.length - 1;
      const args = Array(returnType);
      for (let i = 0; i < returnType; ++i) {
        const expression = parse(encoded[i + 1], argType, context);
        args[i] = expression;
      }
      return args;
    };
  }
  function hasEvenArgs(encoded, returnType, context) {
    returnType = encoded[0];
    encoded = encoded.length - 1;
    if (1 === encoded % 2) {
      throw Error(`expected an even number of arguments for operation ${returnType}, got ${encoded} instead`);
    }
  }
  function createCallExpressionParser(...validators) {
    return function(encoded, returnType, context) {
      const operator = encoded[0];
      let args;
      for (let i = 0; i < validators.length; i++) {
        const parsed = validators[i](encoded, returnType, context);
        if (i == validators.length - 1) {
          if (!parsed) {
            throw Error("expected last argument validator to return the parsed args");
          }
          args = parsed;
        }
      }
      return new CallExpression(returnType, operator, ...args);
    };
  }
  function computeGeometryType(geometry) {
    if (!geometry) {
      return "";
    }
    const type = geometry.getType();
    switch(type) {
      case "Point":
      case "LineString":
      case "Polygon":
        return type;
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
        return type.substring(5);
      case "Circle":
        return "Polygon";
      case "GeometryCollection":
        return computeGeometryType(geometry.getGeometries()[0]);
      default:
        return "";
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, AnyType:{enumerable:!0, get:function() {
    return AnyType;
  }}, BooleanType:{enumerable:!0, get:function() {
    return BooleanType;
  }}, CallExpression:{enumerable:!0, get:function() {
    return CallExpression;
  }}, ColorType:{enumerable:!0, get:function() {
    return ColorType;
  }}, LiteralExpression:{enumerable:!0, get:function() {
    return LiteralExpression;
  }}, NoneType:{enumerable:!0, get:function() {
    return 0;
  }}, NumberArrayType:{enumerable:!0, get:function() {
    return NumberArrayType;
  }}, NumberType:{enumerable:!0, get:function() {
    return NumberType;
  }}, Ops:{enumerable:!0, get:function() {
    return Ops;
  }}, SizeType:{enumerable:!0, get:function() {
    return SizeType;
  }}, StringType:{enumerable:!0, get:function() {
    return StringType;
  }}, computeGeometryType:{enumerable:!0, get:function() {
    return computeGeometryType;
  }}, includesType:{enumerable:!0, get:function() {
    return includesType;
  }}, isType:{enumerable:!0, get:function() {
    return isType;
  }}, newParsingContext:{enumerable:!0, get:function() {
    return newParsingContext;
  }}, overlapsType:{enumerable:!0, get:function() {
    return overlapsType;
  }}, parse:{enumerable:!0, get:function() {
    return parse;
  }}, typeName:{enumerable:!0, get:function() {
    return typeName;
  }}});
  global = require("module$node_modules$ol$array");
  var require$_DOT__DOT__SLASH_color_DOT_js = require("module$node_modules$ol$color"), require$_DOT__DOT__SLASH_size_DOT_js = require("module$node_modules$ol$size");
  require = 0;
  const BooleanType = 1 << require++, NumberType = 1 << require++, StringType = 1 << require++, ColorType = 1 << require++, NumberArrayType = 1 << require++, SizeType = 1 << require++, AnyType = Math.pow(2, require) - 1, typeNames = {[BooleanType]:"boolean", [NumberType]:"number", [StringType]:"string", [ColorType]:"color", [NumberArrayType]:"number[]", [SizeType]:"size"}, namedTypes = Object.keys(typeNames).map(Number).sort(global.ascending);
  class LiteralExpression {
    constructor(type, value) {
      if (!(type in typeNames)) {
        throw Error(`literal expressions must have a specific type, got ${typeName(type)}`);
      }
      this.type = type;
      this.value = value;
    }
  }
  class CallExpression {
    constructor(type, operator, ...args) {
      this.type = type;
      this.operator = operator;
      this.args = args;
    }
  }
  const Ops = {Get:"get", Var:"var", Concat:"concat", GeometryType:"geometry-type", LineMetric:"line-metric", Any:"any", All:"all", Not:"!", Resolution:"resolution", Zoom:"zoom", Time:"time", Equal:"\x3d\x3d", NotEqual:"!\x3d", GreaterThan:"\x3e", GreaterThanOrEqualTo:"\x3e\x3d", LessThan:"\x3c", LessThanOrEqualTo:"\x3c\x3d", Multiply:"*", Divide:"/", Add:"+", Subtract:"-", Clamp:"clamp", Mod:"%", Pow:"^", Abs:"abs", Floor:"floor", Ceil:"ceil", Round:"round", Sin:"sin", Cos:"cos", Atan:"atan", Sqrt:"sqrt", 
  Match:"match", Between:"between", Interpolate:"interpolate", Coalesce:"coalesce", Case:"case", In:"in", Number:"number", String:"string", Array:"array", Color:"color", Id:"id", Band:"band", Palette:"palette", ToString:"to-string", Has:"has"}, parsers = {[Ops.Get]:createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs), [Ops.Var]:createCallExpressionParser(hasArgsCount(1, 1), function(encoded, returnType, context) {
    encoded = encoded[1];
    if ("string" !== typeof encoded) {
      throw Error("expected a string argument for var operation");
    }
    context.variables.add(encoded);
    return [new LiteralExpression(StringType, encoded)];
  }), [Ops.Has]:createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs), [Ops.Id]:createCallExpressionParser(function(encoded, returnType, context) {
    context.featureId = !0;
  }, withNoArgs), [Ops.Concat]:createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(StringType)), [Ops.GeometryType]:createCallExpressionParser(function(encoded, returnType, context) {
    context.geometryType = !0;
  }, withNoArgs), [Ops.LineMetric]:createCallExpressionParser(withNoArgs), [Ops.Resolution]:createCallExpressionParser(usesMapState, withNoArgs), [Ops.Zoom]:createCallExpressionParser(usesMapState, withNoArgs), [Ops.Time]:createCallExpressionParser(usesMapState, withNoArgs), [Ops.Any]:createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)), [Ops.All]:createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)), [Ops.Not]:createCallExpressionParser(hasArgsCount(1, 
  1), withArgsOfType(BooleanType)), [Ops.Equal]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)), [Ops.NotEqual]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)), [Ops.GreaterThan]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.GreaterThanOrEqualTo]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.LessThan]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.LessThanOrEqualTo]:createCallExpressionParser(hasArgsCount(2, 
  2), withArgsOfType(NumberType)), [Ops.Multiply]:createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType), [Ops.Coalesce]:createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType), [Ops.Divide]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.Add]:createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(NumberType)), [Ops.Subtract]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.Clamp]:createCallExpressionParser(hasArgsCount(3, 
  3), withArgsOfType(NumberType)), [Ops.Mod]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.Pow]:createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)), [Ops.Abs]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)), [Ops.Floor]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)), [Ops.Ceil]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)), [Ops.Round]:createCallExpressionParser(hasArgsCount(1, 
  1), withArgsOfType(NumberType)), [Ops.Sin]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)), [Ops.Cos]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)), [Ops.Atan]:createCallExpressionParser(hasArgsCount(1, 2), withArgsOfType(NumberType)), [Ops.Sqrt]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)), [Ops.Match]:createCallExpressionParser(hasArgsCount(4, Infinity), hasEvenArgs, function(encoded, returnType, context) {
    const argsCount = encoded.length - 1, input = parse(encoded[1], StringType | NumberType | BooleanType, context);
    returnType = parse(encoded[encoded.length - 1], returnType, context);
    const args = Array(argsCount - 2);
    for (let i = 0; i < argsCount - 2; i += 2) {
      try {
        const match = parse(encoded[i + 2], input.type, context);
        args[i] = match;
      } catch (err) {
        throw Error(`failed to parse argument ${i + 1} of match expression: ${err.message}`);
      }
      try {
        const output = parse(encoded[i + 3], returnType.type, context);
        args[i + 1] = output;
      } catch (err) {
        throw Error(`failed to parse argument ${i + 2} of match expression: ${err.message}`);
      }
    }
    return [input, ...args, returnType];
  }), [Ops.Between]:createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)), [Ops.Interpolate]:createCallExpressionParser(hasArgsCount(6, Infinity), hasEvenArgs, function(encoded, returnType, context) {
    var interpolationType = encoded[1];
    switch(interpolationType[0]) {
      case "linear":
        interpolationType = 1;
        break;
      case "exponential":
        interpolationType = interpolationType[1];
        if ("number" !== typeof interpolationType || 0 >= interpolationType) {
          throw Error("expected a number base for exponential interpolation" + `, got ${JSON.stringify(interpolationType)} instead`);
        }
        break;
      default:
        throw Error(`invalid interpolation type: ${JSON.stringify(interpolationType)}`);
    }
    interpolationType = new LiteralExpression(NumberType, interpolationType);
    let input;
    try {
      input = parse(encoded[2], NumberType, context);
    } catch (err) {
      throw Error(`failed to parse argument 1 in interpolate expression: ${err.message}`);
    }
    const args = Array(encoded.length - 3);
    for (let i = 0; i < args.length; i += 2) {
      try {
        const stop = parse(encoded[i + 3], NumberType, context);
        args[i] = stop;
      } catch (err) {
        throw Error(`failed to parse argument ${i + 2} for interpolate expression: ${err.message}`);
      }
      try {
        const output = parse(encoded[i + 4], returnType, context);
        args[i + 1] = output;
      } catch (err) {
        throw Error(`failed to parse argument ${i + 3} for interpolate expression: ${err.message}`);
      }
    }
    return [interpolationType, input, ...args];
  }), [Ops.Case]:createCallExpressionParser(hasArgsCount(3, Infinity), function(encoded, returnType, context) {
    returnType = encoded[0];
    encoded = encoded.length - 1;
    if (0 === encoded % 2) {
      throw Error(`expected an odd number of arguments for ${returnType}, got ${encoded} instead`);
    }
  }, function(encoded, returnType, context) {
    returnType = parse(encoded[encoded.length - 1], returnType, context);
    const args = Array(encoded.length - 1);
    for (let i = 0; i < args.length - 1; i += 2) {
      try {
        const condition = parse(encoded[i + 1], BooleanType, context);
        args[i] = condition;
      } catch (err) {
        throw Error(`failed to parse argument ${i} of case expression: ${err.message}`);
      }
      try {
        const output = parse(encoded[i + 2], returnType.type, context);
        args[i + 1] = output;
      } catch (err) {
        throw Error(`failed to parse argument ${i + 1} of case expression: ${err.message}`);
      }
    }
    args[args.length - 1] = returnType;
    return args;
  }), [Ops.In]:createCallExpressionParser(hasArgsCount(2, 2), function(encoded, returnType, context) {
    returnType = encoded[2];
    if (!Array.isArray(returnType)) {
      throw Error('the second argument for the "in" operator must be an array');
    }
    let needleType;
    if ("string" === typeof returnType[0]) {
      if ("literal" !== returnType[0]) {
        throw Error('for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions');
      }
      if (!Array.isArray(returnType[1])) {
        throw Error('failed to parse "in" expression: the literal operator must be followed by an array');
      }
      returnType = returnType[1];
      needleType = StringType;
    } else {
      needleType = NumberType;
    }
    const args = Array(returnType.length);
    for (let i = 0; i < args.length; i++) {
      try {
        const arg = parse(returnType[i], needleType, context);
        args[i] = arg;
      } catch (err) {
        throw Error(`failed to parse haystack item ${i} for "in" expression: ${err.message}`);
      }
    }
    return [parse(encoded[1], needleType, context), ...args];
  }), [Ops.Number]:createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)), [Ops.String]:createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)), [Ops.Array]:createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(NumberType)), [Ops.Color]:createCallExpressionParser(hasArgsCount(1, 4), withArgsOfType(NumberType)), [Ops.Band]:createCallExpressionParser(hasArgsCount(1, 3), withArgsOfType(NumberType)), [Ops.Palette]:createCallExpressionParser(hasArgsCount(2, 
  2), function(encoded, returnType, context) {
    let index;
    try {
      index = parse(encoded[1], NumberType, context);
    } catch (err) {
      throw Error(`failed to parse first argument in palette expression: ${err.message}`);
    }
    encoded = encoded[2];
    if (!Array.isArray(encoded)) {
      throw Error("the second argument of palette must be an array");
    }
    returnType = Array(encoded.length);
    for (let i = 0; i < returnType.length; i++) {
      let color;
      try {
        color = parse(encoded[i], ColorType, context);
      } catch (err) {
        throw Error(`failed to parse color at index ${i} in palette expression: ${err.message}`);
      }
      if (!(color instanceof LiteralExpression)) {
        throw Error(`the palette color at index ${i} must be a literal value`);
      }
      returnType[i] = color;
    }
    return [index, ...returnType];
  }), [Ops.ToString]:createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType | NumberType | StringType | ColorType))};
};

//# sourceMappingURL=module$node_modules$ol$expr$expression.js.map
