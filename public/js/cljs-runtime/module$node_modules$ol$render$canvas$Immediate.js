shadow$provide.module$node_modules$ol$render$canvas$Immediate = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js = require("module$node_modules$ol$colorlike"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_SimpleGeometry_DOT_js = require("module$node_modules$ol$geom$SimpleGeometry"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js = 
  require("module$node_modules$ol$geom$flat$transform"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform");
  global = require("module$node_modules$ol$render$VectorContext");
  var require$_DOT__DOT__SLASH_canvas_DOT_js = require("module$node_modules$ol$render$canvas");
  require = require.esmDefault(global);
  class CanvasImmediateRenderer extends require.default {
    constructor(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform) {
      super();
      this.context_ = context;
      this.pixelRatio_ = pixelRatio;
      this.extent_ = extent;
      this.transformRotation_ = (this.transform_ = transform) ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toFixed)(Math.atan2(transform[1], transform[0]), 10) : 0;
      this.viewRotation_ = viewRotation;
      this.squaredTolerance_ = squaredTolerance;
      this.userTransform_ = userTransform;
      this.image_ = this.strokeState_ = this.fillState_ = this.contextTextState_ = this.contextStrokeState_ = this.contextFillState_ = null;
      this.imageOriginY_ = this.imageOriginX_ = this.imageOpacity_ = this.imageHeight_ = this.imageAnchorY_ = this.imageAnchorX_ = 0;
      this.imageRotateWithView_ = !1;
      this.imageRotation_ = 0;
      this.imageScale_ = [0, 0];
      this.imageWidth_ = 0;
      this.text_ = "";
      this.textOffsetY_ = this.textOffsetX_ = 0;
      this.textRotateWithView_ = !1;
      this.textRotation_ = 0;
      this.textScale_ = [0, 0];
      this.textState_ = this.textStrokeState_ = this.textFillState_ = null;
      this.pixelCoordinates_ = [];
      this.tmpLocalTransform_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)();
    }
    drawImages_(flatCoordinates, offset, end, stride) {
      if (this.image_) {
        flatCoordinates = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        offset = this.context_;
        end = this.tmpLocalTransform_;
        stride = offset.globalAlpha;
        1 != this.imageOpacity_ && (offset.globalAlpha = stride * this.imageOpacity_);
        var rotation = this.imageRotation_;
        0 === this.transformRotation_ && (rotation -= this.viewRotation_);
        this.imageRotateWithView_ && (rotation += this.viewRotation_);
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += 2) {
          var x = flatCoordinates[i] - this.imageAnchorX_, y = flatCoordinates[i + 1] - this.imageAnchorY_;
          0 !== rotation || 1 != this.imageScale_[0] || 1 != this.imageScale_[1] ? (x += this.imageAnchorX_, y += this.imageAnchorY_, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.compose)(end, x, y, 1, 1, rotation, -x, -y), offset.save(), offset.transform.apply(offset, end), offset.translate(x, y), offset.scale(this.imageScale_[0], this.imageScale_[1]), offset.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, 
          -this.imageAnchorY_, this.imageWidth_, this.imageHeight_), offset.restore()) : offset.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
        1 != this.imageOpacity_ && (offset.globalAlpha = stride);
      }
    }
    drawText_(flatCoordinates, offset, end, stride) {
      if (this.textState_ && "" !== this.text_) {
        this.textFillState_ && this.setContextFillState_(this.textFillState_);
        this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_);
        this.setContextTextState_(this.textState_);
        flatCoordinates = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        var context = this.context_, rotation = this.textRotation_;
        0 === this.transformRotation_ && (rotation -= this.viewRotation_);
        for (this.textRotateWithView_ && (rotation += this.viewRotation_); offset < end; offset += stride) {
          const x = flatCoordinates[offset] + this.textOffsetX_, y = flatCoordinates[offset + 1] + this.textOffsetY_;
          0 !== rotation || 1 != this.textScale_[0] || 1 != this.textScale_[1] ? (context.save(), context.translate(x - this.textOffsetX_, y - this.textOffsetY_), context.rotate(rotation), context.translate(this.textOffsetX_, this.textOffsetY_), context.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && context.strokeText(this.text_, 0, 0), this.textFillState_ && context.fillText(this.text_, 0, 0), context.restore()) : (this.textStrokeState_ && context.strokeText(this.text_, 
          x, y), this.textFillState_ && context.fillText(this.text_, x, y));
        }
      }
    }
    moveToLineTo_(flatCoordinates, offset, end, stride, close) {
      const context = this.context_;
      flatCoordinates = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
      context.moveTo(flatCoordinates[0], flatCoordinates[1]);
      offset = flatCoordinates.length;
      close && (offset -= 2);
      for (stride = 2; stride < offset; stride += 2) {
        context.lineTo(flatCoordinates[stride], flatCoordinates[stride + 1]);
      }
      close && context.closePath();
      return end;
    }
    drawRings_(flatCoordinates, offset, ends, stride) {
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, !0);
      }
      return offset;
    }
    drawCircle(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(this.extent_, geometry.getExtent())) {
        if (this.fillState_ || this.strokeState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_);
          this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const pixelCoordinates = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_SimpleGeometry_DOT_js.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
          var dx = pixelCoordinates[2] - pixelCoordinates[0], dy = pixelCoordinates[3] - pixelCoordinates[1];
          dx = Math.sqrt(dx * dx + dy * dy);
          dy = this.context_;
          dy.beginPath();
          dy.arc(pixelCoordinates[0], pixelCoordinates[1], dx, 0, 2 * Math.PI);
          this.fillState_ && dy.fill();
          this.strokeState_ && dy.stroke();
        }
        "" !== this.text_ && this.drawText_(geometry.getCenter(), 0, 2, 2);
      }
    }
    setStyle(style) {
      this.setFillStrokeStyle(style.getFill(), style.getStroke());
      this.setImageStyle(style.getImage());
      this.setTextStyle(style.getText());
    }
    setTransform(transform) {
      this.transform_ = transform;
    }
    drawGeometry(geometry) {
      switch(geometry.getType()) {
        case "Point":
          this.drawPoint(geometry);
          break;
        case "LineString":
          this.drawLineString(geometry);
          break;
        case "Polygon":
          this.drawPolygon(geometry);
          break;
        case "MultiPoint":
          this.drawMultiPoint(geometry);
          break;
        case "MultiLineString":
          this.drawMultiLineString(geometry);
          break;
        case "MultiPolygon":
          this.drawMultiPolygon(geometry);
          break;
        case "GeometryCollection":
          this.drawGeometryCollection(geometry);
          break;
        case "Circle":
          this.drawCircle(geometry);
      }
    }
    drawFeature(feature, style) {
      if (feature = style.getGeometryFunction()(feature)) {
        this.setStyle(style), this.drawGeometry(feature);
      }
    }
    drawGeometryCollection(geometry) {
      geometry = geometry.getGeometriesArray();
      for (let i = 0, ii = geometry.length; i < ii; ++i) {
        this.drawGeometry(geometry[i]);
      }
    }
    drawPoint(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      const flatCoordinates = geometry.getFlatCoordinates();
      geometry = geometry.getStride();
      this.image_ && this.drawImages_(flatCoordinates, 0, flatCoordinates.length, geometry);
      "" !== this.text_ && this.drawText_(flatCoordinates, 0, flatCoordinates.length, geometry);
    }
    drawMultiPoint(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      const flatCoordinates = geometry.getFlatCoordinates();
      geometry = geometry.getStride();
      this.image_ && this.drawImages_(flatCoordinates, 0, flatCoordinates.length, geometry);
      "" !== this.text_ && this.drawText_(flatCoordinates, 0, flatCoordinates.length, geometry);
    }
    drawLineString(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(this.extent_, geometry.getExtent())) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_, flatCoordinates = geometry.getFlatCoordinates();
          context.beginPath();
          this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), !1);
          context.stroke();
        }
        "" !== this.text_ && (geometry = geometry.getFlatMidpoint(), this.drawText_(geometry, 0, 2, 2));
      }
    }
    drawMultiLineString(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      var geometryExtent = geometry.getExtent();
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(this.extent_, geometryExtent)) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          geometryExtent = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          let offset = 0;
          const ends = geometry.getEnds(), stride = geometry.getStride();
          geometryExtent.beginPath();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, !1);
          }
          geometryExtent.stroke();
        }
        "" !== this.text_ && (geometry = geometry.getFlatMidpoints(), this.drawText_(geometry, 0, geometry.length, 2));
      }
    }
    drawPolygon(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(this.extent_, geometry.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_);
          this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          context.beginPath();
          this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
          this.fillState_ && context.fill();
          this.strokeState_ && context.stroke();
        }
        "" !== this.text_ && (geometry = geometry.getFlatInteriorPoint(), this.drawText_(geometry, 0, 2, 2));
      }
    }
    drawMultiPolygon(geometry) {
      this.squaredTolerance_ && (geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
      if ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(this.extent_, geometry.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_);
          this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const context = this.context_, flatCoordinates = geometry.getOrientedFlatCoordinates();
          let offset = 0;
          const endss = geometry.getEndss(), stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = endss.length; i < ii; ++i) {
            offset = this.drawRings_(flatCoordinates, offset, endss[i], stride);
          }
          this.fillState_ && context.fill();
          this.strokeState_ && context.stroke();
        }
        "" !== this.text_ && (geometry = geometry.getFlatInteriorPoints(), this.drawText_(geometry, 0, geometry.length, 2));
      }
    }
    setContextFillState_(fillState) {
      const context = this.context_, contextFillState = this.contextFillState_;
      contextFillState ? contextFillState.fillStyle != fillState.fillStyle && (contextFillState.fillStyle = fillState.fillStyle, context.fillStyle = fillState.fillStyle) : (context.fillStyle = fillState.fillStyle, this.contextFillState_ = {fillStyle:fillState.fillStyle});
    }
    setContextStrokeState_(strokeState) {
      const context = this.context_, contextStrokeState = this.contextStrokeState_;
      contextStrokeState ? (contextStrokeState.lineCap != strokeState.lineCap && (contextStrokeState.lineCap = strokeState.lineCap, context.lineCap = strokeState.lineCap), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.equals)(contextStrokeState.lineDash, strokeState.lineDash) || context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash), contextStrokeState.lineDashOffset != strokeState.lineDashOffset && (contextStrokeState.lineDashOffset = strokeState.lineDashOffset, context.lineDashOffset = 
      strokeState.lineDashOffset), contextStrokeState.lineJoin != strokeState.lineJoin && (contextStrokeState.lineJoin = strokeState.lineJoin, context.lineJoin = strokeState.lineJoin), contextStrokeState.lineWidth != strokeState.lineWidth && (contextStrokeState.lineWidth = strokeState.lineWidth, context.lineWidth = strokeState.lineWidth), contextStrokeState.miterLimit != strokeState.miterLimit && (contextStrokeState.miterLimit = strokeState.miterLimit, context.miterLimit = strokeState.miterLimit), 
      contextStrokeState.strokeStyle != strokeState.strokeStyle && (contextStrokeState.strokeStyle = strokeState.strokeStyle, context.strokeStyle = strokeState.strokeStyle)) : (context.lineCap = strokeState.lineCap, context.setLineDash(strokeState.lineDash), context.lineDashOffset = strokeState.lineDashOffset, context.lineJoin = strokeState.lineJoin, context.lineWidth = strokeState.lineWidth, context.miterLimit = strokeState.miterLimit, context.strokeStyle = strokeState.strokeStyle, this.contextStrokeState_ = 
      {lineCap:strokeState.lineCap, lineDash:strokeState.lineDash, lineDashOffset:strokeState.lineDashOffset, lineJoin:strokeState.lineJoin, lineWidth:strokeState.lineWidth, miterLimit:strokeState.miterLimit, strokeStyle:strokeState.strokeStyle});
    }
    setContextTextState_(textState) {
      const context = this.context_, contextTextState = this.contextTextState_, textAlign = textState.textAlign ? textState.textAlign : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextAlign;
      contextTextState ? (contextTextState.font != textState.font && (contextTextState.font = textState.font, context.font = textState.font), contextTextState.textAlign != textAlign && (contextTextState.textAlign = textAlign, context.textAlign = textAlign), contextTextState.textBaseline != textState.textBaseline && (contextTextState.textBaseline = textState.textBaseline, context.textBaseline = textState.textBaseline)) : (context.font = textState.font, context.textAlign = textAlign, context.textBaseline = 
      textState.textBaseline, this.contextTextState_ = {font:textState.font, textAlign, textBaseline:textState.textBaseline});
    }
    setFillStrokeStyle(fillStyle, strokeStyle) {
      fillStyle ? (fillStyle = fillStyle.getColor(), this.fillState_ = {fillStyle:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(fillStyle ? fillStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle)}) : this.fillState_ = null;
      if (strokeStyle) {
        fillStyle = strokeStyle.getColor();
        const strokeStyleLineCap = strokeStyle.getLineCap();
        var strokeStyleLineDash = strokeStyle.getLineDash();
        const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset(), strokeStyleLineJoin = strokeStyle.getLineJoin(), strokeStyleWidth = strokeStyle.getWidth();
        strokeStyle = strokeStyle.getMiterLimit();
        strokeStyleLineDash = strokeStyleLineDash ? strokeStyleLineDash : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash;
        this.strokeState_ = {lineCap:void 0 !== strokeStyleLineCap ? strokeStyleLineCap : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineCap, lineDash:1 === this.pixelRatio_ ? strokeStyleLineDash : strokeStyleLineDash.map(n => n * this.pixelRatio_), lineDashOffset:(strokeStyleLineDashOffset ? strokeStyleLineDashOffset : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset) * this.pixelRatio_, lineJoin:void 0 !== strokeStyleLineJoin ? strokeStyleLineJoin : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineJoin, 
        lineWidth:(void 0 !== strokeStyleWidth ? strokeStyleWidth : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineWidth) * this.pixelRatio_, miterLimit:void 0 !== strokeStyle ? strokeStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultMiterLimit, strokeStyle:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(fillStyle ? fillStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultStrokeStyle)};
      } else {
        this.strokeState_ = null;
      }
    }
    setImageStyle(imageStyle) {
      let imageSize;
      if (imageStyle && (imageSize = imageStyle.getSize())) {
        var imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_), imageAnchor = imageStyle.getAnchor(), imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        imageStyle = imageStyle.getScaleArray();
        this.imageScale_ = [imageStyle[0] * this.pixelRatio_ / imagePixelRatio, imageStyle[1] * this.pixelRatio_ / imagePixelRatio];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
      } else {
        this.image_ = null;
      }
    }
    setTextStyle(textStyle) {
      if (textStyle) {
        var textFillStyle = textStyle.getFill();
        textFillStyle ? (textFillStyle = textFillStyle.getColor(), this.textFillState_ = {fillStyle:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(textFillStyle ? textFillStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle)}) : this.textFillState_ = null;
        var textStrokeStyle = textStyle.getStroke();
        if (textStrokeStyle) {
          textFillStyle = textStrokeStyle.getColor();
          var textStrokeStyleLineCap = textStrokeStyle.getLineCap(), textStrokeStyleLineDash = textStrokeStyle.getLineDash(), textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset(), textStrokeStyleLineJoin = textStrokeStyle.getLineJoin(), textStrokeStyleWidth = textStrokeStyle.getWidth();
          textStrokeStyle = textStrokeStyle.getMiterLimit();
          this.textStrokeState_ = {lineCap:void 0 !== textStrokeStyleLineCap ? textStrokeStyleLineCap : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineCap, lineDash:textStrokeStyleLineDash ? textStrokeStyleLineDash : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash, lineDashOffset:textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset, lineJoin:void 0 !== textStrokeStyleLineJoin ? textStrokeStyleLineJoin : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineJoin, 
          lineWidth:void 0 !== textStrokeStyleWidth ? textStrokeStyleWidth : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineWidth, miterLimit:void 0 !== textStrokeStyle ? textStrokeStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultMiterLimit, strokeStyle:(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(textFillStyle ? textFillStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultStrokeStyle)};
        } else {
          this.textStrokeState_ = null;
        }
        textFillStyle = textStyle.getFont();
        textStrokeStyleLineCap = textStyle.getOffsetX();
        textStrokeStyleLineDash = textStyle.getOffsetY();
        textStrokeStyleLineDashOffset = textStyle.getRotateWithView();
        textStrokeStyleLineJoin = textStyle.getRotation();
        textStrokeStyleWidth = textStyle.getScaleArray();
        textStrokeStyle = textStyle.getText();
        const textTextAlign = textStyle.getTextAlign();
        textStyle = textStyle.getTextBaseline();
        this.textState_ = {font:void 0 !== textFillStyle ? textFillStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFont, textAlign:void 0 !== textTextAlign ? textTextAlign : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextAlign, textBaseline:void 0 !== textStyle ? textStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextBaseline};
        this.text_ = void 0 !== textStrokeStyle ? Array.isArray(textStrokeStyle) ? textStrokeStyle.reduce((acc, t, i) => acc + (i % 2 ? " " : t), "") : textStrokeStyle : "";
        this.textOffsetX_ = void 0 !== textStrokeStyleLineCap ? this.pixelRatio_ * textStrokeStyleLineCap : 0;
        this.textOffsetY_ = void 0 !== textStrokeStyleLineDash ? this.pixelRatio_ * textStrokeStyleLineDash : 0;
        this.textRotateWithView_ = void 0 !== textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : !1;
        this.textRotation_ = void 0 !== textStrokeStyleLineJoin ? textStrokeStyleLineJoin : 0;
        this.textScale_ = [this.pixelRatio_ * textStrokeStyleWidth[0], this.pixelRatio_ * textStrokeStyleWidth[1]];
      } else {
        this.text_ = "";
      }
    }
  }
  const $$default = CanvasImmediateRenderer;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$Immediate.js.map
