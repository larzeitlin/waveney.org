shadow$provide.module$node_modules$ol$proj = function(global, require, module, exports) {
  function disableCoordinateWarning(disable) {
    showCoordinateWarning = !(void 0 === disable || disable);
  }
  function cloneTransform(input, output) {
    if (void 0 !== output) {
      for (let i = 0, ii = input.length; i < ii; ++i) {
        output[i] = input[i];
      }
    } else {
      output = input.slice();
    }
    return output;
  }
  function identityTransform(input, output) {
    if (void 0 !== output && input !== output) {
      for (let i = 0, ii = input.length; i < ii; ++i) {
        output[i] = input[i];
      }
      input = output;
    }
    return input;
  }
  function addProjection(projection) {
    (0,require$_DOT__SLASH_proj_SLASH_projections_DOT_js.add)(projection.getCode(), projection);
    (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(projection, projection, cloneTransform);
  }
  function addProjections(projections) {
    projections.forEach(addProjection);
  }
  function get(projectionLike) {
    if ("string" !== typeof projectionLike) {
      return projectionLike;
    }
    var projection = (0,require$_DOT__SLASH_proj_SLASH_projections_DOT_js.get)(projectionLike);
    if (projection) {
      return projection;
    }
    for (const makeProjection of projectionFactories) {
      if (projection = makeProjection(projectionLike)) {
        return projection;
      }
    }
    return null;
  }
  function getPointResolution(projection, resolution, point, units) {
    projection = get(projection);
    var getter = projection.getPointResolutionFunc();
    if (getter) {
      resolution = getter(resolution, point), units && units !== projection.getUnits() && (projection = projection.getMetersPerUnit()) && (resolution = resolution * projection / require$_DOT__SLASH_proj_SLASH_Units_DOT_js.METERS_PER_UNIT[units]);
    } else {
      const projUnits = projection.getUnits();
      "degrees" == projUnits && !units || "degrees" == units || ((getter = getTransformFromProjections(projection, get("EPSG:4326"))) || "degrees" === projUnits ? (resolution = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2], resolution = getter(resolution, resolution, 2), point = (0,require$_DOT__SLASH_sphere_DOT_js.getDistance)(resolution.slice(0, 2), resolution.slice(2, 4)), resolution = (0,require$_DOT__SLASH_sphere_DOT_js.getDistance)(resolution.slice(4, 
      6), resolution.slice(6, 8)), resolution = (point + resolution) / 2) : resolution *= projection.getMetersPerUnit(), units = units ? require$_DOT__SLASH_proj_SLASH_Units_DOT_js.METERS_PER_UNIT[units] : projection.getMetersPerUnit(), void 0 !== units && (resolution /= units));
    }
    return resolution;
  }
  function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
      projections.forEach(function(destination) {
        source !== destination && (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(source, destination, cloneTransform);
      });
    });
  }
  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
      projections2.forEach(function(projection2) {
        (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(projection1, projection2, forwardTransform);
        (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(projection2, projection1, inverseTransform);
      });
    });
  }
  function clearAllProjections() {
    (0,require$_DOT__SLASH_proj_SLASH_projections_DOT_js.clear)();
    (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.clear)();
  }
  function createProjection(projection, defaultCode) {
    return projection ? "string" === typeof projection ? get(projection) : projection : get(defaultCode);
  }
  function createTransformFromCoordinateTransform(coordTransform) {
    return function(input, output, dimension, stride) {
      const length = input.length;
      dimension = void 0 !== dimension ? dimension : 2;
      stride = stride ?? dimension;
      output = void 0 !== output ? output : Array(length);
      for (let i = 0; i < length; i += stride) {
        const point = coordTransform(input.slice(i, i + dimension)), pointLength = point.length;
        for (let j = 0, jj = stride; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    };
  }
  function addCoordinateTransforms(source, destination, forward, inverse) {
    source = get(source);
    destination = get(destination);
    (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(source, destination, createTransformFromCoordinateTransform(forward));
    (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(destination, source, createTransformFromCoordinateTransform(inverse));
  }
  function fromLonLat(coordinate, projection) {
    disableCoordinateWarning();
    return transform(coordinate, "EPSG:4326", void 0 !== projection ? projection : "EPSG:3857");
  }
  function toLonLat(coordinate, projection) {
    coordinate = transform(coordinate, void 0 !== projection ? projection : "EPSG:3857", "EPSG:4326");
    projection = coordinate[0];
    if (-180 > projection || 180 < projection) {
      coordinate[0] = (0,require$_DOT__SLASH_math_DOT_js.modulo)(projection + 180, 360) - 180;
    }
    return coordinate;
  }
  function equivalent(projection1, projection2) {
    if (projection1 === projection2) {
      return !0;
    }
    const equalUnits = projection1.getUnits() === projection2.getUnits();
    return projection1.getCode() === projection2.getCode() ? equalUnits : getTransformFromProjections(projection1, projection2) === cloneTransform && equalUnits;
  }
  function getTransformFromProjections(source, destination) {
    const sourceCode = source.getCode(), destinationCode = destination.getCode();
    let transformFunc = (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.get)(sourceCode, destinationCode);
    if (transformFunc) {
      return transformFunc;
    }
    var sourceTransforms = null, destinationTransforms = null;
    for (const makeTransforms of transformFactories) {
      sourceTransforms || (sourceTransforms = makeTransforms(source)), destinationTransforms || (destinationTransforms = makeTransforms(destination));
    }
    if (!sourceTransforms && !destinationTransforms) {
      return null;
    }
    destinationTransforms ? sourceTransforms ? transformFunc = composeTransformFuncs(sourceTransforms.inverse, destinationTransforms.forward) : (sourceTransforms = (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.get)(sourceCode, "EPSG:4326")) && (transformFunc = composeTransformFuncs(sourceTransforms, destinationTransforms.forward)) : (destinationTransforms = (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.get)("EPSG:4326", destinationCode)) && (transformFunc = composeTransformFuncs(sourceTransforms.inverse, 
    destinationTransforms));
    transformFunc && (addProjection(source), addProjection(destination), (0,require$_DOT__SLASH_proj_SLASH_transforms_DOT_js.add)(source, destination, transformFunc));
    return transformFunc;
  }
  function composeTransformFuncs(t1, t2) {
    return function(input, output, dimensions, stride) {
      output = t1(input, output, dimensions, stride);
      return t2(output, output, dimensions, stride);
    };
  }
  function getTransform(source, destination) {
    source = get(source);
    destination = get(destination);
    return getTransformFromProjections(source, destination);
  }
  function transform(coordinate, source, destination) {
    const transformFunc = getTransform(source, destination);
    if (!transformFunc) {
      throw coordinate = get(source).getCode(), destination = get(destination).getCode(), Error(`No transform available between ${coordinate} and ${destination}`);
    }
    return transformFunc(coordinate, void 0, coordinate.length);
  }
  function transformExtent(extent, source, destination, stops) {
    source = getTransform(source, destination);
    return (0,require$_DOT__SLASH_extent_DOT_js.applyTransform)(extent, source, void 0, stops);
  }
  function transformWithProjections(point, sourceProjection, destinationProjection) {
    return getTransformFromProjections(sourceProjection, destinationProjection)(point);
  }
  function setUserProjection(projection) {
    userProjection = get(projection);
  }
  function clearUserProjection() {
    userProjection = null;
  }
  function getUserProjection() {
    return userProjection;
  }
  function useGeographic() {
    setUserProjection("EPSG:4326");
  }
  function toUserCoordinate(coordinate, sourceProjection) {
    return userProjection ? transform(coordinate, sourceProjection, userProjection) : coordinate;
  }
  function fromUserCoordinate(coordinate, destProjection) {
    return userProjection ? transform(coordinate, userProjection, destProjection) : (showCoordinateWarning && !(0,require$_DOT__SLASH_coordinate_DOT_js.equals)(coordinate, [0, 0]) && -180 <= coordinate[0] && 180 >= coordinate[0] && -90 <= coordinate[1] && 90 >= coordinate[1] && (showCoordinateWarning = !1, (0,require$_DOT__SLASH_console_DOT_js.warn)("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), coordinate);
  }
  function toUserExtent(extent, sourceProjection) {
    return userProjection ? transformExtent(extent, sourceProjection, userProjection) : extent;
  }
  function fromUserExtent(extent, destProjection) {
    return userProjection ? transformExtent(extent, userProjection, destProjection) : extent;
  }
  function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) {
      return resolution;
    }
    sourceProjection = get(sourceProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return sourceProjection && userMetersPerUnit ? resolution * sourceProjection / userMetersPerUnit : resolution;
  }
  function fromUserResolution(resolution, destProjection) {
    if (!userProjection) {
      return resolution;
    }
    destProjection = get(destProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return destProjection && userMetersPerUnit ? resolution * userMetersPerUnit / destProjection : resolution;
  }
  function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function(coord) {
      let worldsAway;
      if (sourceProj.canWrapX()) {
        const sourceExtent = sourceProj.getExtent(), sourceExtentWidth = (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(sourceExtent);
        coord = coord.slice(0);
        (worldsAway = (0,require$_DOT__SLASH_coordinate_DOT_js.getWorldsAway)(coord, sourceProj, sourceExtentWidth)) && (coord[0] -= worldsAway * sourceExtentWidth);
        coord[0] = (0,require$_DOT__SLASH_math_DOT_js.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
        coord[1] = (0,require$_DOT__SLASH_math_DOT_js.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
      }
      coord = transform(coord);
      worldsAway && destProj.canWrapX() && (coord[0] += worldsAway * (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(destProj.getExtent()));
      return coord;
    };
  }
  function addCommon() {
    addEquivalentProjections(require$_DOT__SLASH_proj_SLASH_epsg3857_DOT_js.PROJECTIONS);
    addEquivalentProjections(require$_DOT__SLASH_proj_SLASH_epsg4326_DOT_js.PROJECTIONS);
    addEquivalentTransforms(require$_DOT__SLASH_proj_SLASH_epsg4326_DOT_js.PROJECTIONS, require$_DOT__SLASH_proj_SLASH_epsg3857_DOT_js.PROJECTIONS, require$_DOT__SLASH_proj_SLASH_epsg3857_DOT_js.fromEPSG4326, require$_DOT__SLASH_proj_SLASH_epsg3857_DOT_js.toEPSG4326);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, METERS_PER_UNIT:{enumerable:!0, get:function() {
    return require$_DOT__SLASH_proj_SLASH_Units_DOT_js.METERS_PER_UNIT;
  }}, Projection:{enumerable:!0, get:function() {
    return default$$require$_DOT__SLASH_proj_SLASH_Projection_DOT_js.default;
  }}, addCommon:{enumerable:!0, get:function() {
    return addCommon;
  }}, addCoordinateTransforms:{enumerable:!0, get:function() {
    return addCoordinateTransforms;
  }}, addEquivalentProjections:{enumerable:!0, get:function() {
    return addEquivalentProjections;
  }}, addEquivalentTransforms:{enumerable:!0, get:function() {
    return addEquivalentTransforms;
  }}, addProjection:{enumerable:!0, get:function() {
    return addProjection;
  }}, addProjections:{enumerable:!0, get:function() {
    return addProjections;
  }}, clearAllProjections:{enumerable:!0, get:function() {
    return clearAllProjections;
  }}, clearUserProjection:{enumerable:!0, get:function() {
    return clearUserProjection;
  }}, cloneTransform:{enumerable:!0, get:function() {
    return cloneTransform;
  }}, createProjection:{enumerable:!0, get:function() {
    return createProjection;
  }}, createSafeCoordinateTransform:{enumerable:!0, get:function() {
    return createSafeCoordinateTransform;
  }}, createTransformFromCoordinateTransform:{enumerable:!0, get:function() {
    return createTransformFromCoordinateTransform;
  }}, disableCoordinateWarning:{enumerable:!0, get:function() {
    return disableCoordinateWarning;
  }}, equivalent:{enumerable:!0, get:function() {
    return equivalent;
  }}, fromLonLat:{enumerable:!0, get:function() {
    return fromLonLat;
  }}, fromUserCoordinate:{enumerable:!0, get:function() {
    return fromUserCoordinate;
  }}, fromUserExtent:{enumerable:!0, get:function() {
    return fromUserExtent;
  }}, fromUserResolution:{enumerable:!0, get:function() {
    return fromUserResolution;
  }}, get:{enumerable:!0, get:function() {
    return get;
  }}, getPointResolution:{enumerable:!0, get:function() {
    return getPointResolution;
  }}, getTransform:{enumerable:!0, get:function() {
    return getTransform;
  }}, getTransformFromProjections:{enumerable:!0, get:function() {
    return getTransformFromProjections;
  }}, getUserProjection:{enumerable:!0, get:function() {
    return getUserProjection;
  }}, identityTransform:{enumerable:!0, get:function() {
    return identityTransform;
  }}, setUserProjection:{enumerable:!0, get:function() {
    return setUserProjection;
  }}, toLonLat:{enumerable:!0, get:function() {
    return toLonLat;
  }}, toUserCoordinate:{enumerable:!0, get:function() {
    return toUserCoordinate;
  }}, toUserExtent:{enumerable:!0, get:function() {
    return toUserExtent;
  }}, toUserResolution:{enumerable:!0, get:function() {
    return toUserResolution;
  }}, transform:{enumerable:!0, get:function() {
    return transform;
  }}, transformExtent:{enumerable:!0, get:function() {
    return transformExtent;
  }}, transformWithProjections:{enumerable:!0, get:function() {
    return transformWithProjections;
  }}, useGeographic:{enumerable:!0, get:function() {
    return useGeographic;
  }}});
  var require$_DOT__SLASH_console_DOT_js = require("module$node_modules$ol$console"), require$_DOT__SLASH_coordinate_DOT_js = require("module$node_modules$ol$coordinate"), require$_DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math");
  global = require("module$node_modules$ol$proj$Projection");
  var require$_DOT__SLASH_proj_SLASH_Units_DOT_js = require("module$node_modules$ol$proj$Units"), require$_DOT__SLASH_proj_SLASH_epsg3857_DOT_js = require("module$node_modules$ol$proj$epsg3857"), require$_DOT__SLASH_proj_SLASH_epsg4326_DOT_js = require("module$node_modules$ol$proj$epsg4326"), require$_DOT__SLASH_proj_SLASH_projections_DOT_js = require("module$node_modules$ol$proj$projections"), require$_DOT__SLASH_proj_SLASH_transforms_DOT_js = require("module$node_modules$ol$proj$transforms");
  module = require("module$node_modules$ol$proj$utm");
  var require$_DOT__SLASH_sphere_DOT_js = require("module$node_modules$ol$sphere"), default$$require$_DOT__SLASH_proj_SLASH_Projection_DOT_js = require.esmDefault(global);
  const transformFactories = [module.makeTransforms], projectionFactories = [module.makeProjection];
  let showCoordinateWarning = !0, userProjection = null;
  addCommon();
};

//# sourceMappingURL=module$node_modules$ol$proj.js.map
