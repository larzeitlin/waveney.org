shadow$provide.module$node_modules$ol$render$canvas = function(global, require, module, exports) {
  function measureText(font, text) {
    measureContext || (measureContext = (0,require$_DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(1, 1));
    font != measureFont && (measureContext.font = font, measureFont = measureContext.font);
    return measureContext.measureText(text);
  }
  function measureTextWidth(font, text) {
    return measureText(font, text).width;
  }
  function measureAndCacheTextWidth(font, text, cache) {
    if (text in cache) {
      return cache[text];
    }
    const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
    return cache[text] = width;
  }
  function getTextDimensions(baseStyle, chunks) {
    const widths = [], heights = [], lineWidths = [];
    let width = 0, lineWidth = 0, height = 0, lineHeight = 0;
    for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
      var text = chunks[i];
      if ("\n" === text || i === ii) {
        width = Math.max(width, lineWidth), lineWidths.push(lineWidth), lineWidth = 0, height += lineHeight, lineHeight = 0;
      } else {
        var font = chunks[i + 1] || baseStyle.font;
        text = measureTextWidth(font, text);
        widths.push(text);
        lineWidth += text;
        font = measureTextHeight(font);
        heights.push(font);
        lineHeight = Math.max(lineHeight, font);
      }
    }
    return {width, height, widths, heights, lineWidths};
  }
  function rotateAtOffset(context, rotation, offsetX, offsetY) {
    0 !== rotation && (context.translate(offsetX, offsetY), context.rotate(rotation), context.translate(-offsetX, -offsetY));
  }
  function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
    context.save();
    1 !== opacity && (context.globalAlpha = void 0 === context.globalAlpha ? context => context.globalAlpha *= opacity : context.globalAlpha * opacity);
    transform && context.transform.apply(context, transform);
    labelOrImage.contextInstructions ? (context.translate(x, y), context.scale(scale[0], scale[1]), executeLabelInstructions(labelOrImage, context)) : 0 > scale[0] || 0 > scale[1] ? (context.translate(x, y), context.scale(scale[0], scale[1]), context.drawImage(labelOrImage, originX, originY, w, h, 0, 0, w, h)) : context.drawImage(labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
    context.restore();
  }
  function executeLabelInstructions(label, context) {
    label = label.contextInstructions;
    for (let i = 0, ii = label.length; i < ii; i += 2) {
      Array.isArray(label[i + 1]) ? context[label[i]].apply(context, label[i + 1]) : context[label[i]] = label[i + 1];
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, checkedFonts:{enumerable:!0, get:function() {
    return checkedFonts;
  }}, defaultFillStyle:{enumerable:!0, get:function() {
    return "#000";
  }}, defaultFont:{enumerable:!0, get:function() {
    return "10px sans-serif";
  }}, defaultLineCap:{enumerable:!0, get:function() {
    return "round";
  }}, defaultLineDash:{enumerable:!0, get:function() {
    return defaultLineDash;
  }}, defaultLineDashOffset:{enumerable:!0, get:function() {
    return 0;
  }}, defaultLineJoin:{enumerable:!0, get:function() {
    return "round";
  }}, defaultLineWidth:{enumerable:!0, get:function() {
    return 1;
  }}, defaultMiterLimit:{enumerable:!0, get:function() {
    return 10;
  }}, defaultPadding:{enumerable:!0, get:function() {
    return defaultPadding;
  }}, defaultStrokeStyle:{enumerable:!0, get:function() {
    return "#000";
  }}, defaultTextAlign:{enumerable:!0, get:function() {
    return "center";
  }}, defaultTextBaseline:{enumerable:!0, get:function() {
    return "middle";
  }}, drawImageOrLabel:{enumerable:!0, get:function() {
    return drawImageOrLabel;
  }}, getTextDimensions:{enumerable:!0, get:function() {
    return getTextDimensions;
  }}, measureAndCacheTextWidth:{enumerable:!0, get:function() {
    return measureAndCacheTextWidth;
  }}, measureTextHeight:{enumerable:!0, get:function() {
    return measureTextHeight;
  }}, measureTextWidth:{enumerable:!0, get:function() {
    return measureTextWidth;
  }}, registerFont:{enumerable:!0, get:function() {
    return registerFont;
  }}, rotateAtOffset:{enumerable:!0, get:function() {
    return rotateAtOffset;
  }}, textHeights:{enumerable:!0, get:function() {
    return textHeights;
  }}});
  global = require("module$node_modules$ol$Object");
  var require$_DOT__DOT__SLASH_css_DOT_js = require("module$node_modules$ol$css"), require$_DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__DOT__SLASH_has_DOT_js = require("module$node_modules$ol$has"), require$_DOT__DOT__SLASH_obj_DOT_js = require("module$node_modules$ol$obj");
  const defaultLineDash = [], defaultPadding = [0, 0, 0, 0], checkedFonts = new (require.esmDefault(global).default)();
  let measureContext = null, measureFont;
  const textHeights = {}, registerFont = function() {
    function isAvailable(fontStyle, fontWeight, fontFamily) {
      let available = !0;
      for (let i = 0; i < len; ++i) {
        var referenceFont = referenceFonts[i];
        referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " 32px " + referenceFont, "wmytzilWMYTZIL@#/\x26?$%10");
        fontFamily != referenceFont && (referenceFont = measureTextWidth(fontStyle + " " + fontWeight + " 32px " + fontFamily + "," + referenceFont, "wmytzilWMYTZIL@#/\x26?$%10"), available = available && referenceFont != referenceWidth);
      }
      return available ? !0 : !1;
    }
    function check() {
      let done = !0;
      const fonts = checkedFonts.getKeys();
      for (let i = 0, ii = fonts.length; i < ii; ++i) {
        const font = fonts[i];
        if (100 > checkedFonts.get(font)) {
          const [style, weight, family] = font.split("\n");
          isAvailable(style, weight, family) ? ((0,require$_DOT__DOT__SLASH_obj_DOT_js.clear)(textHeights), measureContext = null, measureFont = void 0, checkedFonts.set(font, 100)) : (checkedFonts.set(font, checkedFonts.get(font) + 1, !0), done = !1);
        }
      }
      done && (clearInterval(interval), interval = void 0);
    }
    const referenceFonts = ["monospace", "serif"], len = referenceFonts.length;
    let interval, referenceWidth;
    return function(fontSpec) {
      if (fontSpec = (0,require$_DOT__DOT__SLASH_css_DOT_js.getFontParameters)(fontSpec)) {
        var families = fontSpec.families;
        for (let i = 0, ii = families.length; i < ii; ++i) {
          const family = families[i], key = fontSpec.style + "\n" + fontSpec.weight + "\n" + family;
          void 0 === checkedFonts.get(key) && (checkedFonts.set(key, 100, !0), isAvailable(fontSpec.style, fontSpec.weight, family) || (checkedFonts.set(key, 0, !0), void 0 === interval && (interval = setInterval(check, 32))));
        }
      }
    };
  }(), measureTextHeight = function() {
    let measureElement;
    return function(fontSpec) {
      var height = textHeights[fontSpec];
      if (void 0 == height) {
        if (require$_DOT__DOT__SLASH_has_DOT_js.WORKER_OFFSCREEN_CANVAS) {
          height = (0,require$_DOT__DOT__SLASH_css_DOT_js.getFontParameters)(fontSpec);
          const metrics = measureText(fontSpec, "Žg");
          height = (isNaN(Number(height.lineHeight)) ? 1.2 : Number(height.lineHeight)) * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
        } else {
          measureElement || (measureElement = document.createElement("div"), measureElement.innerHTML = "M", measureElement.style.minHeight = "0", measureElement.style.maxHeight = "none", measureElement.style.height = "auto", measureElement.style.padding = "0", measureElement.style.border = "none", measureElement.style.position = "absolute", measureElement.style.display = "block", measureElement.style.left = "-99999px"), measureElement.style.font = fontSpec, document.body.appendChild(measureElement), 
          height = measureElement.offsetHeight, document.body.removeChild(measureElement);
        }
        textHeights[fontSpec] = height;
      }
      return height;
    };
  }();
};

//# sourceMappingURL=module$node_modules$ol$render$canvas.js.map
