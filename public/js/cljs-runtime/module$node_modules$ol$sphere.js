shadow$provide.module$node_modules$ol$sphere = function(global, require, module, exports) {
  function getDistance(c1, c2, radius) {
    radius = radius || 6371008.8;
    var lat1 = (0,require$_DOT__SLASH_math_DOT_js.toRadians)(c1[1]);
    const lat2 = (0,require$_DOT__SLASH_math_DOT_js.toRadians)(c2[1]), deltaLatBy2 = (lat2 - lat1) / 2;
    c1 = (0,require$_DOT__SLASH_math_DOT_js.toRadians)(c2[0] - c1[0]) / 2;
    lat1 = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(c1) * Math.sin(c1) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(lat1), Math.sqrt(1 - lat1));
  }
  function getLengthInternal(coordinates, radius) {
    let length = 0;
    for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {
      length += getDistance(coordinates[i], coordinates[i + 1], radius);
    }
    return length;
  }
  function getLength(geometry, options) {
    options = options || {};
    var radius = options.radius || 6371008.8, projection = options.projection || "EPSG:3857", type = geometry.getType();
    "GeometryCollection" !== type && (geometry = geometry.clone().transform(projection, "EPSG:4326"));
    projection = 0;
    let coords, j, jj;
    switch(type) {
      case "Point":
      case "MultiPoint":
        break;
      case "LineString":
      case "LinearRing":
        options = geometry.getCoordinates();
        projection = getLengthInternal(options, radius);
        break;
      case "MultiLineString":
      case "Polygon":
        options = geometry.getCoordinates();
        geometry = 0;
        for (type = options.length; geometry < type; ++geometry) {
          projection += getLengthInternal(options[geometry], radius);
        }
        break;
      case "MultiPolygon":
        options = geometry.getCoordinates();
        geometry = 0;
        for (type = options.length; geometry < type; ++geometry) {
          for (coords = options[geometry], j = 0, jj = coords.length; j < jj; ++j) {
            projection += getLengthInternal(coords[j], radius);
          }
        }
        break;
      case "GeometryCollection":
        radius = geometry.getGeometries();
        geometry = 0;
        for (type = radius.length; geometry < type; ++geometry) {
          projection += getLength(radius[geometry], options);
        }
        break;
      default:
        throw Error("Unsupported geometry type: " + type);
    }
    return projection;
  }
  function getAreaInternal(coordinates, radius) {
    let area = 0;
    const len = coordinates.length;
    let x1 = coordinates[len - 1][0], y1 = coordinates[len - 1][1];
    for (let i = 0; i < len; i++) {
      const x2 = coordinates[i][0], y2 = coordinates[i][1];
      area += (0,require$_DOT__SLASH_math_DOT_js.toRadians)(x2 - x1) * (2 + Math.sin((0,require$_DOT__SLASH_math_DOT_js.toRadians)(y1)) + Math.sin((0,require$_DOT__SLASH_math_DOT_js.toRadians)(y2)));
      x1 = x2;
      y1 = y2;
    }
    return area * radius * radius / 2.0;
  }
  function getArea(geometry, options) {
    options = options || {};
    var radius = options.radius || 6371008.8, projection = options.projection || "EPSG:3857", type = geometry.getType();
    "GeometryCollection" !== type && (geometry = geometry.clone().transform(projection, "EPSG:4326"));
    projection = 0;
    let coords, j, jj;
    switch(type) {
      case "Point":
      case "MultiPoint":
      case "LineString":
      case "MultiLineString":
      case "LinearRing":
        break;
      case "Polygon":
        options = geometry.getCoordinates();
        projection = Math.abs(getAreaInternal(options[0], radius));
        geometry = 1;
        for (type = options.length; geometry < type; ++geometry) {
          projection -= Math.abs(getAreaInternal(options[geometry], radius));
        }
        break;
      case "MultiPolygon":
        options = geometry.getCoordinates();
        geometry = 0;
        for (type = options.length; geometry < type; ++geometry) {
          for (coords = options[geometry], projection += Math.abs(getAreaInternal(coords[0], radius)), j = 1, jj = coords.length; j < jj; ++j) {
            projection -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }
        break;
      case "GeometryCollection":
        radius = geometry.getGeometries();
        geometry = 0;
        for (type = radius.length; geometry < type; ++geometry) {
          projection += getArea(radius[geometry], options);
        }
        break;
      default:
        throw Error("Unsupported geometry type: " + type);
    }
    return projection;
  }
  function offset(c1, distance, bearing, radius) {
    radius = radius || 6371008.8;
    const lat1 = (0,require$_DOT__SLASH_math_DOT_js.toRadians)(c1[1]);
    c1 = (0,require$_DOT__SLASH_math_DOT_js.toRadians)(c1[0]);
    distance /= radius;
    radius = Math.asin(Math.sin(lat1) * Math.cos(distance) + Math.cos(lat1) * Math.sin(distance) * Math.cos(bearing));
    return [(0,require$_DOT__SLASH_math_DOT_js.toDegrees)(c1 + Math.atan2(Math.sin(bearing) * Math.sin(distance) * Math.cos(lat1), Math.cos(distance) - Math.sin(lat1) * Math.sin(radius))), (0,require$_DOT__SLASH_math_DOT_js.toDegrees)(radius)];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, DEFAULT_RADIUS:{enumerable:!0, get:function() {
    return 6371008.8;
  }}, getArea:{enumerable:!0, get:function() {
    return getArea;
  }}, getDistance:{enumerable:!0, get:function() {
    return getDistance;
  }}, getLength:{enumerable:!0, get:function() {
    return getLength;
  }}, offset:{enumerable:!0, get:function() {
    return offset;
  }}});
  var require$_DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math");
};

//# sourceMappingURL=module$node_modules$ol$sphere.js.map
