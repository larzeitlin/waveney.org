shadow$provide.module$node_modules$ol$render$canvas$Builder = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js = require("module$node_modules$ol$colorlike");
  global = require("module$node_modules$ol$extent$Relationship");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js = require("module$node_modules$ol$geom$flat$inflate");
  module = require("module$node_modules$ol$render$VectorContext");
  var require$_DOT__DOT__SLASH_canvas_DOT_js = require("module$node_modules$ol$render$canvas");
  exports = require("module$node_modules$ol$render$canvas$Instruction");
  var default$$require$_DOT__SLASH_Instruction_DOT_js = require.esmDefault(exports), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_SLASH_Relationship_DOT_js = require.esmDefault(global);
  require = require.esmDefault(module);
  class CanvasBuilder extends require.default {
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super();
      this.tolerance = tolerance;
      this.maxExtent = maxExtent;
      this.pixelRatio = pixelRatio;
      this.maxLineWidth = 0;
      this.resolution = resolution;
      this.bufferedMaxExtent_ = this.beginGeometryInstruction2_ = this.beginGeometryInstruction1_ = null;
      this.instructions = [];
      this.coordinates = [];
      this.tmpCoordinate_ = [];
      this.hitDetectionInstructions = [];
      this.state = {};
    }
    applyPixelRatio(dashArray) {
      const pixelRatio = this.pixelRatio;
      return 1 == pixelRatio ? dashArray : dashArray.map(function(dash) {
        return dash * pixelRatio;
      });
    }
    appendFlatPointCoordinates(flatCoordinates, stride) {
      const extent = this.getBufferedMaxExtent(), tmpCoord = this.tmpCoordinate_, coordinates = this.coordinates;
      let myEnd = coordinates.length;
      for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        tmpCoord[0] = flatCoordinates[i], tmpCoord[1] = flatCoordinates[i + 1], (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(extent, tmpCoord) && (coordinates[myEnd++] = tmpCoord[0], coordinates[myEnd++] = tmpCoord[1]);
      }
      return myEnd;
    }
    appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
      const coordinates = this.coordinates;
      let myEnd = coordinates.length;
      const extent = this.getBufferedMaxExtent();
      skipFirst && (offset += stride);
      skipFirst = flatCoordinates[offset];
      let lastYCoord = flatCoordinates[offset + 1];
      const nextCoord = this.tmpCoordinate_;
      let skipped = !0, i, lastRel, nextRel;
      for (i = offset + stride; i < end; i += stride) {
        nextCoord[0] = flatCoordinates[i], nextCoord[1] = flatCoordinates[i + 1], nextRel = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.coordinateRelationship)(extent, nextCoord), nextRel !== lastRel ? (skipped && (coordinates[myEnd++] = skipFirst, coordinates[myEnd++] = lastYCoord, skipped = !1), coordinates[myEnd++] = nextCoord[0], coordinates[myEnd++] = nextCoord[1]) : nextRel === default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.INTERSECTING ? 
        (coordinates[myEnd++] = nextCoord[0], coordinates[myEnd++] = nextCoord[1], skipped = !1) : skipped = !0, skipFirst = nextCoord[0], lastYCoord = nextCoord[1], lastRel = nextRel;
      }
      if (closed && skipped || i === offset + stride) {
        coordinates[myEnd++] = skipFirst, coordinates[myEnd++] = lastYCoord;
      }
      return myEnd;
    }
    drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        const end = ends[i];
        offset = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, !1, !1);
        builderEnds.push(offset);
        offset = end;
      }
      return offset;
    }
    drawCustom(geometry, feature, renderer, hitDetectionRenderer, index) {
      this.beginGeometry(geometry, feature, index);
      var type = geometry.getType(), stride = geometry.getStride();
      const builderBegin = this.coordinates.length;
      let offset;
      switch(type) {
        case "MultiPolygon":
          type = geometry.getOrientedFlatCoordinates();
          var builderEnds = [];
          const endss = geometry.getEndss();
          offset = 0;
          for (let i = 0, ii = endss.length; i < ii; ++i) {
            const myEnds = [];
            offset = this.drawCustomCoordinates_(type, offset, endss[i], stride, myEnds);
            builderEnds.push(myEnds);
          }
          this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, builderEnds, geometry, renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateMultiCoordinatesArray, index]);
          this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateMultiCoordinatesArray, index]);
          break;
        case "Polygon":
        case "MultiLineString":
          builderEnds = [];
          type = "Polygon" == type ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
          this.drawCustomCoordinates_(type, 0, geometry.getEnds(), stride, builderEnds);
          this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, builderEnds, geometry, renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinatesArray, index]);
          this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinatesArray, index]);
          break;
        case "LineString":
        case "Circle":
          type = geometry.getFlatCoordinates();
          stride = this.appendFlatLineCoordinates(type, 0, type.length, stride, !1, !1);
          this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, stride, geometry, renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinates, index]);
          this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, stride, geometry, hitDetectionRenderer || renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinates, index]);
          break;
        case "MultiPoint":
          type = geometry.getFlatCoordinates();
          stride = this.appendFlatPointCoordinates(type, stride);
          stride > builderBegin && (this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, stride, geometry, renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinates, index]), this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, stride, geometry, hitDetectionRenderer || renderer, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinates, 
          index]));
          break;
        case "Point":
          type = geometry.getFlatCoordinates(), this.coordinates.push(type[0], type[1]), stride = this.coordinates.length, this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, stride, geometry, renderer, void 0, index]), this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM, builderBegin, stride, geometry, hitDetectionRenderer || renderer, void 0, index]);
      }
      this.endGeometry(feature);
    }
    beginGeometry(geometry, feature, index) {
      this.beginGeometryInstruction1_ = [default$$require$_DOT__SLASH_Instruction_DOT_js.default.BEGIN_GEOMETRY, feature, 0, geometry, index];
      this.instructions.push(this.beginGeometryInstruction1_);
      this.beginGeometryInstruction2_ = [default$$require$_DOT__SLASH_Instruction_DOT_js.default.BEGIN_GEOMETRY, feature, 0, geometry, index];
      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    finish() {
      return {instructions:this.instructions, hitDetectionInstructions:this.hitDetectionInstructions, coordinates:this.coordinates};
    }
    reverseHitDetectionInstructions() {
      const hitDetectionInstructions = this.hitDetectionInstructions;
      hitDetectionInstructions.reverse();
      let i;
      const n = hitDetectionInstructions.length;
      let instruction, type, begin = -1;
      for (i = 0; i < n; ++i) {
        instruction = hitDetectionInstructions[i], type = instruction[0], type == default$$require$_DOT__SLASH_Instruction_DOT_js.default.END_GEOMETRY ? begin = i : type == default$$require$_DOT__SLASH_Instruction_DOT_js.default.BEGIN_GEOMETRY && (instruction[2] = i, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.reverseSubArray)(this.hitDetectionInstructions, begin, i), begin = -1);
      }
    }
    fillStyleToState(fillStyle, state = {}) {
      fillStyle ? (fillStyle = fillStyle.getColor(), state.fillPatternScale = fillStyle && "object" === typeof fillStyle && "src" in fillStyle ? this.pixelRatio : 1, state.fillStyle = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(fillStyle ? fillStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle)) : state.fillStyle = void 0;
      return state;
    }
    strokeStyleToState(strokeStyle, state = {}) {
      if (strokeStyle) {
        var strokeStyleColor = strokeStyle.getColor();
        state.strokeStyle = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(strokeStyleColor ? strokeStyleColor : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultStrokeStyle);
        strokeStyleColor = strokeStyle.getLineCap();
        state.lineCap = void 0 !== strokeStyleColor ? strokeStyleColor : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineCap;
        strokeStyleColor = strokeStyle.getLineDash();
        state.lineDash = strokeStyleColor ? strokeStyleColor.slice() : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash;
        strokeStyleColor = strokeStyle.getLineDashOffset();
        state.lineDashOffset = strokeStyleColor ? strokeStyleColor : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset;
        strokeStyleColor = strokeStyle.getLineJoin();
        state.lineJoin = void 0 !== strokeStyleColor ? strokeStyleColor : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineJoin;
        strokeStyleColor = strokeStyle.getWidth();
        state.lineWidth = void 0 !== strokeStyleColor ? strokeStyleColor : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineWidth;
        strokeStyle = strokeStyle.getMiterLimit();
        state.miterLimit = void 0 !== strokeStyle ? strokeStyle : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultMiterLimit;
        state.lineWidth > this.maxLineWidth && (this.maxLineWidth = state.lineWidth, this.bufferedMaxExtent_ = null);
      } else {
        state.strokeStyle = void 0, state.lineCap = void 0, state.lineDash = null, state.lineDashOffset = void 0, state.lineJoin = void 0, state.lineWidth = void 0, state.miterLimit = void 0;
      }
      return state;
    }
    setFillStrokeStyle(fillStyle, strokeStyle) {
      const state = this.state;
      this.fillStyleToState(fillStyle, state);
      this.strokeStyleToState(strokeStyle, state);
    }
    createFill(state) {
      const fillStyle = state.fillStyle, fillInstruction = [default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_FILL_STYLE, fillStyle];
      "string" !== typeof fillStyle && fillInstruction.push(state.fillPatternScale);
      return fillInstruction;
    }
    applyStroke(state) {
      this.instructions.push(this.createStroke(state));
    }
    createStroke(state) {
      return [default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash ? this.applyPixelRatio(state.lineDash) : null, state.lineDashOffset * this.pixelRatio];
    }
    updateFillStyle(state, createFill) {
      const fillStyle = state.fillStyle;
      if ("string" !== typeof fillStyle || state.currentFillStyle != fillStyle) {
        void 0 !== fillStyle && this.instructions.push(createFill.call(this, state)), state.currentFillStyle = fillStyle;
      }
    }
    updateStrokeStyle(state, applyStroke) {
      const strokeStyle = state.strokeStyle, lineCap = state.lineCap, lineDash = state.lineDash, lineDashOffset = state.lineDashOffset, lineJoin = state.lineJoin, lineWidth = state.lineWidth, miterLimit = state.miterLimit;
      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
        void 0 !== strokeStyle && applyStroke.call(this, state), state.currentStrokeStyle = strokeStyle, state.currentLineCap = lineCap, state.currentLineDash = lineDash, state.currentLineDashOffset = lineDashOffset, state.currentLineJoin = lineJoin, state.currentLineWidth = lineWidth, state.currentMiterLimit = miterLimit;
      }
    }
    endGeometry(feature) {
      this.beginGeometryInstruction1_[2] = this.instructions.length;
      this.beginGeometryInstruction1_ = null;
      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
      this.beginGeometryInstruction2_ = null;
      feature = [default$$require$_DOT__SLASH_Instruction_DOT_js.default.END_GEOMETRY, feature];
      this.instructions.push(feature);
      this.hitDetectionInstructions.push(feature);
    }
    getBufferedMaxExtent() {
      this.bufferedMaxExtent_ || (this.bufferedMaxExtent_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.clone)(this.maxExtent), 0 < this.maxLineWidth && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.buffer)(this.bufferedMaxExtent_, this.resolution * (this.maxLineWidth + 1) / 2, this.bufferedMaxExtent_));
      return this.bufferedMaxExtent_;
    }
  }
  const $$default = CanvasBuilder;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$Builder.js.map
