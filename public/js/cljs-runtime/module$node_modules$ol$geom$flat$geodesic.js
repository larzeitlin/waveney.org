shadow$provide.module$node_modules$ol$geom$flat$geodesic = function(global, require, module, exports) {
  function line(interpolate, transform, squaredTolerance) {
    const flatCoordinates = [];
    let geoA = interpolate(0);
    var geoB = interpolate(1);
    let a = transform(geoA), b = transform(geoB);
    const geoStack = [geoB, geoA], stack = [b, a], fractionStack = [1, 0], fractions = {};
    let maxIterations = 1e5, geoM, m, fracA, fracB, fracM;
    for (; 0 < --maxIterations && 0 < fractionStack.length;) {
      fracA = fractionStack.pop(), geoA = geoStack.pop(), a = stack.pop(), geoB = fracA.toString(), geoB in fractions || (flatCoordinates.push(a[0], a[1]), fractions[geoB] = !0), fracB = fractionStack.pop(), geoB = geoStack.pop(), b = stack.pop(), fracM = (fracA + fracB) / 2, geoM = interpolate(fracM), m = transform(geoM), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredSegmentDistance)(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance ? (flatCoordinates.push(b[0], b[1]), geoB = 
      fracB.toString(), fractions[geoB] = !0) : (fractionStack.push(fracB, fracM, fracM, fracA), stack.push(b, m, m, a), geoStack.push(geoB, geoM, geoM, geoA));
    }
    return flatCoordinates;
  }
  function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {
    const geoProjection = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.get)("EPSG:4326"), cosLat1 = Math.cos((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lat1)), sinLat1 = Math.sin((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lat1)), cosLat2 = Math.cos((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lat2)), sinLat2 = Math.sin((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lat2)), cosDeltaLon = Math.cos((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lon2 - 
    lon1)), sinDeltaLon = Math.sin((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lon2 - lon1)), d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;
    return line(function(frac) {
      if (1 <= d) {
        return [lon2, lat2];
      }
      var D = frac * Math.acos(d);
      frac = Math.cos(D);
      const sinD = Math.sin(D), theta = Math.atan2(sinDeltaLon * cosLat2, cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon);
      D = Math.asin(sinLat1 * frac + cosLat1 * sinD * Math.cos(theta));
      frac = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toRadians)(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, frac - sinLat1 * Math.sin(D));
      return [(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toDegrees)(frac), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.toDegrees)(D)];
    }, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getTransform)(geoProjection, projection), squaredTolerance);
  }
  function meridian(lon, lat1, lat2, projection, squaredTolerance) {
    const epsg4326Projection = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.get)("EPSG:4326");
    return line(function(frac) {
      return [lon, lat1 + (lat2 - lat1) * frac];
    }, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getTransform)(epsg4326Projection, projection), squaredTolerance);
  }
  function parallel(lat, lon1, lon2, projection, squaredTolerance) {
    const epsg4326Projection = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.get)("EPSG:4326");
    return line(function(frac) {
      return [lon1 + (lon2 - lon1) * frac, lat];
    }, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getTransform)(epsg4326Projection, projection), squaredTolerance);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, greatCircleArc:{enumerable:!0, get:function() {
    return greatCircleArc;
  }}, meridian:{enumerable:!0, get:function() {
    return meridian;
  }}, parallel:{enumerable:!0, get:function() {
    return parallel;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj");
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$geodesic.js.map
