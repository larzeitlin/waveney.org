shadow$provide.module$node_modules$ol$render$canvas$style = function(global, require, module, exports) {
  function always(context) {
    return !0;
  }
  function rulesToStyleFunction(rules) {
    const parsingContext = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.newParsingContext)(), evaluator = buildRuleSet(rules, parsingContext), evaluationContext = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.newEvaluationContext)();
    return function(feature, resolution) {
      evaluationContext.properties = feature.getPropertiesInternal();
      evaluationContext.resolution = resolution;
      parsingContext.featureId && (resolution = feature.getId(), evaluationContext.featureId = void 0 !== resolution ? resolution : null);
      parsingContext.geometryType && (evaluationContext.geometryType = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.computeGeometryType)(feature.getGeometry()));
      return evaluator(evaluationContext);
    };
  }
  function flatStylesToStyleFunction(flatStyles) {
    const parsingContext = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.newParsingContext)(), length = flatStyles.length, evaluators = Array(length);
    for (let i = 0; i < length; ++i) {
      evaluators[i] = buildStyle(flatStyles[i], parsingContext);
    }
    const evaluationContext = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.newEvaluationContext)(), styles = Array(length);
    return function(feature, resolution) {
      evaluationContext.properties = feature.getPropertiesInternal();
      evaluationContext.resolution = resolution;
      parsingContext.featureId && (feature = feature.getId(), evaluationContext.featureId = void 0 !== feature ? feature : null);
      feature = 0;
      for (resolution = 0; resolution < length; ++resolution) {
        const style = evaluators[resolution](evaluationContext);
        style && (styles[feature] = style, feature += 1);
      }
      styles.length = feature;
      return styles;
    };
  }
  function buildRuleSet(rules, context) {
    const length = rules.length, compiledRules = Array(length);
    for (let i = 0; i < length; ++i) {
      const rule = rules[i], filter = "filter" in rule ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(rule.filter, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.BooleanType, context) : always;
      let styles;
      if (Array.isArray(rule.style)) {
        const styleLength = rule.style.length;
        styles = Array(styleLength);
        for (let j = 0; j < styleLength; ++j) {
          styles[j] = buildStyle(rule.style[j], context);
        }
      } else {
        styles = [buildStyle(rule.style, context)];
      }
      compiledRules[i] = {filter, styles};
    }
    return function(context) {
      const styles = [];
      let someMatched = !1;
      for (let i = 0; i < length; ++i) {
        var filterEvaluator = compiledRules[i].filter;
        if (filterEvaluator(context) && (!rules[i].else || !someMatched)) {
          someMatched = !0;
          for (const styleEvaluator of compiledRules[i].styles) {
            (filterEvaluator = styleEvaluator(context)) && styles.push(filterEvaluator);
          }
        }
      }
      return styles;
    };
  }
  function buildStyle(flatStyle, context) {
    const evaluateFill = buildFill(flatStyle, "", context), evaluateStroke = buildStroke(flatStyle, "", context), evaluateText = buildText(flatStyle, context), evaluateImage = buildImage(flatStyle, context), evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
    if (!(evaluateFill || evaluateStroke || evaluateText || evaluateImage || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_obj_DOT_js.isEmpty)(flatStyle))) {
      throw Error("No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle));
    }
    const style = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Style_DOT_js.default();
    return function(context) {
      let empty = !0;
      if (evaluateFill) {
        var fill = evaluateFill(context);
        fill && (empty = !1);
        style.setFill(fill);
      }
      evaluateStroke && ((fill = evaluateStroke(context)) && (empty = !1), style.setStroke(fill));
      evaluateText && ((fill = evaluateText(context)) && (empty = !1), style.setText(fill));
      evaluateImage && ((fill = evaluateImage(context)) && (empty = !1), style.setImage(fill));
      evaluateZIndex && style.setZIndex(evaluateZIndex(context));
      return empty ? null : style;
    };
  }
  function buildFill(flatStyle, prefix, context) {
    let evaluateColor;
    if (prefix + "fill-pattern-src" in flatStyle) {
      evaluateColor = patternEvaluator(flatStyle, prefix + "fill-", context);
    } else {
      if ("none" === flatStyle[prefix + "fill-color"]) {
        return context => null;
      }
      evaluateColor = colorLikeEvaluator(flatStyle, prefix + "fill-color", context);
    }
    if (!evaluateColor) {
      return null;
    }
    const fill = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Fill_DOT_js.default();
    return function(context) {
      context = evaluateColor(context);
      if (context === require$_DOT__DOT__SLASH__DOT__DOT__SLASH_color_DOT_js.NO_COLOR) {
        return null;
      }
      fill.setColor(context);
      return fill;
    };
  }
  function buildStroke(flatStyle, prefix, context) {
    const evaluateWidth = numberEvaluator(flatStyle, prefix + "stroke-width", context), evaluateColor = colorLikeEvaluator(flatStyle, prefix + "stroke-color", context);
    if (!evaluateWidth && !evaluateColor) {
      return null;
    }
    const evaluateLineCap = stringEvaluator(flatStyle, prefix + "stroke-line-cap", context), evaluateLineJoin = stringEvaluator(flatStyle, prefix + "stroke-line-join", context), evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + "stroke-line-dash", context), evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + "stroke-line-dash-offset", context), evaluateMiterLimit = numberEvaluator(flatStyle, prefix + "stroke-miter-limit", context), stroke = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js.default();
    return function(context) {
      if (evaluateColor) {
        var color = evaluateColor(context);
        if (color === require$_DOT__DOT__SLASH__DOT__DOT__SLASH_color_DOT_js.NO_COLOR) {
          return null;
        }
        stroke.setColor(color);
      }
      evaluateWidth && stroke.setWidth(evaluateWidth(context));
      if (evaluateLineCap) {
        color = evaluateLineCap(context);
        if ("butt" !== color && "round" !== color && "square" !== color) {
          throw Error("Expected butt, round, or square line cap");
        }
        stroke.setLineCap(color);
      }
      if (evaluateLineJoin) {
        color = evaluateLineJoin(context);
        if ("bevel" !== color && "round" !== color && "miter" !== color) {
          throw Error("Expected bevel, round, or miter line join");
        }
        stroke.setLineJoin(color);
      }
      evaluateLineDash && stroke.setLineDash(evaluateLineDash(context));
      evaluateLineDashOffset && stroke.setLineDashOffset(evaluateLineDashOffset(context));
      evaluateMiterLimit && stroke.setMiterLimit(evaluateMiterLimit(context));
      return stroke;
    };
  }
  function buildText(flatStyle, context) {
    const evaluateValue = stringEvaluator(flatStyle, "text-value", context);
    if (!evaluateValue) {
      return null;
    }
    const evaluateFill = buildFill(flatStyle, "text-", context), evaluateBackgroundFill = buildFill(flatStyle, "text-background-", context), evaluateStroke = buildStroke(flatStyle, "text-", context), evaluateBackgroundStroke = buildStroke(flatStyle, "text-background-", context), evaluateFont = stringEvaluator(flatStyle, "text-font", context), evaluateMaxAngle = numberEvaluator(flatStyle, "text-max-angle", context), evaluateOffsetX = numberEvaluator(flatStyle, "text-offset-x", context), evaluateOffsetY = 
    numberEvaluator(flatStyle, "text-offset-y", context), evaluateOverflow = booleanEvaluator(flatStyle, "text-overflow", context), evaluatePlacement = stringEvaluator(flatStyle, "text-placement", context), evaluateRepeat = numberEvaluator(flatStyle, "text-repeat", context), evaluateScale = sizeLikeEvaluator(flatStyle, "text-scale", context), evaluateRotateWithView = booleanEvaluator(flatStyle, "text-rotate-with-view", context), evaluateRotation = numberEvaluator(flatStyle, "text-rotation", context), 
    evaluateAlign = stringEvaluator(flatStyle, "text-align", context), evaluateJustify = stringEvaluator(flatStyle, "text-justify", context), evaluateBaseline = stringEvaluator(flatStyle, "text-baseline", context), evaluateKeepUpright = booleanEvaluator(flatStyle, "text-keep-upright", context), evaluatePadding = numberArrayEvaluator(flatStyle, "text-padding", context);
    flatStyle = optionalDeclutterMode(flatStyle, "text-declutter-mode");
    const text = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Text_DOT_js.default({declutterMode:flatStyle});
    return function(context) {
      text.setText(evaluateValue(context));
      evaluateFill && text.setFill(evaluateFill(context));
      evaluateBackgroundFill && text.setBackgroundFill(evaluateBackgroundFill(context));
      evaluateStroke && text.setStroke(evaluateStroke(context));
      evaluateBackgroundStroke && text.setBackgroundStroke(evaluateBackgroundStroke(context));
      evaluateFont && text.setFont(evaluateFont(context));
      evaluateMaxAngle && text.setMaxAngle(evaluateMaxAngle(context));
      evaluateOffsetX && text.setOffsetX(evaluateOffsetX(context));
      evaluateOffsetY && text.setOffsetY(evaluateOffsetY(context));
      evaluateOverflow && text.setOverflow(evaluateOverflow(context));
      if (evaluatePlacement) {
        var placement = evaluatePlacement(context);
        if ("point" !== placement && "line" !== placement) {
          throw Error("Expected point or line for text-placement");
        }
        text.setPlacement(placement);
      }
      evaluateRepeat && text.setRepeat(evaluateRepeat(context));
      evaluateScale && text.setScale(evaluateScale(context));
      evaluateRotateWithView && text.setRotateWithView(evaluateRotateWithView(context));
      evaluateRotation && text.setRotation(evaluateRotation(context));
      if (evaluateAlign) {
        placement = evaluateAlign(context);
        if ("left" !== placement && "center" !== placement && "right" !== placement && "end" !== placement && "start" !== placement) {
          throw Error("Expected left, right, center, start, or end for text-align");
        }
        text.setTextAlign(placement);
      }
      if (evaluateJustify) {
        placement = evaluateJustify(context);
        if ("left" !== placement && "right" !== placement && "center" !== placement) {
          throw Error("Expected left, right, or center for text-justify");
        }
        text.setJustify(placement);
      }
      if (evaluateBaseline) {
        placement = evaluateBaseline(context);
        if ("bottom" !== placement && "top" !== placement && "middle" !== placement && "alphabetic" !== placement && "hanging" !== placement) {
          throw Error("Expected bottom, top, middle, alphabetic, or hanging for text-baseline");
        }
        text.setTextBaseline(placement);
      }
      evaluatePadding && text.setPadding(evaluatePadding(context));
      evaluateKeepUpright && text.setKeepUpright(evaluateKeepUpright(context));
      return text;
    };
  }
  function buildImage(flatStyle, context) {
    return "icon-src" in flatStyle ? buildIcon(flatStyle, context) : "shape-points" in flatStyle ? buildShape(flatStyle, context) : "circle-radius" in flatStyle ? buildCircle(flatStyle, context) : null;
  }
  function buildIcon(flatStyle, context) {
    const src = requireString(flatStyle["icon-src"], "icon-src"), evaluateAnchor = coordinateEvaluator(flatStyle, "icon-anchor", context), evaluateScale = sizeLikeEvaluator(flatStyle, "icon-scale", context), evaluateOpacity = numberEvaluator(flatStyle, "icon-opacity", context), evaluateDisplacement = coordinateEvaluator(flatStyle, "icon-displacement", context), evaluateRotation = numberEvaluator(flatStyle, "icon-rotation", context), evaluateRotateWithView = booleanEvaluator(flatStyle, "icon-rotate-with-view", 
    context);
    context = optionalIconOrigin(flatStyle, "icon-anchor-origin");
    const anchorXUnits = optionalIconAnchorUnits(flatStyle, "icon-anchor-x-units"), anchorYUnits = optionalIconAnchorUnits(flatStyle, "icon-anchor-y-units"), color = optionalColorLike(flatStyle, "icon-color"), crossOrigin = optionalString(flatStyle, "icon-cross-origin"), offset = optionalNumberArray(flatStyle, "icon-offset"), offsetOrigin = optionalIconOrigin(flatStyle, "icon-offset-origin"), width = optionalNumber(flatStyle, "icon-width"), height = optionalNumber(flatStyle, "icon-height"), size = 
    optionalSize(flatStyle, "icon-size");
    flatStyle = optionalDeclutterMode(flatStyle, "icon-declutter-mode");
    const icon = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Icon_DOT_js.default({src, anchorOrigin:context, anchorXUnits, anchorYUnits, color, crossOrigin, offset, offsetOrigin, height, width, size, declutterMode:flatStyle});
    return function(context) {
      evaluateOpacity && icon.setOpacity(evaluateOpacity(context));
      evaluateDisplacement && icon.setDisplacement(evaluateDisplacement(context));
      evaluateRotation && icon.setRotation(evaluateRotation(context));
      evaluateRotateWithView && icon.setRotateWithView(evaluateRotateWithView(context));
      evaluateScale && icon.setScale(evaluateScale(context));
      evaluateAnchor && icon.setAnchor(evaluateAnchor(context));
      return icon;
    };
  }
  function buildShape(flatStyle, context) {
    const points = requireNumber(flatStyle["shape-points"], "shape-points"), radius = requireNumber(flatStyle["shape-radius"], "shape-radius"), evaluateFill = buildFill(flatStyle, "shape-", context), evaluateStroke = buildStroke(flatStyle, "shape-", context), evaluateScale = sizeLikeEvaluator(flatStyle, "shape-scale", context), evaluateDisplacement = coordinateEvaluator(flatStyle, "shape-displacement", context), evaluateRotation = numberEvaluator(flatStyle, "shape-rotation", context), evaluateRotateWithView = 
    booleanEvaluator(flatStyle, "shape-rotate-with-view", context);
    context = optionalNumber(flatStyle, "shape-radius2");
    const angle = optionalNumber(flatStyle, "shape-angle");
    flatStyle = optionalDeclutterMode(flatStyle, "shape-declutter-mode");
    const shape = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_RegularShape_DOT_js.default({points, radius, radius2:context, angle, declutterMode:flatStyle});
    return function(context) {
      evaluateFill && shape.setFill(evaluateFill(context));
      evaluateStroke && shape.setStroke(evaluateStroke(context));
      evaluateDisplacement && shape.setDisplacement(evaluateDisplacement(context));
      evaluateRotation && shape.setRotation(evaluateRotation(context));
      evaluateRotateWithView && shape.setRotateWithView(evaluateRotateWithView(context));
      evaluateScale && shape.setScale(evaluateScale(context));
      return shape;
    };
  }
  function buildCircle(flatStyle, context) {
    const evaluateFill = buildFill(flatStyle, "circle-", context), evaluateStroke = buildStroke(flatStyle, "circle-", context), evaluateRadius = numberEvaluator(flatStyle, "circle-radius", context), evaluateScale = sizeLikeEvaluator(flatStyle, "circle-scale", context), evaluateDisplacement = coordinateEvaluator(flatStyle, "circle-displacement", context), evaluateRotation = numberEvaluator(flatStyle, "circle-rotation", context), evaluateRotateWithView = booleanEvaluator(flatStyle, "circle-rotate-with-view", 
    context);
    flatStyle = optionalDeclutterMode(flatStyle, "circle-declutter-mode");
    const circle = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Circle_DOT_js.default({radius:5, declutterMode:flatStyle});
    return function(context) {
      evaluateRadius && circle.setRadius(evaluateRadius(context));
      evaluateFill && circle.setFill(evaluateFill(context));
      evaluateStroke && circle.setStroke(evaluateStroke(context));
      evaluateDisplacement && circle.setDisplacement(evaluateDisplacement(context));
      evaluateRotation && circle.setRotation(evaluateRotation(context));
      evaluateRotateWithView && circle.setRotateWithView(evaluateRotateWithView(context));
      evaluateScale && circle.setScale(evaluateScale(context));
      return circle;
    };
  }
  function numberEvaluator(flatStyle, name, context) {
    if (name in flatStyle) {
      var evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.NumberType, context);
      return function(context) {
        return requireNumber(evaluator(context), name);
      };
    }
  }
  function stringEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.StringType, context);
    return function(context) {
      return requireString(evaluator(context), name);
    };
  }
  function patternEvaluator(flatStyle, prefix, context) {
    const srcEvaluator = stringEvaluator(flatStyle, prefix + "pattern-src", context), offsetEvaluator = sizeEvaluator(flatStyle, prefix + "pattern-offset", context), patternSizeEvaluator = sizeEvaluator(flatStyle, prefix + "pattern-size", context), colorEvaluator = colorLikeEvaluator(flatStyle, prefix + "color", context);
    return function(context) {
      return {src:srcEvaluator(context), offset:offsetEvaluator && offsetEvaluator(context), size:patternSizeEvaluator && patternSizeEvaluator(context), color:colorEvaluator && colorEvaluator(context)};
    };
  }
  function booleanEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.BooleanType, context);
    return function(context) {
      context = evaluator(context);
      if ("boolean" !== typeof context) {
        throw Error(`Expected a boolean for ${name}`);
      }
      return context;
    };
  }
  function colorLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.ColorType, context);
    return function(context) {
      return requireColorLike(evaluator(context), name);
    };
  }
  function numberArrayEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.NumberArrayType, context);
    return function(context) {
      return requireNumberArray(evaluator(context), name);
    };
  }
  function coordinateEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.NumberArrayType, context);
    return function(context) {
      context = requireNumberArray(evaluator(context), name);
      if (2 !== context.length) {
        throw Error(`Expected two numbers for ${name}`);
      }
      return context;
    };
  }
  function sizeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.NumberArrayType, context);
    return function(context) {
      return requireSize(evaluator(context), name);
    };
  }
  function sizeLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js.buildExpression)(flatStyle[name], require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.NumberArrayType | require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js.NumberType, context);
    return function(context) {
      context = evaluator(context);
      context = "number" === typeof context ? context : requireSize(context, name);
      return context;
    };
  }
  function optionalNumber(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      if ("number" !== typeof flatStyle) {
        throw Error(`Expected a number for ${property}`);
      }
      return flatStyle;
    }
  }
  function optionalSize(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      if ("number" === typeof flatStyle) {
        return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_size_DOT_js.toSize)(flatStyle);
      }
      if (!Array.isArray(flatStyle)) {
        throw Error(`Expected a number or size array for ${property}`);
      }
      if (2 !== flatStyle.length || "number" !== typeof flatStyle[0] || "number" !== typeof flatStyle[1]) {
        throw Error(`Expected a number or size array for ${property}`);
      }
      return flatStyle;
    }
  }
  function optionalString(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      if ("string" !== typeof flatStyle) {
        throw Error(`Expected a string for ${property}`);
      }
      return flatStyle;
    }
  }
  function optionalIconOrigin(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      if ("bottom-left" !== flatStyle && "bottom-right" !== flatStyle && "top-left" !== flatStyle && "top-right" !== flatStyle) {
        throw Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);
      }
      return flatStyle;
    }
  }
  function optionalIconAnchorUnits(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      if ("pixels" !== flatStyle && "fraction" !== flatStyle) {
        throw Error(`Expected pixels or fraction for ${property}`);
      }
      return flatStyle;
    }
  }
  function optionalNumberArray(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      return requireNumberArray(flatStyle, property);
    }
  }
  function optionalDeclutterMode(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      if ("string" !== typeof flatStyle) {
        throw Error(`Expected a string for ${property}`);
      }
      if ("declutter" !== flatStyle && "obstacle" !== flatStyle && "none" !== flatStyle) {
        throw Error(`Expected declutter, obstacle, or none for ${property}`);
      }
      return flatStyle;
    }
  }
  function optionalColorLike(flatStyle, property) {
    flatStyle = flatStyle[property];
    if (void 0 !== flatStyle) {
      return requireColorLike(flatStyle, property);
    }
  }
  function requireNumberArray(value, property) {
    if (!Array.isArray(value)) {
      throw Error(`Expected an array for ${property}`);
    }
    const length = value.length;
    for (let i = 0; i < length; ++i) {
      if ("number" !== typeof value[i]) {
        throw Error(`Expected an array of numbers for ${property}`);
      }
    }
    return value;
  }
  function requireString(value, property) {
    if ("string" !== typeof value) {
      throw Error(`Expected a string for ${property}`);
    }
    return value;
  }
  function requireNumber(value, property) {
    if ("number" !== typeof value) {
      throw Error(`Expected a number for ${property}`);
    }
    return value;
  }
  function requireColorLike(value, property) {
    if ("string" === typeof value) {
      return value;
    }
    value = requireNumberArray(value, property);
    const length = value.length;
    if (3 > length || 4 < length) {
      throw Error(`Expected a color with 3 or 4 values for ${property}`);
    }
    return value;
  }
  function requireSize(value, property) {
    value = requireNumberArray(value, property);
    if (2 !== value.length) {
      throw Error(`Expected an array of two numbers for ${property}`);
    }
    return value;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, buildRuleSet:{enumerable:!0, get:function() {
    return buildRuleSet;
  }}, buildStyle:{enumerable:!0, get:function() {
    return buildStyle;
  }}, flatStylesToStyleFunction:{enumerable:!0, get:function() {
    return flatStylesToStyleFunction;
  }}, rulesToStyleFunction:{enumerable:!0, get:function() {
    return rulesToStyleFunction;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_color_DOT_js = require("module$node_modules$ol$color"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_cpu_DOT_js = require("module$node_modules$ol$expr$cpu"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_expr_SLASH_expression_DOT_js = require("module$node_modules$ol$expr$expression"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_obj_DOT_js = require("module$node_modules$ol$obj"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_size_DOT_js = require("module$node_modules$ol$size");
  global = require("module$node_modules$ol$style$Circle");
  module = require("module$node_modules$ol$style$Fill");
  exports = require("module$node_modules$ol$style$Icon");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_RegularShape_DOT_js = require("module$node_modules$ol$style$RegularShape"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js = require("module$node_modules$ol$style$Stroke"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Style_DOT_js = require("module$node_modules$ol$style$Style"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Text_DOT_js = require("module$node_modules$ol$style$Text"), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Icon_DOT_js = 
  require.esmDefault(exports), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Circle_DOT_js = require.esmDefault(global), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_RegularShape_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_RegularShape_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Style_DOT_js = 
  require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Style_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Text_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Text_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_SLASH_Fill_DOT_js = require.esmDefault(module);
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$style.js.map
