shadow$provide.module$node_modules$ol$Collection = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, CollectionEvent:{enumerable:!0, get:function() {
    return CollectionEvent;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$CollectionEventType");
  exports = require("module$node_modules$ol$Object");
  module = require("module$node_modules$ol$events$Event");
  exports = require.esmDefault(exports);
  var default$$require$_DOT__SLASH_CollectionEventType_DOT_js = require.esmDefault(global);
  require = require.esmDefault(module);
  class CollectionEvent extends require.default {
    constructor(type, element, index) {
      super(type);
      this.element = element;
      this.index = index;
    }
  }
  class Collection extends exports.default {
    constructor(array, options) {
      super();
      this.on;
      this.once;
      this.un;
      options = options || {};
      this.unique_ = !!options.unique;
      this.array_ = array ? array : [];
      if (this.unique_) {
        for (let i = 0, ii = this.array_.length; i < ii; ++i) {
          this.assertUnique_(this.array_[i], i);
        }
      }
      this.updateLength_();
    }
    clear() {
      for (; 0 < this.getLength();) {
        this.pop();
      }
    }
    extend(arr) {
      for (let i = 0, ii = arr.length; i < ii; ++i) {
        this.push(arr[i]);
      }
      return this;
    }
    forEach(f) {
      const array = this.array_;
      for (let i = 0, ii = array.length; i < ii; ++i) {
        f(array[i], i, array);
      }
    }
    getArray() {
      return this.array_;
    }
    item(index) {
      return this.array_[index];
    }
    getLength() {
      return this.get("length");
    }
    insertAt(index, elem) {
      if (0 > index || index > this.getLength()) {
        throw Error("Index out of bounds: " + index);
      }
      this.unique_ && this.assertUnique_(elem);
      this.array_.splice(index, 0, elem);
      this.updateLength_();
      this.dispatchEvent(new CollectionEvent(default$$require$_DOT__SLASH_CollectionEventType_DOT_js.default.ADD, elem, index));
    }
    pop() {
      return this.removeAt(this.getLength() - 1);
    }
    push(elem) {
      this.unique_ && this.assertUnique_(elem);
      const n = this.getLength();
      this.insertAt(n, elem);
      return this.getLength();
    }
    remove(elem) {
      const arr = this.array_;
      for (let i = 0, ii = arr.length; i < ii; ++i) {
        if (arr[i] === elem) {
          return this.removeAt(i);
        }
      }
    }
    removeAt(index) {
      if (!(0 > index || index >= this.getLength())) {
        var prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(default$$require$_DOT__SLASH_CollectionEventType_DOT_js.default.REMOVE, prev, index));
        return prev;
      }
    }
    setAt(index, elem) {
      var n = this.getLength();
      if (index >= n) {
        this.insertAt(index, elem);
      } else {
        if (0 > index) {
          throw Error("Index out of bounds: " + index);
        }
        this.unique_ && this.assertUnique_(elem, index);
        n = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(new CollectionEvent(default$$require$_DOT__SLASH_CollectionEventType_DOT_js.default.REMOVE, n, index));
        this.dispatchEvent(new CollectionEvent(default$$require$_DOT__SLASH_CollectionEventType_DOT_js.default.ADD, elem, index));
      }
    }
    updateLength_() {
      this.set("length", this.array_.length);
    }
    assertUnique_(elem, except) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        if (this.array_[i] === elem && i !== except) {
          throw Error("Duplicate item added to a unique collection");
        }
      }
    }
  }
  const $$default = Collection;
};

//# sourceMappingURL=module$node_modules$ol$Collection.js.map
