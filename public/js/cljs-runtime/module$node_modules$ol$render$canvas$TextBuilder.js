shadow$provide.module$node_modules$ol$render$canvas$TextBuilder = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, TEXT_ALIGN:{enumerable:!0, get:function() {
    return TEXT_ALIGN;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js = require("module$node_modules$ol$colorlike"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_linechunk_DOT_js = require("module$node_modules$ol$geom$flat$linechunk"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_straightchunk_DOT_js = require("module$node_modules$ol$geom$flat$straightchunk"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js = 
  require("module$node_modules$ol$util"), require$_DOT__DOT__SLASH_canvas_DOT_js = require("module$node_modules$ol$render$canvas");
  global = require("module$node_modules$ol$render$canvas$Builder");
  module = require("module$node_modules$ol$render$canvas$Instruction");
  var default$$require$_DOT__SLASH_Instruction_DOT_js = require.esmDefault(module);
  require = require.esmDefault(global);
  const TEXT_ALIGN = {left:0, center:0.5, right:1, top:0, middle:0.5, hanging:0.2, alphabetic:0.8, ideographic:0.8, bottom:1};
  class CanvasTextBuilder extends require.default {
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
      this.labels_ = null;
      this.text_ = "";
      this.textOffsetY_ = this.textOffsetX_ = 0;
      this.textKeepUpright_ = this.textRotateWithView_ = void 0;
      this.textRotation_ = 0;
      this.textFillState_ = null;
      this.fillStates = {};
      this.fillStates[require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle] = {fillStyle:require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle};
      this.textStrokeState_ = null;
      this.strokeStates = {};
      this.textState_ = {};
      this.textStates = {};
      this.strokeKey_ = this.fillKey_ = this.textKey_ = "";
      this.declutterImageWithText_ = this.declutterMode_ = void 0;
    }
    finish() {
      const instructions = super.finish();
      instructions.textStates = this.textStates;
      instructions.fillStates = this.fillStates;
      instructions.strokeStates = this.strokeStates;
      return instructions;
    }
    drawText(geometry, feature, index) {
      var fillState = this.textFillState_, strokeState = this.textStrokeState_, textState = this.textState_;
      if ("" !== this.text_ && textState && (fillState || strokeState)) {
        var coordinates = this.coordinates;
        fillState = coordinates.length;
        strokeState = geometry.getType();
        var flatCoordinates = null, stride = geometry.getStride();
        if ("line" !== textState.placement || "LineString" != strokeState && "MultiLineString" != strokeState && "Polygon" != strokeState && "MultiPolygon" != strokeState) {
          var geometryWidths = textState.overflow ? null : [];
          switch(strokeState) {
            case "Point":
            case "MultiPoint":
              flatCoordinates = geometry.getFlatCoordinates();
              break;
            case "LineString":
              flatCoordinates = geometry.getFlatMidpoint();
              break;
            case "Circle":
              flatCoordinates = geometry.getCenter();
              break;
            case "MultiLineString":
              flatCoordinates = geometry.getFlatMidpoints();
              stride = 2;
              break;
            case "Polygon":
              flatCoordinates = geometry.getFlatInteriorPoint();
              textState.overflow || geometryWidths.push(flatCoordinates[2] / this.resolution);
              stride = 3;
              break;
            case "MultiPolygon":
              strokeState = geometry.getFlatInteriorPoints();
              flatCoordinates = [];
              for (let i = 0, ii = strokeState.length; i < ii; i += 3) {
                textState.overflow || geometryWidths.push(strokeState[i + 2] / this.resolution), flatCoordinates.push(strokeState[i], strokeState[i + 1]);
              }
              if (0 === flatCoordinates.length) {
                return;
              }
              stride = 2;
          }
          strokeState = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (strokeState === fillState) {
            return;
          }
          if (geometryWidths && (strokeState - fillState) / 2 !== flatCoordinates.length / stride) {
            let beg = fillState / 2;
            geometryWidths = geometryWidths.filter((w, i) => {
              (w = coordinates[2 * (beg + i)] === flatCoordinates[i * stride] && coordinates[2 * (beg + i) + 1] === flatCoordinates[i * stride + 1]) || --beg;
              return w;
            });
          }
          this.saveTextStates_();
          var backgroundFill = textState.backgroundFill ? this.createFill(this.fillStyleToState(textState.backgroundFill)) : null, backgroundStroke = textState.backgroundStroke ? this.createStroke(this.strokeStyleToState(textState.backgroundStroke)) : null;
          this.beginGeometry(geometry, feature, index);
          geometry = textState.padding;
          if (geometry != require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding && (0 > textState.scale[0] || 0 > textState.scale[1])) {
            geometry = textState.padding[0];
            index = textState.padding[1];
            var p2 = textState.padding[2];
            let p3 = textState.padding[3];
            0 > textState.scale[0] && (index = -index, p3 = -p3);
            0 > textState.scale[1] && (geometry = -geometry, p2 = -p2);
            geometry = [geometry, index, p2, p3];
          }
          const pixelRatio = this.pixelRatio;
          this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE, fillState, strokeState, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, this.declutterMode_, this.declutterImageWithText_, geometry == require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding ? require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding : geometry.map(function(p) {
            return p * pixelRatio;
          }), backgroundFill, backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
          textState = 1 / pixelRatio;
          if (index = backgroundFill ? backgroundFill.slice(0) : null) {
            index[1] = require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle;
          }
          this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE, fillState, strokeState, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [textState, textState], NaN, this.declutterMode_, this.declutterImageWithText_, geometry, index, backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_ ? require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle : this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
        } else {
          if (!(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(this.maxExtent, geometry.getExtent())) {
            return;
          }
          flatCoordinates = geometry.getFlatCoordinates();
          if ("LineString" == strokeState) {
            geometryWidths = [flatCoordinates.length];
          } else if ("MultiLineString" == strokeState) {
            geometryWidths = geometry.getEnds();
          } else if ("Polygon" == strokeState) {
            geometryWidths = geometry.getEnds().slice(0, 1);
          } else if ("MultiPolygon" == strokeState) {
            strokeState = geometry.getEndss();
            geometryWidths = [];
            for (let i = 0, ii = strokeState.length; i < ii; ++i) {
              geometryWidths.push(strokeState[i][0]);
            }
          }
          this.beginGeometry(geometry, feature, index);
          backgroundStroke = (strokeState = textState.repeat) ? void 0 : textState.textAlign;
          index = 0;
          for (let o = 0, oo = geometryWidths.length; o < oo; ++o) {
            geometry = strokeState ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_linechunk_DOT_js.lineChunk)(strokeState * this.resolution, flatCoordinates, index, geometryWidths[o], stride) : [flatCoordinates.slice(index, geometryWidths[o])];
            for (let c = 0, cc = geometry.length; c < cc; ++c) {
              index = geometry[c];
              backgroundFill = 0;
              p2 = index.length;
              void 0 == backgroundStroke && (p2 = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_straightchunk_DOT_js.matchingChunk)(textState.maxAngle, index, 0, index.length, 2), backgroundFill = p2[0], p2 = p2[1]);
              for (; backgroundFill < p2; backgroundFill += stride) {
                coordinates.push(index[backgroundFill], index[backgroundFill + 1]);
              }
              backgroundFill = coordinates.length;
              index = geometryWidths[o];
              this.drawChars_(fillState, backgroundFill);
              fillState = backgroundFill;
            }
          }
        }
        this.endGeometry(feature);
      }
    }
    saveTextStates_() {
      var strokeState = this.textStrokeState_, textState = this.textState_;
      const fillState = this.textFillState_, strokeKey = this.strokeKey_;
      strokeState && (strokeKey in this.strokeStates || (this.strokeStates[strokeKey] = {strokeStyle:strokeState.strokeStyle, lineCap:strokeState.lineCap, lineDashOffset:strokeState.lineDashOffset, lineWidth:strokeState.lineWidth, lineJoin:strokeState.lineJoin, miterLimit:strokeState.miterLimit, lineDash:strokeState.lineDash}));
      strokeState = this.textKey_;
      strokeState in this.textStates || (this.textStates[strokeState] = {font:textState.font, textAlign:textState.textAlign || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextAlign, justify:textState.justify, textBaseline:textState.textBaseline || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextBaseline, scale:textState.scale});
      textState = this.fillKey_;
      fillState && (textState in this.fillStates || (this.fillStates[textState] = {fillStyle:fillState.fillStyle}));
    }
    drawChars_(begin, end) {
      var strokeState = this.textStrokeState_;
      const textState = this.textState_, strokeKey = this.strokeKey_, textKey = this.textKey_, fillKey = this.fillKey_;
      this.saveTextStates_();
      const pixelRatio = this.pixelRatio, baseline = TEXT_ALIGN[textState.textBaseline], offsetY = this.textOffsetY_ * pixelRatio, text = this.text_;
      strokeState = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
      this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeState * pixelRatio, text, textKey, 1, this.declutterMode_, this.textKeepUpright_]);
      this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey ? require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle : fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeState * pixelRatio, text, textKey, 1 / pixelRatio, this.declutterMode_, this.textKeepUpright_]);
    }
    setTextStyle(textStyle, sharedData) {
      var textState;
      let fillState;
      var strokeState;
      if (textStyle) {
        (strokeState = textStyle.getFill()) ? (fillState = this.textFillState_, fillState || (this.textFillState_ = fillState = {}), fillState.fillStyle = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(strokeState.getColor() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFillStyle)) : this.textFillState_ = fillState = null;
        if (textState = textStyle.getStroke()) {
          strokeState = this.textStrokeState_;
          strokeState || (this.textStrokeState_ = strokeState = {});
          var lineDash = textState.getLineDash(), lineDashOffset = textState.getLineDashOffset(), lineWidth = textState.getWidth(), miterLimit = textState.getMiterLimit();
          strokeState.lineCap = textState.getLineCap() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineCap;
          strokeState.lineDash = lineDash ? lineDash.slice() : require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDash;
          strokeState.lineDashOffset = void 0 === lineDashOffset ? require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineDashOffset : lineDashOffset;
          strokeState.lineJoin = textState.getLineJoin() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineJoin;
          strokeState.lineWidth = void 0 === lineWidth ? require$_DOT__DOT__SLASH_canvas_DOT_js.defaultLineWidth : lineWidth;
          strokeState.miterLimit = void 0 === miterLimit ? require$_DOT__DOT__SLASH_canvas_DOT_js.defaultMiterLimit : miterLimit;
          strokeState.strokeStyle = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(textState.getColor() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultStrokeStyle);
        } else {
          this.textStrokeState_ = strokeState = null;
        }
        textState = this.textState_;
        lineDash = textStyle.getFont() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultFont;
        (0,require$_DOT__DOT__SLASH_canvas_DOT_js.registerFont)(lineDash);
        lineDashOffset = textStyle.getScaleArray();
        textState.overflow = textStyle.getOverflow();
        textState.font = lineDash;
        textState.maxAngle = textStyle.getMaxAngle();
        textState.placement = textStyle.getPlacement();
        textState.textAlign = textStyle.getTextAlign();
        textState.repeat = textStyle.getRepeat();
        textState.justify = textStyle.getJustify();
        textState.textBaseline = textStyle.getTextBaseline() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextBaseline;
        textState.backgroundFill = textStyle.getBackgroundFill();
        textState.backgroundStroke = textStyle.getBackgroundStroke();
        textState.padding = textStyle.getPadding() || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding;
        textState.scale = void 0 === lineDashOffset ? [1, 1] : lineDashOffset;
        lineDash = textStyle.getOffsetX();
        lineDashOffset = textStyle.getOffsetY();
        lineWidth = textStyle.getRotateWithView();
        miterLimit = textStyle.getKeepUpright();
        const textRotation = textStyle.getRotation();
        this.text_ = textStyle.getText() || "";
        this.textOffsetX_ = void 0 === lineDash ? 0 : lineDash;
        this.textOffsetY_ = void 0 === lineDashOffset ? 0 : lineDashOffset;
        this.textRotateWithView_ = void 0 === lineWidth ? !1 : lineWidth;
        this.textKeepUpright_ = void 0 === miterLimit ? !0 : miterLimit;
        this.textRotation_ = void 0 === textRotation ? 0 : textRotation;
        this.strokeKey_ = strokeState ? ("string" == typeof strokeState.strokeStyle ? strokeState.strokeStyle : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
        this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
        this.fillKey_ = fillState && fillState.fillStyle ? "string" == typeof fillState.fillStyle ? fillState.fillStyle : "|" + (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(fillState.fillStyle) : "";
      } else {
        this.text_ = "";
      }
      this.declutterMode_ = textStyle.getDeclutterMode();
      this.declutterImageWithText_ = sharedData;
    }
  }
  const $$default = CanvasTextBuilder;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$TextBuilder.js.map
