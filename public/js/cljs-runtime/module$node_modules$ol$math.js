shadow$provide.module$node_modules$ol$math = function(global, require, module, exports) {
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    if (0 !== dx || 0 !== dy) {
      const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
      1 < t ? (x1 = x2, y1 = y2) : 0 < t && (x1 += dx * t, y1 += dy * t);
    }
    return squaredDistance(x, y, x1, y1);
  }
  function squaredDistance(x1, y1, x2, y2) {
    x1 = x2 - x1;
    y1 = y2 - y1;
    return x1 * x1 + y1 * y1;
  }
  function solveLinearSystem(mat) {
    const n = mat.length;
    for (var i = 0; i < n; i++) {
      var maxRow = i, maxEl = Math.abs(mat[i][i]);
      for (var r = i + 1; r < n; r++) {
        const absValue = Math.abs(mat[r][i]);
        absValue > maxEl && (maxEl = absValue, maxRow = r);
      }
      if (0 === maxEl) {
        return null;
      }
      maxEl = mat[maxRow];
      mat[maxRow] = mat[i];
      mat[i] = maxEl;
      for (maxRow = i + 1; maxRow < n; maxRow++) {
        for (maxEl = -mat[maxRow][i] / mat[i][i], r = i; r < n + 1; r++) {
          mat[maxRow][r] = i == r ? 0 : mat[maxRow][r] + maxEl * mat[i][r];
        }
      }
    }
    i = Array(n);
    for (maxRow = n - 1; 0 <= maxRow; maxRow--) {
      for (i[maxRow] = mat[maxRow][n] / mat[maxRow][maxRow], maxEl = maxRow - 1; 0 <= maxEl; maxEl--) {
        mat[maxEl][n] -= mat[maxEl][maxRow] * i[maxRow];
      }
    }
    return i;
  }
  function toDegrees(angleInRadians) {
    return 180 * angleInRadians / Math.PI;
  }
  function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
  }
  function modulo(a, b) {
    a %= b;
    return 0 > a * b ? a + b : a;
  }
  function lerp(a, b, x) {
    return a + x * (b - a);
  }
  function toFixed(n, decimals) {
    decimals = Math.pow(10, decimals);
    return Math.round(n * decimals) / decimals;
  }
  function round(n, decimals) {
    return Math.round(toFixed(n, decimals));
  }
  function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
  }
  function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
  }
  function wrap(n, min, max) {
    if (n >= min && n < max) {
      return n;
    }
    max -= min;
    return ((n - min) % max + max) % max + min;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ceil:{enumerable:!0, get:function() {
    return ceil;
  }}, clamp:{enumerable:!0, get:function() {
    return clamp;
  }}, floor:{enumerable:!0, get:function() {
    return floor;
  }}, lerp:{enumerable:!0, get:function() {
    return lerp;
  }}, modulo:{enumerable:!0, get:function() {
    return modulo;
  }}, round:{enumerable:!0, get:function() {
    return round;
  }}, solveLinearSystem:{enumerable:!0, get:function() {
    return solveLinearSystem;
  }}, squaredDistance:{enumerable:!0, get:function() {
    return squaredDistance;
  }}, squaredSegmentDistance:{enumerable:!0, get:function() {
    return squaredSegmentDistance;
  }}, toDegrees:{enumerable:!0, get:function() {
    return toDegrees;
  }}, toFixed:{enumerable:!0, get:function() {
    return toFixed;
  }}, toRadians:{enumerable:!0, get:function() {
    return toRadians;
  }}, wrap:{enumerable:!0, get:function() {
    return wrap;
  }}});
};

//# sourceMappingURL=module$node_modules$ol$math.js.map
