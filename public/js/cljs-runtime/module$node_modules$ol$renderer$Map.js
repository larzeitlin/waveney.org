shadow$provide.module$node_modules$ol$renderer$Map = function(global, require, module, exports) {
  function expireIconCache(map, frameState) {
    require$_DOT__DOT__SLASH_style_SLASH_IconImageCache_DOT_js.shared.expire();
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$Disposable");
  var require$_DOT__DOT__SLASH_coordinate_DOT_js = require("module$node_modules$ol$coordinate"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_functions_DOT_js = require("module$node_modules$ol$functions"), require$_DOT__DOT__SLASH_layer_SLASH_Layer_DOT_js = require("module$node_modules$ol$layer$Layer"), require$_DOT__DOT__SLASH_style_SLASH_IconImageCache_DOT_js = require("module$node_modules$ol$style$IconImageCache"), require$_DOT__DOT__SLASH_transform_DOT_js = 
  require("module$node_modules$ol$transform"), require$_DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util");
  require = require.esmDefault(global);
  class MapRenderer extends require.default {
    constructor(map) {
      super();
      this.map_ = map;
    }
    dispatchRenderEvent(type, frameState) {
      (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    calculateMatrices2D(frameState) {
      const viewState = frameState.viewState, coordinateToPixelTransform = frameState.coordinateToPixelTransform, pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
      (0,require$_DOT__DOT__SLASH_transform_DOT_js.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
      (0,require$_DOT__DOT__SLASH_transform_DOT_js.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
    }
    forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
      function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
        return callback.call(thisArg, feature, managed ? layer : null, geometry);
      }
      let result;
      const viewState = frameState.viewState;
      var projection = viewState.projection;
      const translatedCoordinate = (0,require$_DOT__DOT__SLASH_coordinate_DOT_js.wrapX)(coordinate.slice(), projection), offsets = [[0, 0]];
      projection.canWrapX() && checkWrapped && (checkWrapped = projection.getExtent(), checkWrapped = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(checkWrapped), offsets.push([-checkWrapped, 0], [checkWrapped, 0]));
      checkWrapped = frameState.layerStatesArray;
      projection = checkWrapped.length;
      const matches = [], tmpCoord = [];
      for (let i = 0; i < offsets.length; i++) {
        for (let j = projection - 1; 0 <= j; --j) {
          var layerState = checkWrapped[j], layer = layerState.layer;
          if (layer.hasRenderer() && (0,require$_DOT__DOT__SLASH_layer_SLASH_Layer_DOT_js.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
            const layerRenderer = layer.getRenderer();
            layer = layer.getSource();
            layerRenderer && layer && (layer = layer.getWrapX() ? translatedCoordinate : coordinate, layerState = forEachFeatureAtCoordinate.bind(null, layerState.managed), tmpCoord[0] = layer[0] + offsets[i][0], tmpCoord[1] = layer[1] + offsets[i][1], result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, layerState, matches));
            if (result) {
              return result;
            }
          }
        }
      }
      if (0 !== matches.length) {
        var order = 1 / matches.length;
        matches.forEach((m, i) => m.distanceSq += i * order);
        matches.sort((a, b) => a.distanceSq - b.distanceSq);
        matches.some(m => result = m.callback(m.feature, m.layer, m.geometry));
        return result;
      }
    }
    hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
      return void 0 !== this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, require$_DOT__DOT__SLASH_functions_DOT_js.TRUE, this, layerFilter, thisArg);
    }
    getMap() {
      return this.map_;
    }
    renderFrame(frameState) {
      (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    scheduleExpireIconCache(frameState) {
      require$_DOT__DOT__SLASH_style_SLASH_IconImageCache_DOT_js.shared.canExpireCache() && frameState.postRenderFunctions.push(expireIconCache);
    }
  }
  const $$default = MapRenderer;
};

//# sourceMappingURL=module$node_modules$ol$renderer$Map.js.map
