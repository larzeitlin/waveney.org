shadow$provide.module$node_modules$ol$tilegrid$TileGrid = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_TileRange_DOT_js = require("module$node_modules$ol$TileRange"), require$_DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH_asserts_DOT_js = require("module$node_modules$ol$asserts"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_geom_SLASH_flat_SLASH_intersectsextent_DOT_js = require("module$node_modules$ol$geom$flat$intersectsextent"), require$_DOT__DOT__SLASH_math_DOT_js = 
  require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH_size_DOT_js = require("module$node_modules$ol$size"), require$_DOT__DOT__SLASH_tilecoord_DOT_js = require("module$node_modules$ol$tilecoord"), require$_DOT__SLASH_common_DOT_js = require("module$node_modules$ol$tilegrid$common"), default$$require$_DOT__DOT__SLASH_TileRange_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_TileRange_DOT_js);
  const tmpTileCoord = [0, 0, 0];
  class TileGrid {
    constructor(options) {
      this.minZoom = void 0 !== options.minZoom ? options.minZoom : 0;
      this.resolutions_ = options.resolutions;
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)((0,require$_DOT__DOT__SLASH_array_DOT_js.isSorted)(this.resolutions_, (a, b) => b - a, !0), "`resolutions` must be sorted in descending order");
      let zoomFactor;
      if (!options.origins) {
        for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
          if (!zoomFactor) {
            zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
          } else {
            if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
              zoomFactor = void 0;
              break;
            }
          }
        }
      }
      this.zoomFactor_ = zoomFactor;
      this.maxZoom = this.resolutions_.length - 1;
      this.origin_ = void 0 !== options.origin ? options.origin : null;
      this.origins_ = null;
      void 0 !== options.origins && (this.origins_ = options.origins, (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(this.origins_.length == this.resolutions_.length, "Number of `origins` and `resolutions` must be equal"));
      const extent = options.extent;
      void 0 === extent || this.origin_ || this.origins_ || (this.origin_ = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getTopLeft)(extent));
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, "Either `origin` or `origins` must be configured, never both");
      this.tileSizes_ = null;
      void 0 !== options.tileSizes && (this.tileSizes_ = options.tileSizes, (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(this.tileSizes_.length == this.resolutions_.length, "Number of `tileSizes` and `resolutions` must be equal"));
      this.tileSize_ = void 0 !== options.tileSize ? options.tileSize : this.tileSizes_ ? null : require$_DOT__SLASH_common_DOT_js.DEFAULT_TILE_SIZE;
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, "Either `tileSize` or `tileSizes` must be configured, never both");
      this.extent_ = void 0 !== extent ? extent : null;
      this.fullTileRanges_ = null;
      this.tmpSize_ = [0, 0];
      this.tmpExtent_ = [0, 0, 0, 0];
      void 0 !== options.sizes ? this.fullTileRanges_ = options.sizes.map((size, z) => {
        size = new default$$require$_DOT__DOT__SLASH_TileRange_DOT_js.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
        extent && (z = this.getTileRangeForExtentAndZ(extent, z), size.minX = Math.max(z.minX, size.minX), size.maxX = Math.min(z.maxX, size.maxX), size.minY = Math.max(z.minY, size.minY), size.maxY = Math.min(z.maxY, size.maxY));
        return size;
      }) : extent && this.calculateTileRanges_(extent);
    }
    forEachTileCoord(extent, zoom, callback) {
      extent = this.getTileRangeForExtentAndZ(extent, zoom);
      for (let i = extent.minX, ii = extent.maxX; i <= ii; ++i) {
        for (let j = extent.minY, jj = extent.maxY; j <= jj; ++j) {
          callback([zoom, i, j]);
        }
      }
    }
    forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
      let x, y, tileCoordExtent = null, z = tileCoord[0] - 1;
      2 === this.zoomFactor_ ? (x = tileCoord[1], y = tileCoord[2]) : tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
      for (; z >= this.minZoom;) {
        void 0 !== x && void 0 !== y ? (x = Math.floor(x / 2), y = Math.floor(y / 2), tileCoord = (0,require$_DOT__DOT__SLASH_TileRange_DOT_js.createOrUpdate)(x, x, y, y, tempTileRange)) : tileCoord = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
        if (callback(z, tileCoord)) {
          return !0;
        }
        --z;
      }
      return !1;
    }
    getExtent() {
      return this.extent_;
    }
    getMaxZoom() {
      return this.maxZoom;
    }
    getMinZoom() {
      return this.minZoom;
    }
    getOrigin(z) {
      return this.origin_ ? this.origin_ : this.origins_[z];
    }
    getResolution(z) {
      return this.resolutions_[z];
    }
    getResolutions() {
      return this.resolutions_;
    }
    getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
      if (tileCoord[0] < this.maxZoom) {
        if (2 === this.zoomFactor_) {
          return tempExtent = 2 * tileCoord[1], tileCoord = 2 * tileCoord[2], (0,require$_DOT__DOT__SLASH_TileRange_DOT_js.createOrUpdate)(tempExtent, tempExtent + 1, tileCoord, tileCoord + 1, tempTileRange);
        }
        tempExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tempExtent, tileCoord[0] + 1, tempTileRange);
      }
      return null;
    }
    getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
      if (z > this.maxZoom || z < this.minZoom) {
        return null;
      }
      var tileCoordZ = tileCoord[0];
      const tileCoordX = tileCoord[1], tileCoordY = tileCoord[2];
      if (z === tileCoordZ) {
        return (0,require$_DOT__DOT__SLASH_TileRange_DOT_js.createOrUpdate)(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
      }
      if (this.zoomFactor_) {
        tileCoord = Math.pow(this.zoomFactor_, z - tileCoordZ);
        const minX = Math.floor(tileCoordX * tileCoord), minY = Math.floor(tileCoordY * tileCoord);
        return z < tileCoordZ ? (0,require$_DOT__DOT__SLASH_TileRange_DOT_js.createOrUpdate)(minX, minX, minY, minY, tempTileRange) : (0,require$_DOT__DOT__SLASH_TileRange_DOT_js.createOrUpdate)(minX, Math.floor(tileCoord * (tileCoordX + 1)) - 1, minY, Math.floor(tileCoord * (tileCoordY + 1)) - 1, tempTileRange);
      }
      tileCoordZ = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(tileCoordZ, z, tempTileRange);
    }
    getTileRangeForExtentAndZ(extent, z, tempTileRange) {
      this.getTileCoordForXYAndZ_(extent[0], extent[3], z, !1, tmpTileCoord);
      const minX = tmpTileCoord[1], minY = tmpTileCoord[2];
      this.getTileCoordForXYAndZ_(extent[2], extent[1], z, !0, tmpTileCoord);
      return (0,require$_DOT__DOT__SLASH_TileRange_DOT_js.createOrUpdate)(minX, tmpTileCoord[1], minY, tmpTileCoord[2], tempTileRange);
    }
    getTileCoordCenter(tileCoord) {
      const origin = this.getOrigin(tileCoord[0]), resolution = this.getResolution(tileCoord[0]), tileSize = (0,require$_DOT__DOT__SLASH_size_DOT_js.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
      return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
    }
    getTileCoordExtent(tileCoord, tempExtent) {
      const origin = this.getOrigin(tileCoord[0]), resolution = this.getResolution(tileCoord[0]), tileSize = (0,require$_DOT__DOT__SLASH_size_DOT_js.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_), minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
      tileCoord = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
      return (0,require$_DOT__DOT__SLASH_extent_DOT_js.createOrUpdate)(minX, tileCoord, minX + tileSize[0] * resolution, tileCoord + tileSize[1] * resolution, tempExtent);
    }
    getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
      return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, !1, opt_tileCoord);
    }
    getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
      const z = this.getZForResolution(resolution), scale = resolution / this.getResolution(z), origin = this.getOrigin(z), tileSize = (0,require$_DOT__DOT__SLASH_size_DOT_js.toSize)(this.getTileSize(z), this.tmpSize_);
      x = scale * (x - origin[0]) / resolution / tileSize[0];
      y = scale * (origin[1] - y) / resolution / tileSize[1];
      reverseIntersectionPolicy ? (x = (0,require$_DOT__DOT__SLASH_math_DOT_js.ceil)(x, 5) - 1, y = (0,require$_DOT__DOT__SLASH_math_DOT_js.ceil)(y, 5) - 1) : (x = (0,require$_DOT__DOT__SLASH_math_DOT_js.floor)(x, 5), y = (0,require$_DOT__DOT__SLASH_math_DOT_js.floor)(y, 5));
      return (0,require$_DOT__DOT__SLASH_tilecoord_DOT_js.createOrUpdate)(z, x, y, opt_tileCoord);
    }
    getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
      const origin = this.getOrigin(z), resolution = this.getResolution(z), tileSize = (0,require$_DOT__DOT__SLASH_size_DOT_js.toSize)(this.getTileSize(z), this.tmpSize_);
      x = (x - origin[0]) / resolution / tileSize[0];
      y = (origin[1] - y) / resolution / tileSize[1];
      reverseIntersectionPolicy ? (x = (0,require$_DOT__DOT__SLASH_math_DOT_js.ceil)(x, 5) - 1, y = (0,require$_DOT__DOT__SLASH_math_DOT_js.ceil)(y, 5) - 1) : (x = (0,require$_DOT__DOT__SLASH_math_DOT_js.floor)(x, 5), y = (0,require$_DOT__DOT__SLASH_math_DOT_js.floor)(y, 5));
      return (0,require$_DOT__DOT__SLASH_tilecoord_DOT_js.createOrUpdate)(z, x, y, opt_tileCoord);
    }
    getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
      return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, !1, opt_tileCoord);
    }
    getTileCoordResolution(tileCoord) {
      return this.resolutions_[tileCoord[0]];
    }
    getTileSize(z) {
      return this.tileSize_ ? this.tileSize_ : this.tileSizes_[z];
    }
    getFullTileRange(z) {
      return this.fullTileRanges_ ? this.fullTileRanges_[z] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    getZForResolution(resolution, opt_direction) {
      resolution = (0,require$_DOT__DOT__SLASH_array_DOT_js.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
      return (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(resolution, this.minZoom, this.maxZoom);
    }
    tileCoordIntersectsViewport(tileCoord, viewport) {
      return (0,require$_DOT__DOT__SLASH_geom_SLASH_flat_SLASH_intersectsextent_DOT_js.intersectsLinearRing)(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
    }
    calculateTileRanges_(extent) {
      const length = this.resolutions_.length, fullTileRanges = Array(length);
      for (let z = this.minZoom; z < length; ++z) {
        fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
      }
      this.fullTileRanges_ = fullTileRanges;
    }
  }
  const $$default = TileGrid;
};

//# sourceMappingURL=module$node_modules$ol$tilegrid$TileGrid.js.map
