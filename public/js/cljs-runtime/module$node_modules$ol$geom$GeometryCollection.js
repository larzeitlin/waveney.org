shadow$provide.module$node_modules$ol$geom$GeometryCollection = function(global, require, module, exports) {
  function cloneGeometries(geometries) {
    return geometries.map(geometry => geometry.clone());
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$events$EventType");
  var require$_DOT__DOT__SLASH_events_DOT_js = require("module$node_modules$ol$events"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent");
  module = require("module$node_modules$ol$geom$Geometry");
  var default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js = require.esmDefault(global);
  require = require.esmDefault(module);
  class GeometryCollection extends require.default {
    constructor(geometries) {
      super();
      this.geometries_ = geometries;
      this.changeEventsKeys_ = [];
      this.listenGeometriesChange_();
    }
    unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(require$_DOT__DOT__SLASH_events_DOT_js.unlistenByKey);
      this.changeEventsKeys_.length = 0;
    }
    listenGeometriesChange_() {
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        this.changeEventsKeys_.push((0,require$_DOT__DOT__SLASH_events_DOT_js.listen)(geometries[i], default$$require$_DOT__DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE, this.changed, this));
      }
    }
    clone() {
      const geometryCollection = new GeometryCollection(cloneGeometries(this.geometries_));
      geometryCollection.applyProperties(this);
      return geometryCollection;
    }
    closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0,require$_DOT__DOT__SLASH_extent_DOT_js.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
      }
      return minSquaredDistance;
    }
    containsXY(x, y) {
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        if (geometries[i].containsXY(x, y)) {
          return !0;
        }
      }
      return !1;
    }
    computeExtent(extent) {
      (0,require$_DOT__DOT__SLASH_extent_DOT_js.createOrUpdateEmpty)(extent);
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        (0,require$_DOT__DOT__SLASH_extent_DOT_js.extend)(extent, geometries[i].getExtent());
      }
      return extent;
    }
    getGeometries() {
      return cloneGeometries(this.geometries_);
    }
    getGeometriesArray() {
      return this.geometries_;
    }
    getGeometriesArrayRecursive() {
      let geometriesArray = [];
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].getType() === this.getType() ? geometriesArray = geometriesArray.concat(geometries[i].getGeometriesArrayRecursive()) : geometriesArray.push(geometries[i]);
      }
      return geometriesArray;
    }
    getSimplifiedGeometry(squaredTolerance) {
      this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision());
      if (0 > squaredTolerance || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
        return this;
      }
      const simplifiedGeometries = [], geometries = this.geometries_;
      let simplified = !1;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        const geometry = geometries[i], simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
        simplifiedGeometries.push(simplifiedGeometry);
        simplifiedGeometry !== geometry && (simplified = !0);
      }
      if (simplified) {
        return new GeometryCollection(simplifiedGeometries);
      }
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
    getType() {
      return "GeometryCollection";
    }
    intersectsExtent(extent) {
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        if (geometries[i].intersectsExtent(extent)) {
          return !0;
        }
      }
      return !1;
    }
    isEmpty() {
      return 0 === this.geometries_.length;
    }
    rotate(angle, anchor) {
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].rotate(angle, anchor);
      }
      this.changed();
    }
    scale(sx, sy, anchor) {
      anchor || (anchor = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getCenter)(this.getExtent()));
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].scale(sx, sy, anchor);
      }
      this.changed();
    }
    setGeometries(geometries) {
      this.setGeometriesArray(cloneGeometries(geometries));
    }
    setGeometriesArray(geometries) {
      this.unlistenGeometriesChange_();
      this.geometries_ = geometries;
      this.listenGeometriesChange_();
      this.changed();
    }
    applyTransform(transformFn) {
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].applyTransform(transformFn);
      }
      this.changed();
    }
    translate(deltaX, deltaY) {
      const geometries = this.geometries_;
      for (let i = 0, ii = geometries.length; i < ii; ++i) {
        geometries[i].translate(deltaX, deltaY);
      }
      this.changed();
    }
    disposeInternal() {
      this.unlistenGeometriesChange_();
      super.disposeInternal();
    }
  }
  const $$default = GeometryCollection;
};

//# sourceMappingURL=module$node_modules$ol$geom$GeometryCollection.js.map
