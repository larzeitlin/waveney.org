shadow$provide.module$node_modules$ol$Image = function(global, require, module, exports) {
  function listenImage(image, loadHandler, errorHandler) {
    let listening = !0, decoding = !1, loaded = !1;
    const listenerKeys = [(0,require$_DOT__SLASH_events_DOT_js.listenOnce)(image, default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js.default.LOAD, function() {
      loaded = !0;
      decoding || loadHandler();
    })];
    image.src && require$_DOT__SLASH_has_DOT_js.IMAGE_DECODE ? (decoding = !0, image.decode().then(function() {
      listening && loadHandler();
    }).catch(function(error) {
      listening && (loaded ? loadHandler() : errorHandler());
    })) : listenerKeys.push((0,require$_DOT__SLASH_events_DOT_js.listenOnce)(image, default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js.default.ERROR, errorHandler));
    return function() {
      listening = !1;
      listenerKeys.forEach(require$_DOT__SLASH_events_DOT_js.unlistenByKey);
    };
  }
  function load(image, src) {
    return new Promise((resolve, reject) => {
      function handleLoad() {
        unlisten();
        resolve(image);
      }
      function handleError() {
        unlisten();
        reject(Error("Image load error"));
      }
      function unlisten() {
        image.removeEventListener("load", handleLoad);
        image.removeEventListener("error", handleError);
      }
      image.addEventListener("load", handleLoad);
      image.addEventListener("error", handleError);
      src && (image.src = src);
    });
  }
  function decodeFallback(image, src) {
    src && (image.src = src);
    return image.src && require$_DOT__SLASH_has_DOT_js.IMAGE_DECODE ? new Promise((resolve, reject) => image.decode().then(() => resolve(image)).catch(e => image.complete && image.width ? resolve(image) : reject(e))) : load(image);
  }
  function decode(image, src) {
    src && (image.src = src);
    return image.src && require$_DOT__SLASH_has_DOT_js.IMAGE_DECODE && require$_DOT__SLASH_has_DOT_js.CREATE_IMAGE_BITMAP ? image.decode().then(() => createImageBitmap(image)).catch(e => {
      if (image.complete && image.width) {
        return image;
      }
      throw e;
    }) : decodeFallback(image);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, decode:{enumerable:!0, get:function() {
    return decode;
  }}, decodeFallback:{enumerable:!0, get:function() {
    return decodeFallback;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}, listenImage:{enumerable:!0, get:function() {
    return listenImage;
  }}, load:{enumerable:!0, get:function() {
    return load;
  }}});
  global = require("module$node_modules$ol$ImageState");
  module = require("module$node_modules$ol$events$EventType");
  exports = require("module$node_modules$ol$events$Target");
  var require$_DOT__SLASH_events_DOT_js = require("module$node_modules$ol$events"), require$_DOT__SLASH_functions_DOT_js = require("module$node_modules$ol$functions"), require$_DOT__SLASH_has_DOT_js = require("module$node_modules$ol$has");
  exports = require.esmDefault(exports);
  var default$$require$_DOT__SLASH_ImageState_DOT_js = require.esmDefault(global), default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js = require.esmDefault(module);
  class ImageWrapper extends exports.default {
    constructor(extent, resolution, pixelRatio, stateOrLoader) {
      super();
      this.extent = extent;
      this.pixelRatio_ = pixelRatio;
      this.resolution = resolution;
      this.state = "function" === typeof stateOrLoader ? default$$require$_DOT__SLASH_ImageState_DOT_js.default.IDLE : stateOrLoader;
      this.image_ = null;
      this.loader = "function" === typeof stateOrLoader ? stateOrLoader : null;
    }
    changed() {
      this.dispatchEvent(default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE);
    }
    getExtent() {
      return this.extent;
    }
    getImage() {
      return this.image_;
    }
    getPixelRatio() {
      return this.pixelRatio_;
    }
    getResolution() {
      return this.resolution;
    }
    getState() {
      return this.state;
    }
    load() {
      if (this.state == default$$require$_DOT__SLASH_ImageState_DOT_js.default.IDLE && this.loader) {
        this.state = default$$require$_DOT__SLASH_ImageState_DOT_js.default.LOADING;
        this.changed();
        const resolution = this.getResolution(), requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
        (0,require$_DOT__SLASH_functions_DOT_js.toPromise)(() => this.loader(this.getExtent(), requestResolution, this.getPixelRatio())).then(image => {
          "image" in image && (this.image_ = image.image);
          "extent" in image && (this.extent = image.extent);
          "resolution" in image && (this.resolution = image.resolution);
          "pixelRatio" in image && (this.pixelRatio_ = image.pixelRatio);
          if (image instanceof HTMLImageElement || require$_DOT__SLASH_has_DOT_js.CREATE_IMAGE_BITMAP && image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {
            this.image_ = image;
          }
          this.state = default$$require$_DOT__SLASH_ImageState_DOT_js.default.LOADED;
        }).catch(error => {
          this.state = default$$require$_DOT__SLASH_ImageState_DOT_js.default.ERROR;
          console.error(error);
        }).finally(() => this.changed());
      }
    }
    setImage(image) {
      this.image_ = image;
    }
    setResolution(resolution) {
      this.resolution = resolution;
    }
  }
  const $$default = ImageWrapper;
};

//# sourceMappingURL=module$node_modules$ol$Image.js.map
