shadow$provide.module$node_modules$ol$geom$Geometry = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$Object");
  var require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_functions_DOT_js = require("module$node_modules$ol$functions"), require$_DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj"), require$_DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform"), require$_DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util"), require$_DOT__SLASH_flat_SLASH_transform_DOT_js = require("module$node_modules$ol$geom$flat$transform");
  require = require.esmDefault(global);
  const tmpTransform = (0,require$_DOT__DOT__SLASH_transform_DOT_js.create)(), tmpPoint = [NaN, NaN];
  class Geometry extends require.default {
    constructor() {
      super();
      this.extent_ = (0,require$_DOT__DOT__SLASH_extent_DOT_js.createEmpty)();
      this.extentRevision_ = -1;
      this.simplifiedGeometryRevision = this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifyTransformedInternal = (0,require$_DOT__DOT__SLASH_functions_DOT_js.memoizeOne)((revision, squaredTolerance, transform) => {
        if (!transform) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        revision = this.clone();
        revision.applyTransform(transform);
        return revision.getSimplifiedGeometry(squaredTolerance);
      });
    }
    simplifyTransformed(squaredTolerance, transform) {
      return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
    }
    clone() {
      return (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    closestPointXY(x, y, closestPoint, minSquaredDistance) {
      return (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    containsXY(x, y) {
      return 0 === this.closestPointXY(x, y, tmpPoint, Number.MIN_VALUE);
    }
    getClosestPoint(point, closestPoint) {
      closestPoint = closestPoint ? closestPoint : [NaN, NaN];
      this.closestPointXY(point[0], point[1], closestPoint, Infinity);
      return closestPoint;
    }
    intersectsCoordinate(coordinate) {
      return this.containsXY(coordinate[0], coordinate[1]);
    }
    computeExtent(extent) {
      return (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    getExtent(extent) {
      if (this.extentRevision_ != this.getRevision()) {
        const extent = this.computeExtent(this.extent_);
        (isNaN(extent[0]) || isNaN(extent[1])) && (0,require$_DOT__DOT__SLASH_extent_DOT_js.createOrUpdateEmpty)(extent);
        this.extentRevision_ = this.getRevision();
      }
      return (0,require$_DOT__DOT__SLASH_extent_DOT_js.returnOrUpdate)(this.extent_, extent);
    }
    rotate(angle, anchor) {
      (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    scale(sx, sy, anchor) {
      (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    simplify(tolerance) {
      return this.getSimplifiedGeometry(tolerance * tolerance);
    }
    getSimplifiedGeometry(squaredTolerance) {
      return (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    getType() {
      return (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    applyTransform(transformFn) {
      (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    intersectsExtent(extent) {
      return (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    translate(deltaX, deltaY) {
      (0,require$_DOT__DOT__SLASH_util_DOT_js.abstract)();
    }
    transform(source, destination) {
      const sourceProj = (0,require$_DOT__DOT__SLASH_proj_DOT_js.get)(source);
      source = "tile-pixels" == sourceProj.getUnits() ? function(inCoordinates, outCoordinates, stride) {
        var pixelExtent = sourceProj.getExtent();
        const projectedExtent = sourceProj.getWorldExtent();
        pixelExtent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getHeight)(projectedExtent) / (0,require$_DOT__DOT__SLASH_extent_DOT_js.getHeight)(pixelExtent);
        (0,require$_DOT__DOT__SLASH_transform_DOT_js.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], pixelExtent, -pixelExtent, 0, 0, 0);
        inCoordinates = (0,require$_DOT__SLASH_flat_SLASH_transform_DOT_js.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
        return (outCoordinates = (0,require$_DOT__DOT__SLASH_proj_DOT_js.getTransform)(sourceProj, destination)) ? outCoordinates(inCoordinates, inCoordinates, stride) : inCoordinates;
      } : (0,require$_DOT__DOT__SLASH_proj_DOT_js.getTransform)(sourceProj, destination);
      this.applyTransform(source);
      return this;
    }
  }
  const $$default = Geometry;
};

//# sourceMappingURL=module$node_modules$ol$geom$Geometry.js.map
