shadow$provide.module$node_modules$ol$renderer$canvas$VectorLayer = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  exports = require("module$node_modules$ol$ViewHint");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_coordinate_DOT_js = require("module$node_modules$ol$coordinate"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj");
  global = require("module$node_modules$ol$render$EventType");
  module = require("module$node_modules$ol$render$canvas$BuilderGroup");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js = require("module$node_modules$ol$render$canvas$ExecutorGroup"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js = require("module$node_modules$ol$render$canvas$hitdetect"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util"), require$_DOT__DOT__SLASH_vector_DOT_js = require("module$node_modules$ol$renderer$vector"), require$_DOT__SLASH_Layer_DOT_js = 
  require("module$node_modules$ol$renderer$canvas$Layer"), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ViewHint_DOT_js = require.esmDefault(exports);
  exports = require.esmDefault(require$_DOT__SLASH_Layer_DOT_js);
  var default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_BuilderGroup_DOT_js = require.esmDefault(module), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js = require.esmDefault(global);
  class CanvasVectorLayerRenderer extends exports.default {
    constructor(vectorLayer) {
      super(vectorLayer);
      this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
      this.animatingOrInteracting_;
      this.hitDetectionImageData_ = null;
      this.clipped_ = !1;
      this.renderedFeatures_ = null;
      this.renderedRevision_ = -1;
      this.renderedResolution_ = NaN;
      this.renderedExtent_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createEmpty)();
      this.wrappedRenderedExtent_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createEmpty)();
      this.renderedRotation_;
      this.renderedProjection_ = this.renderedCenter_ = null;
      this.renderedPixelRatio_ = 1;
      this.renderedRenderOrder_ = null;
      this.renderedFrameDeclutter_;
      this.replayGroup_ = null;
      this.clipping = this.replayGroupChanged = !0;
      this.targetContext_ = null;
      this.opacity_ = 1;
    }
    renderWorlds(executorGroup, frameState, declutterable) {
      var extent = frameState.extent, viewState = frameState.viewState;
      const center = viewState.center, resolution = viewState.resolution;
      var projection = viewState.projection;
      viewState = viewState.rotation;
      var projectionExtent = projection.getExtent(), vectorSource = this.getLayer().getSource();
      const declutter = this.getLayer().getDeclutter(), pixelRatio = frameState.pixelRatio;
      var viewHints = frameState.viewHints;
      viewHints = !(viewHints[default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ViewHint_DOT_js.default.ANIMATING] || viewHints[default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ViewHint_DOT_js.default.INTERACTING]);
      const context = this.context, width = Math.round((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getWidth)(extent) / resolution * pixelRatio), height = Math.round((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getHeight)(extent) / resolution * pixelRatio), multiWorld = vectorSource.getWrapX() && projection.canWrapX();
      projection = multiWorld ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getWidth)(projectionExtent) : null;
      vectorSource = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / projection) + 1 : 1;
      extent = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / projection) : 0;
      do {
        projectionExtent = this.getRenderTransform(center, resolution, 0, pixelRatio, width, height, extent * projection), frameState.declutter && (projectionExtent = projectionExtent.slice(0)), executorGroup.execute(context, [context.canvas.width, context.canvas.height], projectionExtent, viewState, viewHints, void 0 === declutterable ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js.ALL : declutterable ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js.DECLUTTER : 
        require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js.NON_DECLUTTER, declutterable ? declutter && frameState.declutter[declutter] : void 0);
      } while (++extent < vectorSource);
    }
    setDrawContext_() {
      1 !== this.opacity_ && (this.targetContext_ = this.context, this.context = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(this.context.canvas.width, this.context.canvas.height, require$_DOT__SLASH_Layer_DOT_js.canvasPool));
    }
    resetDrawContext_() {
      if (1 !== this.opacity_) {
        const alpha = this.targetContext_.globalAlpha;
        this.targetContext_.globalAlpha = this.opacity_;
        this.targetContext_.drawImage(this.context.canvas, 0, 0);
        this.targetContext_.globalAlpha = alpha;
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.releaseCanvas)(this.context);
        require$_DOT__SLASH_Layer_DOT_js.canvasPool.push(this.context.canvas);
        this.context = this.targetContext_;
        this.targetContext_ = null;
      }
    }
    renderDeclutter(frameState) {
      this.replayGroup_ && this.getLayer().getDeclutter() && this.renderWorlds(this.replayGroup_, frameState, !0);
    }
    renderDeferredInternal(frameState) {
      this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
    }
    renderFrame(frameState, target) {
      var layerState = frameState.layerStatesArray[frameState.layerIndex];
      this.opacity_ = layerState.opacity;
      const viewState = frameState.viewState;
      this.prepareContainer(frameState, target);
      target = this.context;
      const replayGroup = this.replayGroup_;
      let render = replayGroup && !replayGroup.isEmpty();
      if (!render && !this.getLayer().hasListener(default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.PRERENDER) && !this.getLayer().hasListener(default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.POSTRENDER)) {
        return null;
      }
      this.setDrawContext_();
      this.preRender(target, frameState);
      const projection = viewState.projection;
      this.clipped_ = !1;
      render && layerState.extent && this.clipping && (layerState = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.fromUserExtent)(layerState.extent, projection), (this.clipped_ = (render = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(layerState, frameState.extent)) && !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsExtent)(layerState, frameState.extent)) && this.clipUnrotated(target, frameState, layerState));
      render && this.renderWorlds(replayGroup, frameState, this.getLayer().getDeclutter() ? !1 : void 0);
      !frameState.declutter && this.clipped_ && target.restore();
      this.postRender(target, frameState);
      this.renderedRotation_ !== viewState.rotation && (this.renderedRotation_ = viewState.rotation, this.hitDetectionImageData_ = null);
      frameState.declutter || this.resetDrawContext_();
      return this.container;
    }
    getFeatures(pixel) {
      return new Promise(resolve => {
        if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const size = this.frameState.size.slice();
          var center = this.renderedCenter_;
          const resolution = this.renderedResolution_, rotation = this.renderedRotation_, projection = this.renderedProjection_, extent = this.wrappedRenderedExtent_, layer = this.getLayer(), transforms = [], width = size[0] * require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.HIT_DETECT_RESOLUTION, height = size[1] * require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.HIT_DETECT_RESOLUTION;
          transforms.push(this.getRenderTransform(center, resolution, rotation, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.HIT_DETECT_RESOLUTION, width, height, 0).slice());
          var source = layer.getSource();
          const projectionExtent = projection.getExtent();
          if (source.getWrapX() && projection.canWrapX() && !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsExtent)(projectionExtent, extent)) {
            source = extent[0];
            const worldWidth = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getWidth)(projectionExtent);
            let world = 0, offsetX;
            for (; source < projectionExtent[0];) {
              --world, offsetX = worldWidth * world, transforms.push(this.getRenderTransform(center, resolution, rotation, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.HIT_DETECT_RESOLUTION, width, height, offsetX).slice()), source += worldWidth;
            }
            world = 0;
            for (source = extent[2]; source > projectionExtent[2];) {
              ++world, offsetX = worldWidth * world, transforms.push(this.getRenderTransform(center, resolution, rotation, require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.HIT_DETECT_RESOLUTION, width, height, offsetX).slice()), source -= worldWidth;
            }
          }
          center = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getUserProjection)();
          this.hitDetectionImageData_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation, (0,require$_DOT__DOT__SLASH_vector_DOT_js.getSquaredTolerance)(resolution, this.renderedPixelRatio_), center ? projection : null);
        }
        resolve((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_hitdetect_DOT_js.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
      });
    }
    forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      if (this.replayGroup_) {
        var resolution = frameState.viewState.resolution, rotation = frameState.viewState.rotation, layer = this.getLayer(), features = {}, declutter = this.getLayer().getDeclutter();
        return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, function(feature, geometry, distanceSq) {
          const key = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_util_DOT_js.getUid)(feature), match = features[key];
          if (!match) {
            if (0 === distanceSq) {
              return features[key] = !0, callback(feature, layer, geometry);
            }
            matches.push(features[key] = {feature, layer, geometry, distanceSq, callback});
          } else if (!0 !== match && distanceSq < match.distanceSq) {
            if (0 === distanceSq) {
              return features[key] = !0, matches.splice(matches.lastIndexOf(match), 1), callback(feature, layer, geometry);
            }
            match.geometry = geometry;
            match.distanceSq = distanceSq;
          }
        }, declutter ? frameState.declutter?.[declutter]?.all().map(item => item.value) : null);
      }
    }
    handleFontsChanged() {
      const layer = this.getLayer();
      layer.getVisible() && this.replayGroup_ && layer.changed();
    }
    handleStyleImageChange_(event) {
      this.renderIfReadyAndVisible();
    }
    prepareFrame(frameState) {
      const vectorLayer = this.getLayer();
      var vectorSource = vectorLayer.getSource();
      if (!vectorSource) {
        return !1;
      }
      var animating = frameState.viewHints[default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ViewHint_DOT_js.default.ANIMATING], interacting = frameState.viewHints[default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_ViewHint_DOT_js.default.INTERACTING], updateWhileAnimating = vectorLayer.getUpdateWhileAnimating(), updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
      if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
        return this.animatingOrInteracting_ = !0;
      }
      this.animatingOrInteracting_ = !1;
      var frameStateExtent = frameState.extent, viewState = frameState.viewState;
      animating = viewState.projection;
      const resolution = viewState.resolution;
      interacting = frameState.pixelRatio;
      updateWhileAnimating = vectorLayer.getRevision();
      var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
      updateWhileInteracting = vectorLayer.getRenderOrder();
      void 0 === updateWhileInteracting && (updateWhileInteracting = require$_DOT__DOT__SLASH_vector_DOT_js.defaultOrder);
      viewState = viewState.center.slice();
      frameStateExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
      vectorLayerRenderBuffer = frameStateExtent.slice();
      var loadExtents = [frameStateExtent.slice()], projectionExtent = animating.getExtent();
      if (vectorSource.getWrapX() && animating.canWrapX() && !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsExtent)(projectionExtent, frameState.extent)) {
        var worldWidth = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getWidth)(projectionExtent), gutter = Math.max((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getWidth)(frameStateExtent) / 2, worldWidth);
        frameStateExtent[0] = projectionExtent[0] - gutter;
        frameStateExtent[2] = projectionExtent[2] + gutter;
        (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_coordinate_DOT_js.wrapX)(viewState, animating);
        gutter = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.wrapX)(loadExtents[0], animating);
        gutter[0] < projectionExtent[0] && gutter[2] < projectionExtent[2] ? loadExtents.push([gutter[0] + worldWidth, gutter[1], gutter[2] + worldWidth, gutter[3]]) : gutter[0] > projectionExtent[0] && gutter[2] > projectionExtent[2] && loadExtents.push([gutter[0] - worldWidth, gutter[1], gutter[2] - worldWidth, gutter[3]]);
      }
      if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == updateWhileAnimating && this.renderedRenderOrder_ == updateWhileInteracting && this.renderedFrameDeclutter_ === !!frameState.declutter && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsExtent)(this.wrappedRenderedExtent_, frameStateExtent)) {
        return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.equals)(this.renderedExtent_, vectorLayerRenderBuffer) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = vectorLayerRenderBuffer), this.renderedCenter_ = viewState, this.replayGroupChanged = !1, !0;
      }
      this.replayGroup_ = null;
      const replayGroup = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_BuilderGroup_DOT_js.default((0,require$_DOT__DOT__SLASH_vector_DOT_js.getTolerance)(resolution, interacting), frameStateExtent, resolution, interacting);
      projectionExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getUserProjection)();
      let userTransform;
      if (projectionExtent) {
        for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
          worldWidth = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.toUserExtent)(loadExtents[i], animating), vectorSource.loadFeatures(worldWidth, (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.toUserResolution)(resolution, animating), projectionExtent);
        }
        userTransform = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getTransformFromProjections)(projectionExtent, animating);
      } else {
        for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
          vectorSource.loadFeatures(loadExtents[i], resolution, animating);
        }
      }
      const squaredTolerance = (0,require$_DOT__DOT__SLASH_vector_DOT_js.getSquaredTolerance)(resolution, interacting);
      let ready = !0;
      loadExtents = (feature, index) => {
        let styles;
        const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
        styleFunction && (styles = styleFunction(feature, resolution));
        styles && (feature = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, this.getLayer().getDeclutter(), index), ready = ready && !feature);
      };
      projectionExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.toUserExtent)(frameStateExtent, animating);
      projectionExtent = vectorSource.getFeaturesInExtent(projectionExtent);
      updateWhileInteracting && projectionExtent.sort(updateWhileInteracting);
      for (let i = 0, ii = projectionExtent.length; i < ii; ++i) {
        loadExtents(projectionExtent[i], i);
      }
      this.renderedFeatures_ = projectionExtent;
      this.ready = ready;
      loadExtents = replayGroup.finish();
      vectorSource = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ExecutorGroup_DOT_js.default(frameStateExtent, resolution, interacting, vectorSource.getOverlaps(), loadExtents, vectorLayer.getRenderBuffer(), !!frameState.declutter);
      this.renderedResolution_ = resolution;
      this.renderedRevision_ = updateWhileAnimating;
      this.renderedRenderOrder_ = updateWhileInteracting;
      this.renderedFrameDeclutter_ = !!frameState.declutter;
      this.renderedExtent_ = vectorLayerRenderBuffer;
      this.wrappedRenderedExtent_ = frameStateExtent;
      this.renderedCenter_ = viewState;
      this.renderedProjection_ = animating;
      this.renderedPixelRatio_ = interacting;
      this.replayGroup_ = vectorSource;
      this.hitDetectionImageData_ = null;
      return this.replayGroupChanged = !0;
    }
    renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutter, index) {
      if (!styles) {
        return !1;
      }
      let loading = !1;
      if (Array.isArray(styles)) {
        for (let i = 0, ii = styles.length; i < ii; ++i) {
          loading = (0,require$_DOT__DOT__SLASH_vector_DOT_js.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutter, index) || loading;
        }
      } else {
        loading = (0,require$_DOT__DOT__SLASH_vector_DOT_js.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutter, index);
      }
      return loading;
    }
  }
  const $$default = CanvasVectorLayerRenderer;
};

//# sourceMappingURL=module$node_modules$ol$renderer$canvas$VectorLayer.js.map
