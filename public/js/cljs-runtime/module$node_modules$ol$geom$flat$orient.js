shadow$provide.module$node_modules$ol$geom$flat$orient = function(global, require, module, exports) {
  function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    let edge = 0, x1 = flatCoordinates[end - stride], y1 = flatCoordinates[end - stride + 1];
    for (; offset < end; offset += stride) {
      const x2 = flatCoordinates[offset], y2 = flatCoordinates[offset + 1];
      edge += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    return 0 === edge ? void 0 : 0 < edge;
  }
  function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
    right = void 0 !== right ? right : !1;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      offset = linearRingIsClockwise(flatCoordinates, offset, end, stride);
      if (0 === i) {
        if (right && offset || !right && !offset) {
          return !1;
        }
      } else {
        if (right && !offset || !right && offset) {
          return !1;
        }
      }
      offset = end;
    }
    return !0;
  }
  function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i];
      if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
        return !1;
      }
      ends.length && (offset = ends[ends.length - 1]);
    }
    return !0;
  }
  function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
    right = void 0 !== right ? right : !1;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i], isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
      (0 === i ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise) && (0,require$_DOT__SLASH_reverse_DOT_js.coordinates)(flatCoordinates, offset, end, stride);
      offset = end;
    }
    return offset;
  }
  function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
    }
    return offset;
  }
  function inflateEnds(flatCoordinates, ends) {
    const endss = [];
    let offset = 0, prevEndIndex = 0, startOrientation;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i], orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
      void 0 === startOrientation && (startOrientation = orientation);
      if (orientation === startOrientation) {
        endss.push(ends.slice(prevEndIndex, i + 1));
      } else {
        if (0 === endss.length) {
          continue;
        }
        endss[endss.length - 1].push(ends[prevEndIndex]);
      }
      prevEndIndex = i + 1;
      offset = end;
    }
    return endss;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, inflateEnds:{enumerable:!0, get:function() {
    return inflateEnds;
  }}, linearRingIsClockwise:{enumerable:!0, get:function() {
    return linearRingIsClockwise;
  }}, linearRingsAreOriented:{enumerable:!0, get:function() {
    return linearRingsAreOriented;
  }}, linearRingssAreOriented:{enumerable:!0, get:function() {
    return linearRingssAreOriented;
  }}, orientLinearRings:{enumerable:!0, get:function() {
    return orientLinearRings;
  }}, orientLinearRingsArray:{enumerable:!0, get:function() {
    return orientLinearRingsArray;
  }}});
  var require$_DOT__SLASH_reverse_DOT_js = require("module$node_modules$ol$geom$flat$reverse");
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$orient.js.map
