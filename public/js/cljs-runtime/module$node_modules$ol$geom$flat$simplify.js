shadow$provide.module$node_modules$ol$geom$flat$simplify = function(global, require, module, exports) {
  function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
    simplifiedFlatCoordinates = void 0 !== simplifiedFlatCoordinates ? simplifiedFlatCoordinates : [];
    highQuality || (end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0), flatCoordinates = simplifiedFlatCoordinates, offset = 0, stride = 2);
    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return simplifiedFlatCoordinates;
  }
  function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    const n = (end - offset) / stride;
    if (3 > n) {
      for (; offset < end; offset += stride) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset], simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
      }
      return simplifiedOffset;
    }
    const markers = Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    end = [offset, end - stride];
    let index = 0;
    for (; 0 < end.length;) {
      const last = end.pop(), first = end.pop();
      let maxSquaredDistance = 0;
      const x1 = flatCoordinates[first], y1 = flatCoordinates[first + 1], x2 = flatCoordinates[last], y2 = flatCoordinates[last + 1];
      for (let i = first + stride; i < last; i += stride) {
        const squaredDistance = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredSegmentDistance)(flatCoordinates[i], flatCoordinates[i + 1], x1, y1, x2, y2);
        squaredDistance > maxSquaredDistance && (index = i, maxSquaredDistance = squaredDistance);
      }
      maxSquaredDistance > squaredTolerance && (markers[(index - offset) / stride] = 1, first + stride < index && end.push(first, index), index + stride < last && end.push(index, last));
    }
    for (squaredTolerance = 0; squaredTolerance < n; ++squaredTolerance) {
      markers[squaredTolerance] && (simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + squaredTolerance * stride], simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + squaredTolerance * stride + 1]);
    }
    return simplifiedOffset;
  }
  function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
      simplifiedEnds.push(simplifiedOffset);
      offset = end;
    }
    return simplifiedOffset;
  }
  function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i], simplifiedEnds = [];
      simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
      simplifiedEndss.push(simplifiedEnds);
      offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
  }
  function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (end <= offset + stride) {
      for (; offset < end; offset += stride) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset], simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
      }
      return simplifiedOffset;
    }
    let x1 = flatCoordinates[offset], y1 = flatCoordinates[offset + 1];
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    let x2 = x1, y2 = y1;
    for (offset += stride; offset < end; offset += stride) {
      x2 = flatCoordinates[offset], y2 = flatCoordinates[offset + 1], (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredDistance)(x1, y1, x2, y2) > squaredTolerance && (simplifiedFlatCoordinates[simplifiedOffset++] = x2, simplifiedFlatCoordinates[simplifiedOffset++] = y2, x1 = x2, y1 = y2);
    }
    if (x2 != x1 || y2 != y1) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2, simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    }
    return simplifiedOffset;
  }
  function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
  }
  function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (offset == end) {
      return simplifiedOffset;
    }
    let x1 = snap(flatCoordinates[offset], tolerance), y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    let x2, y2;
    do {
      if (x2 = snap(flatCoordinates[offset], tolerance), y2 = snap(flatCoordinates[offset + 1], tolerance), offset += stride, offset == end) {
        return simplifiedFlatCoordinates[simplifiedOffset++] = x2, simplifiedFlatCoordinates[simplifiedOffset++] = y2, simplifiedOffset;
      }
    } while (x2 == x1 && y2 == y1);
    for (; offset < end;) {
      const x3 = snap(flatCoordinates[offset], tolerance), y3 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride;
      if (x3 == x2 && y3 == y2) {
        continue;
      }
      const dx1 = x2 - x1, dy1 = y2 - y1, dx2 = x3 - x1, dy2 = y3 - y1;
      dx1 * dy2 == dy1 * dx2 && (0 > dx1 && dx2 < dx1 || dx1 == dx2 || 0 < dx1 && dx2 > dx1) && (0 > dy1 && dy2 < dy1 || dy1 == dy2 || 0 < dy1 && dy2 > dy1) || (simplifiedFlatCoordinates[simplifiedOffset++] = x2, simplifiedFlatCoordinates[simplifiedOffset++] = y2, x1 = x2, y1 = y2);
      x2 = x3;
      y2 = y3;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
  }
  function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
      simplifiedEnds.push(simplifiedOffset);
      offset = end;
    }
    return simplifiedOffset;
  }
  function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i], simplifiedEnds = [];
      simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
      simplifiedEndss.push(simplifiedEnds);
      offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, douglasPeucker:{enumerable:!0, get:function() {
    return douglasPeucker;
  }}, douglasPeuckerArray:{enumerable:!0, get:function() {
    return douglasPeuckerArray;
  }}, douglasPeuckerMultiArray:{enumerable:!0, get:function() {
    return douglasPeuckerMultiArray;
  }}, quantize:{enumerable:!0, get:function() {
    return quantize;
  }}, quantizeArray:{enumerable:!0, get:function() {
    return quantizeArray;
  }}, quantizeMultiArray:{enumerable:!0, get:function() {
    return quantizeMultiArray;
  }}, radialDistance:{enumerable:!0, get:function() {
    return radialDistance;
  }}, simplifyLineString:{enumerable:!0, get:function() {
    return simplifyLineString;
  }}, snap:{enumerable:!0, get:function() {
    return snap;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math");
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$simplify.js.map
