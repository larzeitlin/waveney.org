shadow$provide.module$node_modules$ol$render$canvas$ImageBuilder = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent");
  global = require("module$node_modules$ol$render$canvas$Builder");
  module = require("module$node_modules$ol$render$canvas$Instruction");
  var default$$require$_DOT__SLASH_Instruction_DOT_js = require.esmDefault(module);
  require = require.esmDefault(global);
  class CanvasImageBuilder extends require.default {
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
      this.image_ = this.hitDetectionImage_ = null;
      this.declutterImageWithText_ = this.declutterMode_ = this.width_ = this.scale_ = this.rotation_ = this.rotateWithView_ = this.originY_ = this.originX_ = this.opacity_ = this.height_ = this.anchorY_ = this.anchorX_ = this.imagePixelRatio_ = void 0;
    }
    drawPoint(pointGeometry, feature, index) {
      if (this.image_ && (!this.maxExtent || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(this.maxExtent, pointGeometry.getFlatCoordinates()))) {
        this.beginGeometry(pointGeometry, feature, index);
        index = pointGeometry.getFlatCoordinates();
        var stride = pointGeometry.getStride();
        pointGeometry = this.coordinates.length;
        index = this.appendFlatPointCoordinates(index, stride);
        this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE, pointGeometry, index, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], 
        Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]);
        this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE, pointGeometry, index, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]);
        this.endGeometry(feature);
      }
    }
    drawMultiPoint(multiPointGeometry, feature, index) {
      if (this.image_) {
        this.beginGeometry(multiPointGeometry, feature, index);
        var flatCoordinates = multiPointGeometry.getFlatCoordinates();
        index = [];
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += multiPointGeometry.getStride()) {
          this.maxExtent && !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(this.maxExtent, flatCoordinates.slice(i, i + 2)) || index.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }
        multiPointGeometry = this.coordinates.length;
        index = this.appendFlatPointCoordinates(index, 2);
        this.instructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE, multiPointGeometry, index, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], 
        Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]);
        this.hitDetectionInstructions.push([default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE, multiPointGeometry, index, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]);
        this.endGeometry(feature);
      }
    }
    finish() {
      this.reverseHitDetectionInstructions();
      this.anchorY_ = this.anchorX_ = void 0;
      this.image_ = this.hitDetectionImage_ = null;
      this.width_ = this.rotation_ = this.rotateWithView_ = this.originY_ = this.originX_ = this.opacity_ = this.scale_ = this.height_ = this.imagePixelRatio_ = void 0;
      return super.finish();
    }
    setImageStyle(imageStyle, sharedData) {
      const anchor = imageStyle.getAnchor(), size = imageStyle.getSize(), origin = imageStyle.getOrigin();
      this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
      this.anchorX_ = anchor[0];
      this.anchorY_ = anchor[1];
      this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
      this.image_ = imageStyle.getImage(this.pixelRatio);
      this.height_ = size[1];
      this.opacity_ = imageStyle.getOpacity();
      this.originX_ = origin[0];
      this.originY_ = origin[1];
      this.rotateWithView_ = imageStyle.getRotateWithView();
      this.rotation_ = imageStyle.getRotation();
      this.scale_ = imageStyle.getScaleArray();
      this.width_ = size[0];
      this.declutterMode_ = imageStyle.getDeclutterMode();
      this.declutterImageWithText_ = sharedData;
    }
  }
  const $$default = CanvasImageBuilder;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$ImageBuilder.js.map
