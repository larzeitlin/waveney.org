shadow$provide.module$node_modules$ol$TileRange = function(global, require, module, exports) {
  function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
    return void 0 !== tileRange ? (tileRange.minX = minX, tileRange.maxX = maxX, tileRange.minY = minY, tileRange.maxY = maxY, tileRange) : new TileRange(minX, maxX, minY, maxY);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, createOrUpdate:{enumerable:!0, get:function() {
    return createOrUpdate;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  class TileRange {
    constructor(minX, maxX, minY, maxY) {
      this.minX = minX;
      this.maxX = maxX;
      this.minY = minY;
      this.maxY = maxY;
    }
    contains(tileCoord) {
      return this.containsXY(tileCoord[1], tileCoord[2]);
    }
    containsTileRange(tileRange) {
      return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    }
    containsXY(x, y) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    }
    equals(tileRange) {
      return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    }
    extend(tileRange) {
      tileRange.minX < this.minX && (this.minX = tileRange.minX);
      tileRange.maxX > this.maxX && (this.maxX = tileRange.maxX);
      tileRange.minY < this.minY && (this.minY = tileRange.minY);
      tileRange.maxY > this.maxY && (this.maxY = tileRange.maxY);
    }
    getHeight() {
      return this.maxY - this.minY + 1;
    }
    getSize() {
      return [this.getWidth(), this.getHeight()];
    }
    getWidth() {
      return this.maxX - this.minX + 1;
    }
    intersects(tileRange) {
      return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    }
  }
  const $$default = TileRange;
};

//# sourceMappingURL=module$node_modules$ol$TileRange.js.map
