shadow$provide.module$node_modules$ol$structs$LRUCache = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  global = require("module$node_modules$ol$Disposable");
  var require$_DOT__DOT__SLASH_asserts_DOT_js = require("module$node_modules$ol$asserts"), default$$require$_DOT__DOT__SLASH_Disposable_DOT_js = require.esmDefault(global);
  class LRUCache {
    constructor(highWaterMark) {
      this.highWaterMark = void 0 !== highWaterMark ? highWaterMark : 2048;
      this.count_ = 0;
      this.entries_ = {};
      this.newest_ = this.oldest_ = null;
    }
    deleteOldest() {
      const entry = this.pop();
      entry instanceof default$$require$_DOT__DOT__SLASH_Disposable_DOT_js.default && entry.dispose();
    }
    canExpireCache() {
      return 0 < this.highWaterMark && this.getCount() > this.highWaterMark;
    }
    expireCache(keep) {
      for (; this.canExpireCache();) {
        this.deleteOldest();
      }
    }
    clear() {
      for (; this.oldest_;) {
        this.deleteOldest();
      }
    }
    containsKey(key) {
      return this.entries_.hasOwnProperty(key);
    }
    forEach(f) {
      let entry = this.oldest_;
      for (; entry;) {
        f(entry.value_, entry.key_, this), entry = entry.newer;
      }
    }
    get(key, options) {
      key = this.entries_[key];
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(void 0 !== key, "Tried to get a value for a key that does not exist in the cache");
      if (key === this.newest_) {
        return key.value_;
      }
      key === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (key.newer.older = key.older, key.older.newer = key.newer);
      key.newer = null;
      key.older = this.newest_;
      this.newest_ = this.newest_.newer = key;
      return key.value_;
    }
    remove(key) {
      const entry = this.entries_[key];
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(void 0 !== entry, "Tried to get a value for a key that does not exist in the cache");
      if (entry === this.newest_) {
        if (this.newest_ = entry.older) {
          this.newest_.newer = null;
        }
      } else if (entry === this.oldest_) {
        if (this.oldest_ = entry.newer) {
          this.oldest_.older = null;
        }
      } else {
        entry.newer.older = entry.older, entry.older.newer = entry.newer;
      }
      delete this.entries_[key];
      --this.count_;
      return entry.value_;
    }
    getCount() {
      return this.count_;
    }
    getKeys() {
      const keys = Array(this.count_);
      let i = 0, entry;
      for (entry = this.newest_; entry; entry = entry.older) {
        keys[i++] = entry.key_;
      }
      return keys;
    }
    getValues() {
      const values = Array(this.count_);
      let i = 0, entry;
      for (entry = this.newest_; entry; entry = entry.older) {
        values[i++] = entry.value_;
      }
      return values;
    }
    peekLast() {
      return this.oldest_.value_;
    }
    peekLastKey() {
      return this.oldest_.key_;
    }
    peekFirstKey() {
      return this.newest_.key_;
    }
    peek(key) {
      return this.entries_[key]?.value_;
    }
    pop() {
      const entry = this.oldest_;
      delete this.entries_[entry.key_];
      entry.newer && (entry.newer.older = null);
      this.oldest_ = entry.newer;
      this.oldest_ || (this.newest_ = null);
      --this.count_;
      return entry.value_;
    }
    replace(key, value) {
      this.get(key);
      this.entries_[key].value_ = value;
    }
    set(key, value) {
      (0,require$_DOT__DOT__SLASH_asserts_DOT_js.assert)(!(key in this.entries_), "Tried to set a value for a key that is used already");
      value = {key_:key, newer:null, older:this.newest_, value_:value};
      this.newest_ ? this.newest_.newer = value : this.oldest_ = value;
      this.newest_ = value;
      this.entries_[key] = value;
      ++this.count_;
    }
    setSize(size) {
      this.highWaterMark = size;
    }
  }
  const $$default = LRUCache;
};

//# sourceMappingURL=module$node_modules$ol$structs$LRUCache.js.map
