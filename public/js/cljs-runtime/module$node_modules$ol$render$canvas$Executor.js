shadow$provide.module$node_modules$ol$render$canvas$Executor = function(global, require, module, exports) {
  function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
  }
  function horizontalTextAlign(text, align) {
    "start" === align ? align = rtlRegEx.test(text) ? "right" : "left" : "end" === align && (align = rtlRegEx.test(text) ? "left" : "right");
    return require$_DOT__SLASH_TextBuilder_DOT_js.TEXT_ALIGN[align];
  }
  function createTextChunks(acc, line, i) {
    0 < i && acc.push("\n", "");
    acc.push(line, "");
    return acc;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_length_DOT_js = require("module$node_modules$ol$geom$flat$length"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_textpath_DOT_js = require("module$node_modules$ol$geom$flat$textpath"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js = 
  require("module$node_modules$ol$geom$flat$transform"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform");
  global = require("module$node_modules$ol$render$canvas$ZIndexContext");
  var require$_DOT__DOT__SLASH_canvas_DOT_js = require("module$node_modules$ol$render$canvas");
  module = require("module$node_modules$ol$render$canvas$Instruction");
  var require$_DOT__SLASH_TextBuilder_DOT_js = require("module$node_modules$ol$render$canvas$TextBuilder"), default$$require$_DOT__SLASH_Instruction_DOT_js = require.esmDefault(module), default$$require$_DOT__DOT__SLASH_canvas_SLASH_ZIndexContext_DOT_js = require.esmDefault(global);
  const tmpExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createEmpty)(), p1 = [], p2 = [], p3 = [], p4 = [], rtlRegEx = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
  class Executor {
    constructor(resolution, pixelRatio, overlaps, instructions, deferredRendering) {
      this.overlaps = overlaps;
      this.pixelRatio = pixelRatio;
      this.resolution = resolution;
      this.alignAndScaleFill_;
      this.instructions = instructions.instructions;
      this.coordinates = instructions.coordinates;
      this.coordinateCache_ = {};
      this.renderedTransform_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)();
      this.hitDetectionInstructions = instructions.hitDetectionInstructions;
      this.pixelCoordinates_ = null;
      this.viewRotation_ = 0;
      this.fillStates = instructions.fillStates || {};
      this.strokeStates = instructions.strokeStates || {};
      this.textStates = instructions.textStates || {};
      this.widths_ = {};
      this.labels_ = {};
      this.zIndexContext_ = deferredRendering ? new default$$require$_DOT__DOT__SLASH_canvas_SLASH_ZIndexContext_DOT_js.default() : null;
    }
    getZIndexContext() {
      return this.zIndexContext_;
    }
    createLabel(text$jscomp$0, textKey, fillKey, strokeKey) {
      const key = text$jscomp$0 + textKey + fillKey + strokeKey;
      if (this.labels_[key]) {
        return this.labels_[key];
      }
      var strokeState = strokeKey ? this.strokeStates[strokeKey] : null, fillState = fillKey ? this.fillStates[fillKey] : null;
      textKey = this.textStates[textKey];
      var pixelRatio = this.pixelRatio, scale = [textKey.scale[0] * pixelRatio, textKey.scale[1] * pixelRatio];
      pixelRatio = textKey.justify ? require$_DOT__SLASH_TextBuilder_DOT_js.TEXT_ALIGN[textKey.justify] : horizontalTextAlign(Array.isArray(text$jscomp$0) ? text$jscomp$0[0] : text$jscomp$0, textKey.textAlign || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextAlign);
      const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
      text$jscomp$0 = Array.isArray(text$jscomp$0) ? text$jscomp$0 : String(text$jscomp$0).split("\n").reduce(createTextChunks, []);
      const {width, height, widths, heights, lineWidths} = (0,require$_DOT__DOT__SLASH_canvas_DOT_js.getTextDimensions)(textKey, text$jscomp$0), renderWidth = width + strokeWidth, contextInstructions = [];
      var w = (renderWidth + 2) * scale[0], h = (height + strokeWidth) * scale[1];
      w = {width:0 > w ? Math.floor(w) : Math.ceil(w), height:0 > h ? Math.floor(h) : Math.ceil(h), contextInstructions};
      1 == scale[0] && 1 == scale[1] || contextInstructions.push("scale", scale);
      strokeKey && (contextInstructions.push("strokeStyle", strokeState.strokeStyle), contextInstructions.push("lineWidth", strokeWidth), contextInstructions.push("lineCap", strokeState.lineCap), contextInstructions.push("lineJoin", strokeState.lineJoin), contextInstructions.push("miterLimit", strokeState.miterLimit), contextInstructions.push("setLineDash", [strokeState.lineDash]), contextInstructions.push("lineDashOffset", strokeState.lineDashOffset));
      fillKey && contextInstructions.push("fillStyle", fillState.fillStyle);
      contextInstructions.push("textBaseline", "middle");
      contextInstructions.push("textAlign", "center");
      strokeState = 0.5 - pixelRatio;
      fillState = pixelRatio * renderWidth + strokeState * strokeWidth;
      scale = [];
      h = [];
      let lineHeight = 0, lineOffset = 0, widthHeightIndex = 0, lineWidthIndex = 0, previousFont;
      for (let i = 0, ii = text$jscomp$0.length; i < ii; i += 2) {
        var text = text$jscomp$0[i];
        if ("\n" === text) {
          lineOffset += lineHeight;
          lineHeight = 0;
          fillState = pixelRatio * renderWidth + strokeState * strokeWidth;
          ++lineWidthIndex;
          continue;
        }
        const font = text$jscomp$0[i + 1] || textKey.font;
        font !== previousFont && (strokeKey && scale.push("font", font), fillKey && h.push("font", font), previousFont = font);
        lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
        text = [text, fillState + strokeState * widths[widthHeightIndex] + pixelRatio * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];
        fillState += widths[widthHeightIndex];
        strokeKey && scale.push("strokeText", text);
        fillKey && h.push("fillText", text);
        ++widthHeightIndex;
      }
      Array.prototype.push.apply(contextInstructions, scale);
      Array.prototype.push.apply(contextInstructions, h);
      return this.labels_[key] = w;
    }
    replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
      context.beginPath();
      context.moveTo.apply(context, p1);
      context.lineTo.apply(context, p2);
      context.lineTo.apply(context, p3);
      context.lineTo.apply(context, p4);
      context.lineTo.apply(context, p1);
      fillInstruction && (this.alignAndScaleFill_ = fillInstruction[2], context.fillStyle = fillInstruction[1], this.fill_(context));
      strokeInstruction && (this.setStrokeStyle_(context, strokeInstruction), context.stroke());
    }
    calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
      anchorX *= scale[0];
      anchorY *= scale[1];
      anchorX = centerX - anchorX;
      anchorY = centerY - anchorY;
      sheetWidth = width + originX > sheetWidth ? sheetWidth - originX : width;
      sheetHeight = height + originY > sheetHeight ? sheetHeight - originY : height;
      height = padding[3] + sheetWidth * scale[0] + padding[1];
      width = padding[0] + sheetHeight * scale[1] + padding[2];
      const boxX = anchorX - padding[3];
      padding = anchorY - padding[0];
      if (fillStroke || 0 !== rotation) {
        p1[0] = boxX, p4[0] = boxX, p1[1] = padding, p2[1] = padding, p2[0] = boxX + height, p3[0] = p2[0], p3[1] = padding + width, p4[1] = p3[1];
      }
      let transform;
      0 !== rotation ? (transform = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.compose)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(transform, p1), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(transform, p2), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(transform, p3), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(transform, 
      p4), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent)) : (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createOrUpdate)(Math.min(boxX, boxX + height), Math.min(padding, padding + width), Math.max(boxX, boxX + height), Math.max(padding, padding + width), tmpExtent);
      snapToPixel && (anchorX = Math.round(anchorX), anchorY = Math.round(anchorY));
      return {drawImageX:anchorX, drawImageY:anchorY, drawImageW:sheetWidth, drawImageH:sheetHeight, originX, originY, declutterBox:{minX:tmpExtent[0], minY:tmpExtent[1], maxX:tmpExtent[2], maxY:tmpExtent[3], value:feature}, canvasTransform:transform, scale};
    }
    replayImageOrLabel_(context, scaledCanvasSize, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
      const box = dimensions.declutterBox, strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
      box.minX - strokePadding <= scaledCanvasSize[0] && 0 <= box.maxX + strokePadding && box.minY - strokePadding <= scaledCanvasSize[1] && 0 <= box.maxY + strokePadding && ((fillInstruction || strokeInstruction) && this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction), (0,require$_DOT__DOT__SLASH_canvas_DOT_js.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, 
      dimensions.drawImageX, dimensions.drawImageY, dimensions.scale));
      return !0;
    }
    fill_(context) {
      const alignAndScale = this.alignAndScaleFill_;
      if (alignAndScale) {
        const origin = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(this.renderedTransform_, [0, 0]), repeatSize = 512 * this.pixelRatio;
        context.save();
        context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
        1 !== alignAndScale && context.scale(alignAndScale, alignAndScale);
        context.rotate(this.viewRotation_);
      }
      context.fill();
      alignAndScale && context.restore();
    }
    setStrokeStyle_(context, instruction) {
      context.strokeStyle = instruction[1];
      context.lineWidth = instruction[2];
      context.lineCap = instruction[3];
      context.lineJoin = instruction[4];
      context.miterLimit = instruction[5];
      context.lineDashOffset = instruction[7];
      context.setLineDash(instruction[6]);
    }
    drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
      const textState = this.textStates[textKey];
      textKey = this.createLabel(text, textKey, fillKey, strokeKey);
      fillKey = this.strokeStates[strokeKey];
      strokeKey = this.pixelRatio;
      text = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextAlign);
      const baseline = require$_DOT__SLASH_TextBuilder_DOT_js.TEXT_ALIGN[textState.textBaseline || require$_DOT__DOT__SLASH_canvas_DOT_js.defaultTextBaseline];
      fillKey = fillKey && fillKey.lineWidth ? fillKey.lineWidth : 0;
      return {label:textKey, anchorX:text * (textKey.width / strokeKey - 2 * textState.scale[0]) + 2 * (0.5 - text) * fillKey, anchorY:baseline * textKey.height / strokeKey + 2 * (0.5 - baseline) * fillKey};
    }
    execute_(context, scaledCanvasSize, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
      const zIndexContext = this.zIndexContext_;
      let pixelCoordinates;
      this.pixelCoordinates_ && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.equals)(transform, this.renderedTransform_) ? pixelCoordinates = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), pixelCoordinates = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.setFromArray)(this.renderedTransform_, 
      transform));
      let i = 0;
      const ii = instructions.length;
      let d, dd, anchorX, anchorY, declutterMode, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey, pendingFill = 0, pendingStroke = 0;
      const coordinateCache = this.coordinateCache_, viewRotation = this.viewRotation_, viewRotationFromTransform = Math.round(1e12 * Math.atan2(-transform[1], transform[0])) / 1e12, state = {context, pixelRatio:this.pixelRatio, resolution:this.resolution, rotation:viewRotation}, batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
      let feature, x, y, currentGeometry;
      for (; i < ii;) {
        const instruction = instructions[i];
        switch(instruction[0]) {
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.BEGIN_GEOMETRY:
            feature = instruction[1];
            currentGeometry = instruction[3];
            feature.getGeometry() ? void 0 === hitExtent || (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(hitExtent, currentGeometry.getExtent()) ? ++i : i = instruction[2] + 1 : i = instruction[2];
            zIndexContext && (zIndexContext.zIndex = instruction[4]);
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.BEGIN_PATH:
            pendingFill > batchSize && (this.fill_(context), pendingFill = 0);
            pendingStroke > batchSize && (context.stroke(), pendingStroke = 0);
            pendingFill || pendingStroke || context.beginPath();
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.CIRCLE:
            d = instruction[1];
            const x1 = pixelCoordinates[d], y1 = pixelCoordinates[d + 1], dx = pixelCoordinates[d + 2] - x1, dy = pixelCoordinates[d + 3] - y1, r = Math.sqrt(dx * dx + dy * dy);
            context.moveTo(x1 + r, y1);
            context.arc(x1, y1, r, 0, 2 * Math.PI, !0);
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.CLOSE_PATH:
            context.closePath();
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.CUSTOM:
            d = instruction[1];
            dd = instruction[2];
            const renderer = instruction[4], fn = instruction[5];
            state.geometry = instruction[3];
            state.feature = feature;
            i in coordinateCache || (coordinateCache[i] = []);
            const coords = coordinateCache[i];
            fn ? fn(pixelCoordinates, d, dd, 2, coords) : (coords[0] = pixelCoordinates[d], coords[1] = pixelCoordinates[d + 1], coords.length = 2);
            zIndexContext && (zIndexContext.zIndex = instruction[6]);
            renderer(coords, state);
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_IMAGE:
            d = instruction[1];
            dd = instruction[2];
            image = instruction[3];
            anchorX = instruction[4];
            anchorY = instruction[5];
            let height = instruction[6];
            const opacity = instruction[7], originX = instruction[8], originY = instruction[9], rotateWithView = instruction[10];
            let rotation = instruction[11];
            const scale = instruction[12];
            let width = instruction[13];
            declutterMode = instruction[14] || "declutter";
            const declutterImageWithText = instruction[15];
            if (!image && 20 <= instruction.length) {
              text = instruction[19];
              textKey = instruction[20];
              strokeKey = instruction[21];
              fillKey = instruction[22];
              const labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
              image = labelWithAnchor.label;
              instruction[3] = image;
              anchorX = (labelWithAnchor.anchorX - instruction[23]) * this.pixelRatio;
              instruction[4] = anchorX;
              anchorY = (labelWithAnchor.anchorY - instruction[24]) * this.pixelRatio;
              instruction[5] = anchorY;
              height = image.height;
              instruction[6] = height;
              width = image.width;
              instruction[13] = width;
            }
            let geometryWidths;
            25 < instruction.length && (geometryWidths = instruction[25]);
            let padding, backgroundFillInstruction, backgroundStrokeInstruction;
            17 < instruction.length ? (padding = instruction[16], backgroundFillInstruction = instruction[17], backgroundStrokeInstruction = instruction[18]) : (padding = require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding, backgroundStrokeInstruction = backgroundFillInstruction = null);
            rotateWithView && viewRotationFromTransform ? rotation += viewRotation : rotateWithView || viewRotationFromTransform || (rotation -= viewRotation);
            let widthIndex = 0;
            for (; d < dd; d += 2) {
              if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                continue;
              }
              const dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, !!backgroundFillInstruction || !!backgroundStrokeInstruction, feature), args = [context, scaledCanvasSize, image, dimensions, opacity, backgroundFillInstruction, backgroundStrokeInstruction];
              if (declutterTree) {
                let imageArgs, imageDeclutterMode, imageDeclutterBox;
                if (declutterImageWithText) {
                  const index = dd - d;
                  if (!declutterImageWithText[index]) {
                    declutterImageWithText[index] = {args, declutterMode};
                    continue;
                  }
                  const imageDeclutter = declutterImageWithText[index];
                  imageArgs = imageDeclutter.args;
                  imageDeclutterMode = imageDeclutter.declutterMode;
                  delete declutterImageWithText[index];
                  imageDeclutterBox = getDeclutterBox(imageArgs);
                }
                let renderImage, renderText;
                !imageArgs || "declutter" === imageDeclutterMode && declutterTree.collides(imageDeclutterBox) || (renderImage = !0);
                "declutter" === declutterMode && declutterTree.collides(dimensions.declutterBox) || (renderText = !0);
                if ("declutter" === imageDeclutterMode && "declutter" === declutterMode) {
                  const render = renderImage && renderText;
                  renderText = renderImage = render;
                }
                renderImage && ("none" !== imageDeclutterMode && declutterTree.insert(imageDeclutterBox), this.replayImageOrLabel_.apply(this, imageArgs));
                renderText && ("none" !== declutterMode && declutterTree.insert(dimensions.declutterBox), this.replayImageOrLabel_.apply(this, args));
              } else {
                this.replayImageOrLabel_.apply(this, args);
              }
            }
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.DRAW_CHARS:
            const begin = instruction[1], end = instruction[2], baseline = instruction[3], overflow = instruction[4];
            fillKey = instruction[5];
            const maxAngle = instruction[6], measurePixelRatio = instruction[7], offsetY = instruction[8];
            strokeKey = instruction[9];
            const strokeWidth = instruction[10];
            text = instruction[11];
            textKey = instruction[12];
            const pixelRatioScale = [instruction[13], instruction[13]];
            declutterMode = instruction[14] || "declutter";
            const textKeepUpright = instruction[15], textState = this.textStates[textKey], font = textState.font, textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];
            let cachedWidths;
            font in this.widths_ ? cachedWidths = this.widths_[font] : (cachedWidths = {}, this.widths_[font] = cachedWidths);
            const pathLength = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_length_DOT_js.lineStringLength)(pixelCoordinates, begin, end, 2), textLength = Math.abs(textScale[0]) * (0,require$_DOT__DOT__SLASH_canvas_DOT_js.measureAndCacheTextWidth)(font, text, cachedWidths);
            if (overflow || textLength <= pathLength) {
              const startM = (pathLength - textLength) * horizontalTextAlign(text, this.textStates[textKey].textAlign), parts = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_textpath_DOT_js.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), require$_DOT__DOT__SLASH_canvas_DOT_js.measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_, textKeepUpright);
              a: {
                if (parts) {
                  const replayImageOrLabelArgs = [];
                  let c, cc, chars, label, part;
                  if (strokeKey) {
                    for (c = 0, cc = parts.length; c < cc; ++c) {
                      part = parts[c];
                      chars = part[4];
                      label = this.createLabel(chars, textKey, "", strokeKey);
                      anchorX = part[2] + (0 > textScale[0] ? -strokeWidth : strokeWidth);
                      anchorY = baseline * label.height + 2 * (0.5 - baseline) * strokeWidth * textScale[1] / textScale[0] - offsetY;
                      const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, !1, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding, !1, feature);
                      if (declutterTree && "declutter" === declutterMode && declutterTree.collides(dimensions.declutterBox)) {
                        break a;
                      }
                      replayImageOrLabelArgs.push([context, scaledCanvasSize, label, dimensions, 1, null, null]);
                    }
                  }
                  if (fillKey) {
                    for (c = 0, cc = parts.length; c < cc; ++c) {
                      part = parts[c];
                      chars = part[4];
                      label = this.createLabel(chars, textKey, fillKey, "");
                      anchorX = part[2];
                      anchorY = baseline * label.height - offsetY;
                      const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, !1, require$_DOT__DOT__SLASH_canvas_DOT_js.defaultPadding, !1, feature);
                      if (declutterTree && "declutter" === declutterMode && declutterTree.collides(dimensions.declutterBox)) {
                        break a;
                      }
                      replayImageOrLabelArgs.push([context, scaledCanvasSize, label, dimensions, 1, null, null]);
                    }
                  }
                  declutterTree && "none" !== declutterMode && declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                  for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {
                    this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);
                  }
                }
              }
            }
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.END_GEOMETRY:
            if (void 0 !== featureCallback) {
              feature = instruction[1];
              const result = featureCallback(feature, currentGeometry, declutterMode);
              if (result) {
                return result;
              }
            }
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.FILL:
            batchSize ? pendingFill++ : this.fill_(context);
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.MOVE_TO_LINE_TO:
            d = instruction[1];
            dd = instruction[2];
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            context.moveTo(x, y);
            prevX = x + 0.5 | 0;
            prevY = y + 0.5 | 0;
            for (d += 2; d < dd; d += 2) {
              if (x = pixelCoordinates[d], y = pixelCoordinates[d + 1], roundX = x + 0.5 | 0, roundY = y + 0.5 | 0, d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                context.lineTo(x, y), prevX = roundX, prevY = roundY;
              }
            }
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_FILL_STYLE:
            this.alignAndScaleFill_ = instruction[2];
            pendingFill && (this.fill_(context), pendingFill = 0, pendingStroke && (context.stroke(), pendingStroke = 0));
            context.fillStyle = instruction[1];
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.SET_STROKE_STYLE:
            pendingStroke && (context.stroke(), pendingStroke = 0);
            this.setStrokeStyle_(context, instruction);
            ++i;
            break;
          case default$$require$_DOT__SLASH_Instruction_DOT_js.default.STROKE:
            batchSize ? pendingStroke++ : context.stroke();
            ++i;
            break;
          default:
            ++i;
        }
      }
      pendingFill && this.fill_(context);
      pendingStroke && context.stroke();
    }
    execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree) {
      this.viewRotation_ = viewRotation;
      this.execute_(context, scaledCanvasSize, transform, this.instructions, snapToPixel, void 0, void 0, declutterTree);
    }
    executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {
      this.viewRotation_ = viewRotation;
      return this.execute_(context, [context.canvas.width, context.canvas.height], transform, this.hitDetectionInstructions, !0, featureCallback, hitExtent);
    }
  }
  const $$default = Executor;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$Executor.js.map
