shadow$provide.module$node_modules$ol$renderer$vector = function(global, require, module, exports) {
  function defaultOrder(feature1, feature2) {
    return parseInt((0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(feature1), 10) - parseInt((0,require$_DOT__DOT__SLASH_util_DOT_js.getUid)(feature2), 10);
  }
  function getSquaredTolerance(resolution, pixelRatio) {
    resolution = 0.5 * resolution / pixelRatio;
    return resolution * resolution;
  }
  function getTolerance(resolution, pixelRatio) {
    return 0.5 * resolution / pixelRatio;
  }
  function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutter, index) {
    const loadingPromises = [];
    var imageStyle = style.getImage();
    if (imageStyle) {
      let loading = !0;
      const imageState = imageStyle.getImageState();
      imageState == default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADED || imageState == default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.ERROR ? loading = !1 : imageState == default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.IDLE && imageStyle.load();
      loading && loadingPromises.push(imageStyle.ready());
    }
    (imageStyle = style.getFill()) && imageStyle.loading() && loadingPromises.push(imageStyle.ready());
    (imageStyle = 0 < loadingPromises.length) && Promise.all(loadingPromises).then(() => listener(null));
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutter, index);
    return imageStyle;
  }
  function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutter, index) {
    const geometry = style.getGeometryFunction()(feature);
    if (geometry) {
      if (squaredTolerance = geometry.simplifyTransformed(squaredTolerance, transform), style.getRenderer()) {
        renderGeometry(replayGroup, squaredTolerance, style, feature, index);
      } else {
        (0,GEOMETRY_RENDERERS[squaredTolerance.getType()])(replayGroup, squaredTolerance, style, feature, index, declutter);
      }
    }
  }
  function renderGeometry(replayGroup, geometry, style, feature, index) {
    if ("GeometryCollection" == geometry.getType()) {
      geometry = geometry.getGeometries();
      for (let i = 0, ii = geometry.length; i < ii; ++i) {
        renderGeometry(replayGroup, geometry[i], style, feature, index);
      }
    } else {
      replayGroup.getBuilder(style.getZIndex(), "Default").drawCustom(geometry, feature, style.getRenderer(), style.getHitDetectionRenderer(), index);
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, defaultOrder:{enumerable:!0, get:function() {
    return defaultOrder;
  }}, getSquaredTolerance:{enumerable:!0, get:function() {
    return getSquaredTolerance;
  }}, getTolerance:{enumerable:!0, get:function() {
    return getTolerance;
  }}, renderFeature:{enumerable:!0, get:function() {
    return renderFeature;
  }}});
  global = require("module$node_modules$ol$ImageState");
  var require$_DOT__DOT__SLASH_util_DOT_js = require("module$node_modules$ol$util"), default$$require$_DOT__DOT__SLASH_ImageState_DOT_js = require.esmDefault(global);
  const GEOMETRY_RENDERERS = {Point:function(builderGroup, geometry, style, feature, index, declutter) {
    const imageStyle = style.getImage(), textStyle = style.getText(), hasText = textStyle && textStyle.getText();
    declutter = declutter && imageStyle && hasText ? {} : void 0;
    if (imageStyle) {
      if (imageStyle.getImageState() != default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADED) {
        return;
      }
      const imageReplay = builderGroup.getBuilder(style.getZIndex(), "Image");
      imageReplay.setImageStyle(imageStyle, declutter);
      imageReplay.drawPoint(geometry, feature, index);
    }
    hasText && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(textStyle, declutter), builderGroup.drawText(geometry, feature, index));
  }, LineString:function(builderGroup, geometry, style, feature, index) {
    var strokeStyle = style.getStroke();
    if (strokeStyle) {
      const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), "LineString");
      lineStringReplay.setFillStrokeStyle(null, strokeStyle);
      lineStringReplay.drawLineString(geometry, feature, index);
    }
    (strokeStyle = style.getText()) && strokeStyle.getText() && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(strokeStyle), builderGroup.drawText(geometry, feature, index));
  }, Polygon:function(builderGroup, geometry, style, feature, index) {
    var fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
      const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
      polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
      polygonReplay.drawPolygon(geometry, feature, index);
    }
    (fillStyle = style.getText()) && fillStyle.getText() && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(fillStyle), builderGroup.drawText(geometry, feature, index));
  }, MultiPoint:function(builderGroup, geometry, style, feature, index, declutter) {
    const imageStyle = style.getImage();
    var hasImage = imageStyle && 0 !== imageStyle.getOpacity();
    const textStyle = style.getText(), hasText = textStyle && textStyle.getText();
    declutter = declutter && hasImage && hasText ? {} : void 0;
    if (hasImage) {
      if (imageStyle.getImageState() != default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADED) {
        return;
      }
      hasImage = builderGroup.getBuilder(style.getZIndex(), "Image");
      hasImage.setImageStyle(imageStyle, declutter);
      hasImage.drawMultiPoint(geometry, feature, index);
    }
    hasText && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(textStyle, declutter), builderGroup.drawText(geometry, feature, index));
  }, MultiLineString:function(builderGroup, geometry, style, feature, index) {
    var strokeStyle = style.getStroke();
    if (strokeStyle) {
      const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), "LineString");
      lineStringReplay.setFillStrokeStyle(null, strokeStyle);
      lineStringReplay.drawMultiLineString(geometry, feature, index);
    }
    (strokeStyle = style.getText()) && strokeStyle.getText() && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(strokeStyle), builderGroup.drawText(geometry, feature, index));
  }, MultiPolygon:function(builderGroup, geometry, style, feature, index) {
    var fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
      const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
      polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
      polygonReplay.drawMultiPolygon(geometry, feature, index);
    }
    (fillStyle = style.getText()) && fillStyle.getText() && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(fillStyle), builderGroup.drawText(geometry, feature, index));
  }, GeometryCollection:function(replayGroup, geometry, style, feature, declutterBuilderGroup, index) {
    geometry = geometry.getGeometriesArray();
    let i, ii;
    i = 0;
    for (ii = geometry.length; i < ii; ++i) {
      (0,GEOMETRY_RENDERERS[geometry[i].getType()])(replayGroup, geometry[i], style, feature, declutterBuilderGroup, index);
    }
  }, Circle:function(builderGroup, geometry, style, feature, index) {
    const fillStyle = style.getFill(), strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
      const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
      circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
      circleReplay.drawCircle(geometry, feature, index);
    }
    (index = style.getText()) && index.getText() && (builderGroup = builderGroup.getBuilder(style.getZIndex(), "Text"), builderGroup.setTextStyle(index), builderGroup.drawText(geometry, feature));
  }};
};

//# sourceMappingURL=module$node_modules$ol$renderer$vector.js.map
