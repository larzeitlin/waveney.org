shadow$provide.module$node_modules$ol$geom$Polygon = function(global, require, module, exports) {
  function circular(center, radius, n, sphereRadius) {
    n = n ? n : 32;
    const flatCoordinates = [];
    for (let i = 0; i < n; ++i) {
      (0,require$_DOT__DOT__SLASH_array_DOT_js.extend)(flatCoordinates, (0,require$_DOT__DOT__SLASH_sphere_DOT_js.offset)(center, radius, 2 * Math.PI * i / n, sphereRadius));
    }
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
  }
  function fromExtent(extent) {
    if ((0,require$_DOT__DOT__SLASH_extent_DOT_js.isEmpty)(extent)) {
      throw Error("Cannot create polygon from empty extent");
    }
    var minX = extent[0];
    const minY = extent[1], maxX = extent[2];
    extent = extent[3];
    minX = [minX, minY, minX, extent, maxX, extent, maxX, minY, minX, minY];
    return new Polygon(minX, "XY", [minX.length]);
  }
  function fromCircle(circle, sides, angle) {
    sides = sides ? sides : 32;
    var stride = circle.getStride();
    const layout = circle.getLayout(), center = circle.getCenter();
    sides = stride * (sides + 1);
    const flatCoordinates = Array(sides);
    for (let i = 0; i < sides; i += stride) {
      flatCoordinates[i] = 0;
      flatCoordinates[i + 1] = 0;
      for (let j = 2; j < stride; j++) {
        flatCoordinates[i + j] = center[j];
      }
    }
    stride = new Polygon(flatCoordinates, layout, [flatCoordinates.length]);
    makeRegular(stride, center, circle.getRadius(), angle);
    return stride;
  }
  function makeRegular(polygon, center, radius, angle$jscomp$0) {
    const flatCoordinates = polygon.getFlatCoordinates(), stride = polygon.getStride(), sides = flatCoordinates.length / stride - 1;
    angle$jscomp$0 = angle$jscomp$0 ? angle$jscomp$0 : 0;
    for (let i = 0; i <= sides; ++i) {
      const offset = i * stride, angle = angle$jscomp$0 + 2 * (0,require$_DOT__DOT__SLASH_math_DOT_js.modulo)(i, sides) * Math.PI / sides;
      flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
      flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
    }
    polygon.changed();
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, circular:{enumerable:!0, get:function() {
    return circular;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}, fromCircle:{enumerable:!0, get:function() {
    return fromCircle;
  }}, fromExtent:{enumerable:!0, get:function() {
    return fromExtent;
  }}, makeRegular:{enumerable:!0, get:function() {
    return makeRegular;
  }}});
  var require$_DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH_sphere_DOT_js = require("module$node_modules$ol$sphere");
  global = require("module$node_modules$ol$geom$LinearRing");
  module = require("module$node_modules$ol$geom$Point");
  exports = require("module$node_modules$ol$geom$SimpleGeometry");
  var require$_DOT__SLASH_flat_SLASH_area_DOT_js = require("module$node_modules$ol$geom$flat$area"), require$_DOT__SLASH_flat_SLASH_closest_DOT_js = require("module$node_modules$ol$geom$flat$closest"), require$_DOT__SLASH_flat_SLASH_contains_DOT_js = require("module$node_modules$ol$geom$flat$contains"), require$_DOT__SLASH_flat_SLASH_deflate_DOT_js = require("module$node_modules$ol$geom$flat$deflate"), require$_DOT__SLASH_flat_SLASH_inflate_DOT_js = require("module$node_modules$ol$geom$flat$inflate"), 
  require$_DOT__SLASH_flat_SLASH_interiorpoint_DOT_js = require("module$node_modules$ol$geom$flat$interiorpoint"), require$_DOT__SLASH_flat_SLASH_intersectsextent_DOT_js = require("module$node_modules$ol$geom$flat$intersectsextent"), require$_DOT__SLASH_flat_SLASH_orient_DOT_js = require("module$node_modules$ol$geom$flat$orient"), require$_DOT__SLASH_flat_SLASH_simplify_DOT_js = require("module$node_modules$ol$geom$flat$simplify");
  exports = require.esmDefault(exports);
  var default$$require$_DOT__SLASH_Point_DOT_js = require.esmDefault(module), default$$require$_DOT__SLASH_LinearRing_DOT_js = require.esmDefault(global);
  class Polygon extends exports.default {
    constructor(coordinates, layout, ends) {
      super();
      this.ends_ = [];
      this.flatInteriorPointRevision_ = -1;
      this.flatInteriorPoint_ = null;
      this.orientedRevision_ = this.maxDeltaRevision_ = this.maxDelta_ = -1;
      this.orientedFlatCoordinates_ = null;
      void 0 !== layout && ends ? (this.setFlatCoordinates(layout, coordinates), this.ends_ = ends) : this.setCoordinates(coordinates, layout);
    }
    appendLinearRing(linearRing) {
      this.flatCoordinates ? (0,require$_DOT__DOT__SLASH_array_DOT_js.extend)(this.flatCoordinates, linearRing.getFlatCoordinates()) : this.flatCoordinates = linearRing.getFlatCoordinates().slice();
      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    }
    clone() {
      const polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      polygon.applyProperties(this);
      return polygon;
    }
    closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0,require$_DOT__DOT__SLASH_extent_DOT_js.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,require$_DOT__SLASH_flat_SLASH_closest_DOT_js.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision());
      return (0,require$_DOT__SLASH_flat_SLASH_closest_DOT_js.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, x, y, closestPoint, minSquaredDistance);
    }
    containsXY(x, y) {
      return (0,require$_DOT__SLASH_flat_SLASH_contains_DOT_js.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    }
    getArea() {
      return (0,require$_DOT__SLASH_flat_SLASH_area_DOT_js.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }
    getCoordinates(right) {
      let flatCoordinates;
      void 0 !== right ? (flatCoordinates = this.getOrientedFlatCoordinates().slice(), (0,require$_DOT__SLASH_flat_SLASH_orient_DOT_js.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right)) : flatCoordinates = this.flatCoordinates;
      return (0,require$_DOT__SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
    }
    getEnds() {
      return this.ends_;
    }
    getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        const flatCenter = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getCenter)(this.getExtent());
        this.flatInteriorPoint_ = (0,require$_DOT__SLASH_flat_SLASH_interiorpoint_DOT_js.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
        this.flatInteriorPointRevision_ = this.getRevision();
      }
      return this.flatInteriorPoint_;
    }
    getInteriorPoint() {
      return new default$$require$_DOT__SLASH_Point_DOT_js.default(this.getFlatInteriorPoint(), "XYM");
    }
    getLinearRingCount() {
      return this.ends_.length;
    }
    getLinearRing(index) {
      return 0 > index || this.ends_.length <= index ? null : new default$$require$_DOT__SLASH_LinearRing_DOT_js.default(this.flatCoordinates.slice(0 === index ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    getLinearRings() {
      const layout = this.layout, flatCoordinates = this.flatCoordinates, ends = this.ends_, linearRings = [];
      var offset = 0;
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        const end = ends[i];
        offset = new default$$require$_DOT__SLASH_LinearRing_DOT_js.default(flatCoordinates.slice(offset, end), layout);
        linearRings.push(offset);
        offset = end;
      }
      return linearRings;
    }
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const flatCoordinates = this.flatCoordinates;
        (0,require$_DOT__SLASH_flat_SLASH_orient_DOT_js.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = flatCoordinates : (this.orientedFlatCoordinates_ = flatCoordinates.slice(), this.orientedFlatCoordinates_.length = (0,require$_DOT__SLASH_flat_SLASH_orient_DOT_js.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride));
        this.orientedRevision_ = this.getRevision();
      }
      return this.orientedFlatCoordinates_;
    }
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [], simplifiedEnds = [];
      simplifiedFlatCoordinates.length = (0,require$_DOT__SLASH_flat_SLASH_simplify_DOT_js.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
      return new Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
    }
    getType() {
      return "Polygon";
    }
    intersectsExtent(extent) {
      return (0,require$_DOT__SLASH_flat_SLASH_intersectsextent_DOT_js.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    }
    setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 2);
      this.flatCoordinates || (this.flatCoordinates = []);
      coordinates = (0,require$_DOT__SLASH_flat_SLASH_deflate_DOT_js.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
      this.flatCoordinates.length = 0 === coordinates.length ? 0 : coordinates[coordinates.length - 1];
      this.changed();
    }
  }
  const $$default = Polygon;
};

//# sourceMappingURL=module$node_modules$ol$geom$Polygon.js.map
