shadow$provide.module$node_modules$ol$layer$Graticule = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_Collection_DOT_js = require("module$node_modules$ol$Collection");
  global = require("module$node_modules$ol$Feature");
  var require$_DOT__DOT__SLASH_coordinate_DOT_js = require("module$node_modules$ol$coordinate"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_geom_SLASH_LineString_DOT_js = require("module$node_modules$ol$geom$LineString");
  module = require("module$node_modules$ol$geom$Point");
  var require$_DOT__DOT__SLASH_geom_SLASH_flat_SLASH_geodesic_DOT_js = require("module$node_modules$ol$geom$flat$geodesic"), require$_DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj");
  exports = require("module$node_modules$ol$render$EventType");
  var require$_DOT__DOT__SLASH_render_DOT_js = require("module$node_modules$ol$render"), require$_DOT__DOT__SLASH_source_SLASH_Vector_DOT_js = require("module$node_modules$ol$source$Vector"), require$_DOT__DOT__SLASH_style_SLASH_Fill_DOT_js = require("module$node_modules$ol$style$Fill"), require$_DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js = require("module$node_modules$ol$style$Stroke"), require$_DOT__DOT__SLASH_style_SLASH_Style_DOT_js = require("module$node_modules$ol$style$Style"), require$_DOT__DOT__SLASH_style_SLASH_Text_DOT_js = 
  require("module$node_modules$ol$style$Text"), require$_DOT__SLASH_Vector_DOT_js = require("module$node_modules$ol$layer$Vector"), default$$require$_DOT__DOT__SLASH_geom_SLASH_LineString_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_geom_SLASH_LineString_DOT_js), default$$require$_DOT__DOT__SLASH_Collection_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_Collection_DOT_js);
  require$_DOT__DOT__SLASH_Collection_DOT_js = require.esmDefault(require$_DOT__SLASH_Vector_DOT_js);
  var default$$require$_DOT__DOT__SLASH_style_SLASH_Style_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_style_SLASH_Style_DOT_js), default$$require$_DOT__DOT__SLASH_style_SLASH_Fill_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_style_SLASH_Fill_DOT_js), default$$require$_DOT__DOT__SLASH_render_SLASH_EventType_DOT_js = require.esmDefault(exports), default$$require$_DOT__DOT__SLASH_geom_SLASH_Point_DOT_js = require.esmDefault(module), default$$require$_DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js = 
  require.esmDefault(require$_DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js), default$$require$_DOT__DOT__SLASH_style_SLASH_Text_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_style_SLASH_Text_DOT_js), default$$require$_DOT__DOT__SLASH_source_SLASH_Vector_DOT_js = require.esmDefault(require$_DOT__DOT__SLASH_source_SLASH_Vector_DOT_js), default$$require$_DOT__DOT__SLASH_Feature_DOT_js = require.esmDefault(global);
  const DEFAULT_STROKE_STYLE = new default$$require$_DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js.default({color:"rgba(0,0,0,0.2)"}), INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, .5, 20 / 60, 10 / 60, 5 / 60, 2 / 60, 1 / 60, 30 / 3600, 20 / 3600, 10 / 3600, 5 / 3600, 2 / 3600, 1 / 3600];
  class Graticule extends require$_DOT__DOT__SLASH_Collection_DOT_js.default {
    constructor(options) {
      options = options ? options : {};
      const baseOptions = Object.assign({updateWhileAnimating:!0, updateWhileInteracting:!0, renderBuffer:0}, options);
      delete baseOptions.maxLines;
      delete baseOptions.strokeStyle;
      delete baseOptions.targetSize;
      delete baseOptions.showLabels;
      delete baseOptions.lonLabelFormatter;
      delete baseOptions.latLabelFormatter;
      delete baseOptions.lonLabelPosition;
      delete baseOptions.latLabelPosition;
      delete baseOptions.lonLabelStyle;
      delete baseOptions.latLabelStyle;
      delete baseOptions.intervals;
      super(baseOptions);
      this.projection_ = null;
      this.maxLon_ = this.maxLat_ = Infinity;
      this.minLon_ = this.minLat_ = -Infinity;
      this.maxY_ = this.maxX_ = Infinity;
      this.minY_ = this.minX_ = -Infinity;
      this.targetSize_ = void 0 !== options.targetSize ? options.targetSize : 100;
      this.maxLines_ = void 0 !== options.maxLines ? options.maxLines : 100;
      this.meridians_ = [];
      this.parallels_ = [];
      this.strokeStyle_ = void 0 !== options.strokeStyle ? options.strokeStyle : DEFAULT_STROKE_STYLE;
      this.toLonLatTransform_ = this.fromLonLatTransform_ = void 0;
      this.parallelsLabels_ = this.meridiansLabels_ = this.topRight_ = this.topLeft_ = this.bottomRight_ = this.bottomLeft_ = this.projectionCenterLonLat_ = null;
      options.showLabels && (this.lonLabelFormatter_ = void 0 == options.lonLabelFormatter ? require$_DOT__DOT__SLASH_coordinate_DOT_js.degreesToStringHDMS.bind(this, "EW") : options.lonLabelFormatter, this.latLabelFormatter_ = void 0 == options.latLabelFormatter ? require$_DOT__DOT__SLASH_coordinate_DOT_js.degreesToStringHDMS.bind(this, "NS") : options.latLabelFormatter, this.lonLabelPosition_ = void 0 == options.lonLabelPosition ? 0 : options.lonLabelPosition, this.latLabelPosition_ = void 0 == 
      options.latLabelPosition ? 1 : options.latLabelPosition, this.lonLabelStyleBase_ = new default$$require$_DOT__DOT__SLASH_style_SLASH_Style_DOT_js.default({text:void 0 !== options.lonLabelStyle ? options.lonLabelStyle.clone() : new default$$require$_DOT__DOT__SLASH_style_SLASH_Text_DOT_js.default({font:"12px Calibri,sans-serif", textBaseline:"bottom", fill:new default$$require$_DOT__DOT__SLASH_style_SLASH_Fill_DOT_js.default({color:"rgba(0,0,0,1)"}), stroke:new default$$require$_DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js.default({color:"rgba(255,255,255,1)", 
      width:3})})}), this.lonLabelStyle_ = feature => {
        feature = feature.get("graticule_label");
        this.lonLabelStyleBase_.getText().setText(feature);
        return this.lonLabelStyleBase_;
      }, this.latLabelStyleBase_ = new default$$require$_DOT__DOT__SLASH_style_SLASH_Style_DOT_js.default({text:void 0 !== options.latLabelStyle ? options.latLabelStyle.clone() : new default$$require$_DOT__DOT__SLASH_style_SLASH_Text_DOT_js.default({font:"12px Calibri,sans-serif", textAlign:"right", fill:new default$$require$_DOT__DOT__SLASH_style_SLASH_Fill_DOT_js.default({color:"rgba(0,0,0,1)"}), stroke:new default$$require$_DOT__DOT__SLASH_style_SLASH_Stroke_DOT_js.default({color:"rgba(255,255,255,1)", 
      width:3})})}), this.latLabelStyle_ = feature => {
        feature = feature.get("graticule_label");
        this.latLabelStyleBase_.getText().setText(feature);
        return this.latLabelStyleBase_;
      }, this.meridiansLabels_ = [], this.parallelsLabels_ = [], this.addEventListener(default$$require$_DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.POSTRENDER, this.drawLabels_.bind(this)));
      this.intervals_ = void 0 !== options.intervals ? options.intervals : INTERVALS;
      this.setSource(new default$$require$_DOT__DOT__SLASH_source_SLASH_Vector_DOT_js.default({loader:this.loaderFunction.bind(this), strategy:this.strategyFunction.bind(this), features:new default$$require$_DOT__DOT__SLASH_Collection_DOT_js.default(), overlaps:!1, useSpatialIndex:!1, wrapX:options.wrapX}));
      this.featurePool_ = [];
      this.lineStyle_ = new default$$require$_DOT__DOT__SLASH_style_SLASH_Style_DOT_js.default({stroke:this.strokeStyle_});
      this.renderedResolution_ = this.renderedExtent_ = this.loadedExtent_ = null;
      this.setRenderOrder(null);
    }
    strategyFunction(extent, resolution) {
      extent = extent.slice();
      this.projection_ && this.getSource().getWrapX() && (0,require$_DOT__DOT__SLASH_extent_DOT_js.wrapX)(extent, this.projection_);
      this.loadedExtent_ && ((0,require$_DOT__DOT__SLASH_extent_DOT_js.approximatelyEquals)(this.loadedExtent_, extent, resolution) ? extent = this.loadedExtent_.slice() : this.getSource().removeLoadedExtent(this.loadedExtent_));
      return [extent];
    }
    loaderFunction(extent, resolution, projection) {
      this.loadedExtent_ = extent;
      var source = this.getSource(), layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];
      extent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getIntersection)(layerExtent, extent);
      if (!this.renderedExtent_ || !(0,require$_DOT__DOT__SLASH_extent_DOT_js.equals)(this.renderedExtent_, extent) || this.renderedResolution_ !== resolution) {
        if (this.renderedExtent_ = extent, this.renderedResolution_ = resolution, !(0,require$_DOT__DOT__SLASH_extent_DOT_js.isEmpty)(extent)) {
          layerExtent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getCenter)(extent);
          var squaredTolerance = resolution * resolution / 4;
          this.projection_ && (0,require$_DOT__DOT__SLASH_proj_DOT_js.equivalent)(this.projection_, projection) || this.updateProjectionInfo_(projection);
          this.createGraticule_(extent, layerExtent, resolution, squaredTolerance);
          projection = this.meridians_.length + this.parallels_.length;
          this.meridiansLabels_ && (projection += this.meridians_.length);
          for (this.parallelsLabels_ && (projection += this.parallels_.length); projection > this.featurePool_.length;) {
            resolution = new default$$require$_DOT__DOT__SLASH_Feature_DOT_js.default(), this.featurePool_.push(resolution);
          }
          source = source.getFeaturesCollection();
          source.clear();
          extent = projection = 0;
          for (layerExtent = this.meridians_.length; extent < layerExtent; ++extent) {
            resolution = this.featurePool_[projection++], resolution.setGeometry(this.meridians_[extent]), resolution.setStyle(this.lineStyle_), source.push(resolution);
          }
          extent = 0;
          for (layerExtent = this.parallels_.length; extent < layerExtent; ++extent) {
            resolution = this.featurePool_[projection++], resolution.setGeometry(this.parallels_[extent]), resolution.setStyle(this.lineStyle_), source.push(resolution);
          }
        }
      }
    }
    addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {
      minLat = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);
      (0,require$_DOT__DOT__SLASH_extent_DOT_js.intersects)(minLat.getExtent(), extent) && (this.meridiansLabels_ && (lon = this.lonLabelFormatter_(lon), index in this.meridiansLabels_ ? this.meridiansLabels_[index].text = lon : this.meridiansLabels_[index] = {geom:new default$$require$_DOT__DOT__SLASH_geom_SLASH_Point_DOT_js.default([]), text:lon}), this.meridians_[index++] = minLat);
      return index;
    }
    addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {
      minLon = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);
      (0,require$_DOT__DOT__SLASH_extent_DOT_js.intersects)(minLon.getExtent(), extent) && (this.parallelsLabels_ && (lat = this.latLabelFormatter_(lat), index in this.parallelsLabels_ ? this.parallelsLabels_[index].text = lat : this.parallelsLabels_[index] = {geom:new default$$require$_DOT__DOT__SLASH_geom_SLASH_Point_DOT_js.default([]), text:lat}), this.parallels_[index++] = minLon);
      return index;
    }
    drawLabels_(event) {
      const rotation = event.frameState.viewState.rotation;
      var resolution = event.frameState.viewState.resolution, size = event.frameState.size;
      const extent = event.frameState.extent, rotationCenter = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getCenter)(extent);
      var rotationExtent = extent;
      rotation && (rotationExtent = size[0] * resolution, resolution *= size[1], rotationExtent = [rotationCenter[0] - rotationExtent / 2, rotationCenter[1] - resolution / 2, rotationCenter[0] + rotationExtent / 2, rotationCenter[1] + resolution / 2]);
      size = resolution = 0;
      let labelsAtStart = 0.5 > this.latLabelPosition_;
      var projectionExtent = this.projection_.getExtent();
      const worldWidth = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(projectionExtent);
      this.getSource().getWrapX() && this.projection_.canWrapX() && !(0,require$_DOT__DOT__SLASH_extent_DOT_js.containsExtent)(projectionExtent, extent) && (resolution = Math.floor((extent[0] - projectionExtent[0]) / worldWidth), size = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth), labelsAtStart = labelsAtStart !== Math.abs(rotation) > Math.PI / 2);
      event = (0,require$_DOT__DOT__SLASH_render_DOT_js.getVectorContext)(event);
      for (projectionExtent = resolution; projectionExtent <= size; ++projectionExtent) {
        let poolIndex = this.meridians_.length + this.parallels_.length;
        var feature = void 0;
        let index, l, textPoint;
        if (this.meridiansLabels_) {
          for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {
            feature = this.meridians_[index], rotation || 0 !== projectionExtent ? (feature = feature.clone(), feature.translate(projectionExtent * worldWidth, 0), feature.rotate(-rotation, rotationCenter), textPoint = this.getMeridianPoint_(feature, rotationExtent, index), textPoint.rotate(rotation, rotationCenter)) : textPoint = this.getMeridianPoint_(feature, extent, index), feature = this.featurePool_[poolIndex++], feature.setGeometry(textPoint), feature.set("graticule_label", this.meridiansLabels_[index].text), 
            event.drawFeature(feature, this.lonLabelStyle_(feature));
          }
        }
        if (this.parallelsLabels_ && (projectionExtent === resolution && labelsAtStart || projectionExtent === size && !labelsAtStart)) {
          for (index = 0, l = this.parallels_.length; index < l; ++index) {
            feature = this.parallels_[index], rotation || 0 !== projectionExtent ? (feature = feature.clone(), feature.translate(projectionExtent * worldWidth, 0), feature.rotate(-rotation, rotationCenter), textPoint = this.getParallelPoint_(feature, rotationExtent, index), textPoint.rotate(rotation, rotationCenter)) : textPoint = this.getParallelPoint_(feature, extent, index), feature = this.featurePool_[poolIndex++], feature.setGeometry(textPoint), feature.set("graticule_label", this.parallelsLabels_[index].text), 
            event.drawFeature(feature, this.latLabelStyle_(feature));
          }
        }
      }
    }
    createGraticule_(extent, center, resolution, squaredTolerance) {
      resolution = this.getInterval_(resolution);
      if (-1 == resolution) {
        this.meridians_.length = 0, this.parallels_.length = 0, this.meridiansLabels_ && (this.meridiansLabels_.length = 0), this.parallelsLabels_ && (this.parallelsLabels_.length = 0);
      } else {
        var wrapX = !1, projectionExtent = this.projection_.getExtent(), worldWidth = (0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(projectionExtent);
        this.getSource().getWrapX() && this.projection_.canWrapX() && !(0,require$_DOT__DOT__SLASH_extent_DOT_js.containsExtent)(projectionExtent, extent) && ((0,require$_DOT__DOT__SLASH_extent_DOT_js.getWidth)(extent) >= worldWidth ? (extent[0] = projectionExtent[0], extent[2] = projectionExtent[2]) : wrapX = !0);
        center = [(0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(center[0], this.minX_, this.maxX_), (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(center[1], this.minY_, this.maxY_)];
        projectionExtent = this.toLonLatTransform_(center);
        isNaN(projectionExtent[1]) && (projectionExtent[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_);
        center = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(projectionExtent[0], this.minLon_, this.maxLon_);
        projectionExtent = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(projectionExtent[1], this.minLat_, this.maxLat_);
        worldWidth = this.maxLines_;
        var cnt = extent;
        wrapX || (cnt = [(0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(extent[0], this.minX_, this.maxX_), (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(extent[1], this.minY_, this.maxY_), (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(extent[2], this.minX_, this.maxX_), (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(extent[3], this.minY_, this.maxY_)]);
        var validExtent = (0,require$_DOT__DOT__SLASH_extent_DOT_js.applyTransform)(cnt, this.toLonLatTransform_, void 0, 8), maxLat = validExtent[3], maxLon = validExtent[2], minLat = validExtent[1];
        validExtent = validExtent[0];
        wrapX || ((0,require$_DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(cnt, this.bottomLeft_) && (validExtent = this.minLon_, minLat = this.minLat_), (0,require$_DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(cnt, this.bottomRight_) && (maxLon = this.maxLon_, minLat = this.minLat_), (0,require$_DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(cnt, this.topLeft_) && (validExtent = this.minLon_, maxLat = this.maxLat_), (0,require$_DOT__DOT__SLASH_extent_DOT_js.containsCoordinate)(cnt, 
        this.topRight_) && (maxLon = this.maxLon_, maxLat = this.maxLat_), maxLat = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(maxLat, projectionExtent, this.maxLat_), maxLon = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(maxLon, center, this.maxLon_), minLat = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(minLat, this.minLat_, projectionExtent), validExtent = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(validExtent, this.minLon_, center));
        center = Math.floor(center / resolution) * resolution;
        var lon = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(center, this.minLon_, this.maxLon_);
        var idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);
        cnt = 0;
        if (wrapX) {
          for (; (lon -= resolution) >= validExtent && cnt++ < worldWidth;) {
            idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
          }
        } else {
          for (; lon != this.minLon_ && cnt++ < worldWidth;) {
            lon = Math.max(lon - resolution, this.minLon_), idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
          }
        }
        lon = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(center, this.minLon_, this.maxLon_);
        cnt = 0;
        if (wrapX) {
          for (; (lon += resolution) <= maxLon && cnt++ < worldWidth;) {
            idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
          }
        } else {
          for (; lon != this.maxLon_ && cnt++ < worldWidth;) {
            lon = Math.min(lon + resolution, this.maxLon_), idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
          }
        }
        this.meridians_.length = idx;
        this.meridiansLabels_ && (this.meridiansLabels_.length = idx);
        projectionExtent = Math.floor(projectionExtent / resolution) * resolution;
        wrapX = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(projectionExtent, this.minLat_, this.maxLat_);
        idx = this.addParallel_(wrapX, validExtent, maxLon, squaredTolerance, extent, 0);
        for (cnt = 0; wrapX != this.minLat_ && cnt++ < worldWidth;) {
          wrapX = Math.max(wrapX - resolution, this.minLat_), idx = this.addParallel_(wrapX, validExtent, maxLon, squaredTolerance, extent, idx);
        }
        wrapX = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(projectionExtent, this.minLat_, this.maxLat_);
        for (cnt = 0; wrapX != this.maxLat_ && cnt++ < worldWidth;) {
          wrapX = Math.min(wrapX + resolution, this.maxLat_), idx = this.addParallel_(wrapX, validExtent, maxLon, squaredTolerance, extent, idx);
        }
        this.parallels_.length = idx;
        this.parallelsLabels_ && (this.parallelsLabels_.length = idx);
      }
    }
    getInterval_(resolution) {
      const centerLon = this.projectionCenterLonLat_[0], centerLat = this.projectionCenterLonLat_[1];
      let interval = -1;
      resolution = Math.pow(this.targetSize_ * resolution, 2);
      const p1 = [], p2 = [];
      for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {
        const delta = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(this.intervals_[i] / 2, 0, 90), clampedLat = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(centerLat, -90 + delta, 90 - delta);
        p1[0] = centerLon - delta;
        p1[1] = clampedLat - delta;
        p2[0] = centerLon + delta;
        p2[1] = clampedLat + delta;
        this.fromLonLatTransform_(p1, p1);
        this.fromLonLatTransform_(p2, p2);
        if (Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2) <= resolution) {
          break;
        }
        interval = this.intervals_[i];
      }
      return interval;
    }
    getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {
      lon = (0,require$_DOT__DOT__SLASH_geom_SLASH_flat_SLASH_geodesic_DOT_js.meridian)(lon, minLat, maxLat, this.projection_, squaredTolerance);
      (minLat = this.meridians_[index]) ? (minLat.setFlatCoordinates("XY", lon), minLat.changed()) : (minLat = new default$$require$_DOT__DOT__SLASH_geom_SLASH_LineString_DOT_js.default(lon, "XY"), this.meridians_[index] = minLat);
      return minLat;
    }
    getMeridianPoint_(lineString, extent, index) {
      lineString = lineString.getFlatCoordinates();
      let bottom = 1, top = lineString.length - 1;
      lineString[bottom] > lineString[top] && (bottom = top, top = 1);
      extent = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, Math.max(extent[1], lineString[bottom]), Math.min(extent[3], lineString[top]));
      index = this.meridiansLabels_[index].geom;
      index.setCoordinates([lineString[bottom - 1] + (lineString[top - 1] - lineString[bottom - 1]) * (extent - lineString[bottom]) / (lineString[top] - lineString[bottom]), extent]);
      return index;
    }
    getMeridians() {
      return this.meridians_;
    }
    getParallel_(lat, minLon, maxLon, squaredTolerance, index) {
      lat = (0,require$_DOT__DOT__SLASH_geom_SLASH_flat_SLASH_geodesic_DOT_js.parallel)(lat, minLon, maxLon, this.projection_, squaredTolerance);
      (index = this.parallels_[index]) ? (index.setFlatCoordinates("XY", lat), index.changed()) : index = new default$$require$_DOT__DOT__SLASH_geom_SLASH_LineString_DOT_js.default(lat, "XY");
      return index;
    }
    getParallelPoint_(lineString, extent, index) {
      lineString = lineString.getFlatCoordinates();
      let left = 0, right = lineString.length - 2;
      lineString[left] > lineString[right] && (left = right, right = 0);
      extent = (0,require$_DOT__DOT__SLASH_math_DOT_js.clamp)(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, Math.max(extent[0], lineString[left]), Math.min(extent[2], lineString[right]));
      index = this.parallelsLabels_[index].geom;
      index.setCoordinates([extent, lineString[left + 1] + (lineString[right + 1] - lineString[left + 1]) * (extent - lineString[left]) / (lineString[right] - lineString[left])]);
      return index;
    }
    getParallels() {
      return this.parallels_;
    }
    updateProjectionInfo_(projection) {
      var epsg4326Projection = (0,require$_DOT__DOT__SLASH_proj_DOT_js.get)("EPSG:4326");
      const worldExtent = projection.getWorldExtent();
      this.maxLat_ = worldExtent[3];
      this.maxLon_ = worldExtent[2];
      this.minLat_ = worldExtent[1];
      this.minLon_ = worldExtent[0];
      const toLonLatTransform = (0,require$_DOT__DOT__SLASH_proj_DOT_js.getTransform)(projection, epsg4326Projection);
      if (this.minLon_ < this.maxLon_) {
        this.toLonLatTransform_ = toLonLatTransform;
      } else {
        const split = this.minLon_ + this.maxLon_ / 2;
        this.maxLon_ += 360;
        this.toLonLatTransform_ = function(coordinates, output, dimension) {
          dimension = dimension || 2;
          coordinates = toLonLatTransform(coordinates, output, dimension);
          for (let i = 0, l = coordinates.length; i < l; i += dimension) {
            coordinates[i] < split && (coordinates[i] += 360);
          }
          return coordinates;
        };
      }
      this.fromLonLatTransform_ = (0,require$_DOT__DOT__SLASH_proj_DOT_js.getTransform)(epsg4326Projection, projection);
      epsg4326Projection = (0,require$_DOT__DOT__SLASH_extent_DOT_js.applyTransform)([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, void 0, 8);
      this.minX_ = epsg4326Projection[0];
      this.maxX_ = epsg4326Projection[2];
      this.minY_ = epsg4326Projection[1];
      this.maxY_ = epsg4326Projection[3];
      this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);
      this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);
      this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);
      this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);
      this.projectionCenterLonLat_ = this.toLonLatTransform_((0,require$_DOT__DOT__SLASH_extent_DOT_js.getCenter)(projection.getExtent()));
      isNaN(this.projectionCenterLonLat_[1]) && (this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_);
      this.projection_ = projection;
    }
  }
  const $$default = Graticule;
};

//# sourceMappingURL=module$node_modules$ol$layer$Graticule.js.map
