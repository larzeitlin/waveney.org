shadow$provide.module$node_modules$ol$color = function(global, require, module, exports) {
  function asString(color) {
    return "string" === typeof color ? color : toString(color);
  }
  function withAlpha(color) {
    if (4 === color.length) {
      return color;
    }
    color = color.slice();
    color[3] = 1;
    return color;
  }
  function rgbaToLcha(color) {
    const output = default$$require$color_space_SLASH_xyz_DOT_js.default.lchuv(default$$require$color_space_SLASH_rgb_DOT_js.default.xyz(color));
    output[3] = color[3];
    return output;
  }
  function lchaToRgba(color) {
    const output = default$$require$color_space_SLASH_xyz_DOT_js.default.rgb(default$$require$color_space_SLASH_lchuv_DOT_js.default.xyz(color));
    output[3] = color[3];
    return output;
  }
  function fromString(s) {
    if ("none" === s) {
      return NO_COLOR;
    }
    if (cache.hasOwnProperty(s)) {
      return cache[s];
    }
    if (1024 <= cacheSize) {
      var i = 0;
      for (const key in cache) {
        0 === (i++ & 3) && (delete cache[key], --cacheSize);
      }
    }
    i = (0,default$$require$color_rgba.default)(s);
    if (4 !== i.length) {
      throw Error('failed to parse "' + s + '" as color');
    }
    for (const c of i) {
      if (isNaN(c)) {
        throw Error('failed to parse "' + s + '" as color');
      }
    }
    normalize(i);
    cache[s] = i;
    ++cacheSize;
    return i;
  }
  function asArray(color) {
    return Array.isArray(color) ? color : fromString(color);
  }
  function normalize(color) {
    color[0] = (0,require$_DOT__SLASH_math_DOT_js.clamp)(color[0] + 0.5 | 0, 0, 255);
    color[1] = (0,require$_DOT__SLASH_math_DOT_js.clamp)(color[1] + 0.5 | 0, 0, 255);
    color[2] = (0,require$_DOT__SLASH_math_DOT_js.clamp)(color[2] + 0.5 | 0, 0, 255);
    color[3] = (0,require$_DOT__SLASH_math_DOT_js.clamp)(color[3], 0, 1);
    return color;
  }
  function toString(color) {
    let r = color[0];
    r != (r | 0) && (r = r + 0.5 | 0);
    let g = color[1];
    g != (g | 0) && (g = g + 0.5 | 0);
    let b = color[2];
    b != (b | 0) && (b = b + 0.5 | 0);
    return "rgba(" + r + "," + g + "," + b + "," + (void 0 === color[3] ? 1 : Math.round(1000 * color[3]) / 1000) + ")";
  }
  function isStringColor(s) {
    try {
      return fromString(s), !0;
    } catch {
      return !1;
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, NO_COLOR:{enumerable:!0, get:function() {
    return NO_COLOR;
  }}, asArray:{enumerable:!0, get:function() {
    return asArray;
  }}, asString:{enumerable:!0, get:function() {
    return asString;
  }}, fromString:{enumerable:!0, get:function() {
    return fromString;
  }}, isStringColor:{enumerable:!0, get:function() {
    return isStringColor;
  }}, lchaToRgba:{enumerable:!0, get:function() {
    return lchaToRgba;
  }}, normalize:{enumerable:!0, get:function() {
    return normalize;
  }}, rgbaToLcha:{enumerable:!0, get:function() {
    return rgbaToLcha;
  }}, toString:{enumerable:!0, get:function() {
    return toString;
  }}, withAlpha:{enumerable:!0, get:function() {
    return withAlpha;
  }}});
  global = require("module$node_modules$color_rgba$index");
  module = require("module$node_modules$color_space$lchuv");
  exports = require("module$node_modules$color_space$rgb");
  var require$color_space_SLASH_xyz_DOT_js = require("module$node_modules$color_space$xyz"), require$_DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), default$$require$color_space_SLASH_rgb_DOT_js = require.esmDefault(exports), default$$require$color_space_SLASH_lchuv_DOT_js = require.esmDefault(module), default$$require$color_rgba = require.esmDefault(global), default$$require$color_space_SLASH_xyz_DOT_js = require.esmDefault(require$color_space_SLASH_xyz_DOT_js);
  const NO_COLOR = [NaN, NaN, NaN, 0], cache = {};
  let cacheSize = 0;
};

//# sourceMappingURL=module$node_modules$ol$color.js.map
