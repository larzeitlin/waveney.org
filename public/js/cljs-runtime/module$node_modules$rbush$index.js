shadow$provide.module$node_modules$rbush$index = function(global, require, module, exports) {
  function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
  }
  function distBBox(node, k, p, toBBox, destNode) {
    destNode || (destNode = createNode(null));
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    for (destNode.maxY = -Infinity; k < p; k++) {
      const child = node.children[k];
      extend(destNode, node.leaf ? toBBox(child) : child);
    }
    return destNode;
  }
  function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
  }
  function compareNodeMinX(a, b) {
    return a.minX - b.minX;
  }
  function compareNodeMinY(a, b) {
    return a.minY - b.minY;
  }
  function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
  }
  function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
  }
  function contains(a, b) {
    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
  }
  function intersects(a, b) {
    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
  }
  function createNode(children) {
    return {children, height:1, leaf:!0, minX:Infinity, minY:Infinity, maxX:-Infinity, maxY:-Infinity};
  }
  function multiSelect(arr, left, right, n, compare) {
    const stack = [left, right];
    for (; stack.length;) {
      right = stack.pop();
      left = stack.pop();
      if (right - left <= n) {
        continue;
      }
      const mid = left + Math.ceil((right - left) / n / 2) * n;
      (0,default$$require$quickselect.default)(arr, mid, left, right, compare);
      stack.push(left, mid, mid, right);
    }
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return RBush;
  }}});
  global = require("module$node_modules$quickselect$index");
  var default$$require$quickselect = require.esmDefault(global);
  class RBush {
    constructor(maxEntries = 9) {
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries));
      this.clear();
    }
    all() {
      return this._all(this.data, []);
    }
    search(bbox) {
      let node = this.data;
      const result = [];
      if (!intersects(bbox, node)) {
        return result;
      }
      const toBBox = this.toBBox, nodesToSearch = [];
      for (; node;) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i], childBBox = node.leaf ? toBBox(child) : child;
          intersects(bbox, childBBox) && (node.leaf ? result.push(child) : contains(bbox, childBBox) ? this._all(child, result) : nodesToSearch.push(child));
        }
        node = nodesToSearch.pop();
      }
      return result;
    }
    collides(bbox) {
      let node = this.data;
      if (!intersects(bbox, node)) {
        return !1;
      }
      const nodesToSearch = [];
      for (; node;) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i], childBBox = node.leaf ? this.toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox)) {
              return !0;
            }
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return !1;
    }
    load(data) {
      if (!data || !data.length) {
        return this;
      }
      if (data.length < this._minEntries) {
        for (var i = 0; i < data.length; i++) {
          this.insert(data[i]);
        }
        return this;
      }
      data = this._build(data.slice(), 0, data.length - 1, 0);
      this.data.children.length ? this.data.height === data.height ? this._splitRoot(this.data, data) : (this.data.height < data.height && (i = this.data, this.data = data, data = i), this._insert(data, this.data.height - data.height - 1, !0)) : this.data = data;
      return this;
    }
    insert(item) {
      item && this._insert(item, this.data.height - 1);
      return this;
    }
    clear() {
      this.data = createNode([]);
      return this;
    }
    remove(item, equalsFn) {
      if (!item) {
        return this;
      }
      let node = this.data;
      const bbox = this.toBBox(item), path = [], indexes = [];
      let i, parent, goingUp;
      for (; node || path.length;) {
        node || (node = path.pop(), parent = path[path.length - 1], i = indexes.pop(), goingUp = !0);
        if (node.leaf) {
          a: {
            var JSCompiler_inline_result = item;
            var items = node.children, equalsFn$jscomp$0 = equalsFn;
            if (equalsFn$jscomp$0) {
              for (let i = 0; i < items.length; i++) {
                if (equalsFn$jscomp$0(JSCompiler_inline_result, items[i])) {
                  JSCompiler_inline_result = i;
                  break a;
                }
              }
              JSCompiler_inline_result = -1;
            } else {
              JSCompiler_inline_result = items.indexOf(JSCompiler_inline_result);
            }
          }
          if (-1 !== JSCompiler_inline_result) {
            node.children.splice(JSCompiler_inline_result, 1);
            path.push(node);
            this._condense(path);
            break;
          }
        }
        goingUp || node.leaf || !contains(node, bbox) ? parent ? (i++, node = parent.children[i], goingUp = !1) : node = null : (path.push(node), indexes.push(i), i = 0, parent = node, node = node.children[0]);
      }
      return this;
    }
    toBBox(item) {
      return item;
    }
    compareMinX(a, b) {
      return a.minX - b.minX;
    }
    compareMinY(a, b) {
      return a.minY - b.minY;
    }
    toJSON() {
      return this.data;
    }
    fromJSON(data) {
      this.data = data;
      return this;
    }
    _all(node, result) {
      const nodesToSearch = [];
      for (; node;) {
        node.leaf ? result.push(...node.children) : nodesToSearch.push(...node.children), node = nodesToSearch.pop();
      }
      return result;
    }
    _build(items, left, right, height) {
      var N = right - left + 1, M = this._maxEntries;
      let node;
      if (N <= M) {
        return node = createNode(items.slice(left, right + 1)), calcBBox(node, this.toBBox), node;
      }
      height || (height = Math.ceil(Math.log(N) / Math.log(M)), M = Math.ceil(N / Math.pow(M, height - 1)));
      node = createNode([]);
      node.leaf = !1;
      node.height = height;
      N = Math.ceil(N / M);
      M = N * Math.ceil(Math.sqrt(M));
      for (multiSelect(items, left, right, M, this.compareMinX); left <= right; left += M) {
        const right2 = Math.min(left + M - 1, right);
        multiSelect(items, left, right2, N, this.compareMinY);
        for (let j = left; j <= right2; j += N) {
          node.children.push(this._build(items, j, Math.min(j + N - 1, right2), height - 1));
        }
      }
      calcBBox(node, this.toBBox);
      return node;
    }
    _chooseSubtree(bbox, node, level, path) {
      for (;;) {
        path.push(node);
        if (node.leaf || path.length - 1 === level) {
          break;
        }
        let minArea = Infinity, minEnlargement = Infinity, targetNode;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i], area = bboxArea(child), enlargement = (Math.max(child.maxX, bbox.maxX) - Math.min(child.minX, bbox.minX)) * (Math.max(child.maxY, bbox.maxY) - Math.min(child.minY, bbox.minY)) - area;
          enlargement < minEnlargement ? (minEnlargement = enlargement, minArea = area < minArea ? area : minArea, targetNode = child) : enlargement === minEnlargement && area < minArea && (minArea = area, targetNode = child);
        }
        node = targetNode || node.children[0];
      }
      return node;
    }
    _insert(item, level, isNode) {
      isNode = isNode ? item : this.toBBox(item);
      const insertPath = [], node = this._chooseSubtree(isNode, this.data, level, insertPath);
      node.children.push(item);
      for (extend(node, isNode); 0 <= level;) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level), level--;
        } else {
          break;
        }
      }
      this._adjustParentBBoxes(isNode, insertPath, level);
    }
    _split(insertPath, level) {
      const node = insertPath[level];
      var M = node.children.length;
      const m = this._minEntries;
      this._chooseSplitAxis(node, m, M);
      M = this._chooseSplitIndex(node, m, M);
      M = createNode(node.children.splice(M, node.children.length - M));
      M.height = node.height;
      M.leaf = node.leaf;
      calcBBox(node, this.toBBox);
      calcBBox(M, this.toBBox);
      level ? insertPath[level - 1].children.push(M) : this._splitRoot(node, M);
    }
    _splitRoot(node, newNode) {
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = !1;
      calcBBox(this.data, this.toBBox);
    }
    _chooseSplitIndex(node, m, M) {
      let index, minOverlap = Infinity, minArea = Infinity;
      for (let i = m; i <= M - m; i++) {
        var bbox1 = distBBox(node, 0, i, this.toBBox);
        const bbox2 = distBBox(node, i, M, this.toBBox), overlap = Math.max(0, Math.min(bbox1.maxX, bbox2.maxX) - Math.max(bbox1.minX, bbox2.minX)) * Math.max(0, Math.min(bbox1.maxY, bbox2.maxY) - Math.max(bbox1.minY, bbox2.minY));
        bbox1 = bboxArea(bbox1) + bboxArea(bbox2);
        overlap < minOverlap ? (minOverlap = overlap, index = i, minArea = bbox1 < minArea ? bbox1 : minArea) : overlap === minOverlap && bbox1 < minArea && (minArea = bbox1, index = i);
      }
      return index || M - m;
    }
    _chooseSplitAxis(node, m, M) {
      const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX);
      m = this._allDistMargin(node, m, M, compareMinY);
      xMargin < m && node.children.sort(compareMinX);
    }
    _allDistMargin(node, m, M, compare) {
      node.children.sort(compare);
      compare = this.toBBox;
      var leftBBox = distBBox(node, 0, m, compare);
      const rightBBox = distBBox(node, M - m, M, compare);
      let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
      for (let i = m; i < M - m; i++) {
        const child = node.children[i];
        extend(leftBBox, node.leaf ? compare(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (M = M - m - 1; M >= m; M--) {
        leftBBox = node.children[M], extend(rightBBox, node.leaf ? compare(leftBBox) : leftBBox), margin += bboxMargin(rightBBox);
      }
      return margin;
    }
    _adjustParentBBoxes(bbox, path, level) {
      for (; 0 <= level; level--) {
        extend(path[level], bbox);
      }
    }
    _condense(path) {
      for (let i = path.length - 1, siblings; 0 <= i; i--) {
        0 === path[i].children.length ? 0 < i ? (siblings = path[i - 1].children, siblings.splice(siblings.indexOf(path[i]), 1)) : this.clear() : calcBBox(path[i], this.toBBox);
      }
    }
  }
};

//# sourceMappingURL=module$node_modules$rbush$index.js.map
