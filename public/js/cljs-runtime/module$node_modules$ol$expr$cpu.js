shadow$provide.module$node_modules$ol$expr$cpu = function(global, require, module, exports) {
  function newEvaluationContext() {
    return {variables:{}, properties:{}, resolution:NaN, featureId:null, geometryType:""};
  }
  function buildExpression(encoded, type, context) {
    encoded = (0,require$_DOT__SLASH_expression_DOT_js.parse)(encoded, type, context);
    return compileExpression(encoded, context);
  }
  function compileExpression(expression, context) {
    if (expression instanceof require$_DOT__SLASH_expression_DOT_js.LiteralExpression) {
      if (expression.type === require$_DOT__SLASH_expression_DOT_js.ColorType && "string" === typeof expression.value) {
        const colorValue = (0,require$_DOT__DOT__SLASH_color_DOT_js.fromString)(expression.value);
        return function() {
          return colorValue;
        };
      }
      return function() {
        return expression.value;
      };
    }
    const operator = expression.operator;
    switch(operator) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.Number:
      case require$_DOT__SLASH_expression_DOT_js.Ops.String:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Coalesce:
        return compileAssertionExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Get:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Var:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Has:
        return compileAccessorExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Id:
        return context => context.featureId;
      case require$_DOT__SLASH_expression_DOT_js.Ops.GeometryType:
        return context => context.geometryType;
      case require$_DOT__SLASH_expression_DOT_js.Ops.Concat:
        const args = expression.args.map(e => compileExpression(e, context));
        return context => "".concat(...args.map(arg => arg(context).toString()));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Resolution:
        return context => context.resolution;
      case require$_DOT__SLASH_expression_DOT_js.Ops.Any:
      case require$_DOT__SLASH_expression_DOT_js.Ops.All:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Between:
      case require$_DOT__SLASH_expression_DOT_js.Ops.In:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Not:
        return compileLogicalExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Equal:
      case require$_DOT__SLASH_expression_DOT_js.Ops.NotEqual:
      case require$_DOT__SLASH_expression_DOT_js.Ops.LessThan:
      case require$_DOT__SLASH_expression_DOT_js.Ops.LessThanOrEqualTo:
      case require$_DOT__SLASH_expression_DOT_js.Ops.GreaterThan:
      case require$_DOT__SLASH_expression_DOT_js.Ops.GreaterThanOrEqualTo:
        return compileComparisonExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Multiply:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Divide:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Add:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Subtract:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Clamp:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Mod:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Pow:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Abs:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Floor:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Ceil:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Round:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Sin:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Cos:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Atan:
      case require$_DOT__SLASH_expression_DOT_js.Ops.Sqrt:
        return compileNumericExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Case:
        return compileCaseExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Match:
        return compileMatchExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Interpolate:
        return compileInterpolateExpression(expression, context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.ToString:
        return compileConvertExpression(expression, context);
      default:
        throw Error(`Unsupported operator ${operator}`);
    }
  }
  function compileAssertionExpression(expression, context) {
    const type = expression.operator, length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    switch(type) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.Coalesce:
        return context => {
          for (let i = 0; i < length; ++i) {
            const value = args[i](context);
            if ("undefined" !== typeof value && null !== value) {
              return value;
            }
          }
          throw Error("Expected one of the values to be non-null");
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Number:
      case require$_DOT__SLASH_expression_DOT_js.Ops.String:
        return context => {
          for (let i = 0; i < length; ++i) {
            const value = args[i](context);
            if (typeof value === type) {
              return value;
            }
          }
          throw Error(`Expected one of the values to be a ${type}`);
        };
      default:
        throw Error(`Unsupported assertion operator ${type}`);
    }
  }
  function compileAccessorExpression(expression, context) {
    const name = expression.args[0].value;
    switch(expression.operator) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.Get:
        return context => {
          const args = expression.args;
          context = context.properties[name];
          for (let i = 1, ii = args.length; i < ii; ++i) {
            context = context[args[i].value];
          }
          return context;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Var:
        return context => context.variables[name];
      case require$_DOT__SLASH_expression_DOT_js.Ops.Has:
        return context => {
          const args = expression.args;
          if (!(name in context.properties)) {
            return !1;
          }
          context = context.properties[name];
          for (let i = 1, ii = args.length; i < ii; ++i) {
            const key = args[i].value;
            if (!context || !Object.hasOwn(context, key)) {
              return !1;
            }
            context = context[key];
          }
          return !0;
        };
      default:
        throw Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
  function compileComparisonExpression(expression, context) {
    const op = expression.operator, left = compileExpression(expression.args[0], context), right = compileExpression(expression.args[1], context);
    switch(op) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.Equal:
        return context => left(context) === right(context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.NotEqual:
        return context => left(context) !== right(context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.LessThan:
        return context => left(context) < right(context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.LessThanOrEqualTo:
        return context => left(context) <= right(context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.GreaterThan:
        return context => left(context) > right(context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.GreaterThanOrEqualTo:
        return context => left(context) >= right(context);
      default:
        throw Error(`Unsupported comparison operator ${op}`);
    }
  }
  function compileLogicalExpression(expression, context) {
    const op = expression.operator, length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    switch(op) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.Any:
        return context => {
          for (let i = 0; i < length; ++i) {
            if (args[i](context)) {
              return !0;
            }
          }
          return !1;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.All:
        return context => {
          for (let i = 0; i < length; ++i) {
            if (!args[i](context)) {
              return !1;
            }
          }
          return !0;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Between:
        return context => {
          const value = args[0](context), min = args[1](context);
          context = args[2](context);
          return value >= min && value <= context;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.In:
        return context => {
          const value = args[0](context);
          for (let i = 1; i < length; ++i) {
            if (value === args[i](context)) {
              return !0;
            }
          }
          return !1;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Not:
        return context => !args[0](context);
      default:
        throw Error(`Unsupported logical operator ${op}`);
    }
  }
  function compileNumericExpression(expression, context) {
    const op = expression.operator, length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    switch(op) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.Multiply:
        return context => {
          let value = 1;
          for (let i = 0; i < length; ++i) {
            value *= args[i](context);
          }
          return value;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Divide:
        return context => args[0](context) / args[1](context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Add:
        return context => {
          let value = 0;
          for (let i = 0; i < length; ++i) {
            value += args[i](context);
          }
          return value;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Subtract:
        return context => args[0](context) - args[1](context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Clamp:
        return context => {
          const value = args[0](context), min = args[1](context);
          if (value < min) {
            return min;
          }
          context = args[2](context);
          return value > context ? context : value;
        };
      case require$_DOT__SLASH_expression_DOT_js.Ops.Mod:
        return context => args[0](context) % args[1](context);
      case require$_DOT__SLASH_expression_DOT_js.Ops.Pow:
        return context => Math.pow(args[0](context), args[1](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Abs:
        return context => Math.abs(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Floor:
        return context => Math.floor(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Ceil:
        return context => Math.ceil(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Round:
        return context => Math.round(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Sin:
        return context => Math.sin(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Cos:
        return context => Math.cos(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Atan:
        return 2 === length ? context => Math.atan2(args[0](context), args[1](context)) : context => Math.atan(args[0](context));
      case require$_DOT__SLASH_expression_DOT_js.Ops.Sqrt:
        return context => Math.sqrt(args[0](context));
      default:
        throw Error(`Unsupported numeric operator ${op}`);
    }
  }
  function compileCaseExpression(expression, context) {
    const length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    return context => {
      for (let i = 0; i < length - 1; i += 2) {
        if (args[i](context)) {
          return args[i + 1](context);
        }
      }
      return args[length - 1](context);
    };
  }
  function compileMatchExpression(expression, context) {
    const length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    return context => {
      const value = args[0](context);
      for (let i = 1; i < length; i += 2) {
        if (value === args[i](context)) {
          return args[i + 1](context);
        }
      }
      return args[length - 1](context);
    };
  }
  function compileInterpolateExpression(expression, context) {
    const length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    return context => {
      var base = args[0](context), value = args[1](context);
      for (var i = 2; i < length; i += 2) {
        var input = args[i](context), output = args[i + 1](context), isColor = Array.isArray(output);
        isColor && (output = (0,require$_DOT__DOT__SLASH_color_DOT_js.withAlpha)(output));
        if (input >= value) {
          return 2 === i ? output : isColor ? (context = base, 0 === input - previousInput ? context = previousOutput : (base = (0,require$_DOT__DOT__SLASH_color_DOT_js.rgbaToLcha)(previousOutput), i = (0,require$_DOT__DOT__SLASH_color_DOT_js.rgbaToLcha)(output), isColor = i[2] - base[2], 180 < isColor ? isColor -= 360 : -180 > isColor && (isColor += 360), context = [interpolateNumber(context, value, previousInput, base[0], input, i[0]), interpolateNumber(context, value, previousInput, base[1], input, 
          i[1]), base[2] + interpolateNumber(context, value, previousInput, 0, input, isColor), interpolateNumber(context, value, previousInput, previousOutput[3], input, output[3])], context = (0,require$_DOT__DOT__SLASH_color_DOT_js.normalize)((0,require$_DOT__DOT__SLASH_color_DOT_js.lchaToRgba)(context))), context) : interpolateNumber(base, value, previousInput, previousOutput, input, output);
        }
        var previousInput = input;
        var previousOutput = output;
      }
      return previousOutput;
    };
  }
  function compileConvertExpression(expression, context) {
    const op = expression.operator, length = expression.args.length, args = Array(length);
    for (let i = 0; i < length; ++i) {
      args[i] = compileExpression(expression.args[i], context);
    }
    switch(op) {
      case require$_DOT__SLASH_expression_DOT_js.Ops.ToString:
        return context => {
          context = args[0](context);
          return expression.args[0].type === require$_DOT__SLASH_expression_DOT_js.ColorType ? (0,require$_DOT__DOT__SLASH_color_DOT_js.toString)(context) : context.toString();
        };
      default:
        throw Error(`Unsupported convert operator ${op}`);
    }
  }
  function interpolateNumber(base, value, input1, output1, input2, output2) {
    input2 -= input1;
    if (0 === input2) {
      return output1;
    }
    value -= input1;
    return output1 + (1 === base ? value / input2 : (Math.pow(base, value) - 1) / (Math.pow(base, input2) - 1)) * (output2 - output1);
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, buildExpression:{enumerable:!0, get:function() {
    return buildExpression;
  }}, newEvaluationContext:{enumerable:!0, get:function() {
    return newEvaluationContext;
  }}});
  var require$_DOT__DOT__SLASH_color_DOT_js = require("module$node_modules$ol$color"), require$_DOT__SLASH_expression_DOT_js = require("module$node_modules$ol$expr$expression");
};

//# sourceMappingURL=module$node_modules$ol$expr$cpu.js.map
