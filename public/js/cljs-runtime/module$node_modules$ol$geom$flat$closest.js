shadow$provide.module$node_modules$ol$geom$flat$closest = function(global, require, module, exports) {
  function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    const x1 = flatCoordinates[offset1], y1 = flatCoordinates[offset1 + 1], dx = flatCoordinates[offset2] - x1, dy = flatCoordinates[offset2 + 1] - y1;
    if (0 !== dx || 0 !== dy) {
      if (x = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 1 < x) {
        offset1 = offset2;
      } else if (0 < x) {
        for (y = 0; y < stride; ++y) {
          closestPoint[y] = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.lerp)(flatCoordinates[offset1 + y], flatCoordinates[offset2 + y], x);
        }
        closestPoint.length = stride;
        return;
      }
    }
    for (offset2 = 0; offset2 < stride; ++offset2) {
      closestPoint[offset2] = flatCoordinates[offset1 + offset2];
    }
    closestPoint.length = stride;
  }
  function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    var x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    for (offset += stride; offset < end; offset += stride) {
      const x2 = flatCoordinates[offset], y2 = flatCoordinates[offset + 1];
      x1 = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredDistance)(x1, y1, x2, y2);
      x1 > max && (max = x1);
      x1 = x2;
      y1 = y2;
    }
    return max;
  }
  function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
      offset = end;
    }
    return max;
  }
  function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i];
      max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
      offset = ends[ends.length - 1];
    }
    return max;
  }
  function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    if (offset == end) {
      return minSquaredDistance;
    }
    let i, squaredDistance;
    if (0 === maxDelta) {
      squaredDistance = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
      if (squaredDistance < minSquaredDistance) {
        for (i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[offset + i];
        }
        closestPoint.length = stride;
        return squaredDistance;
      }
      return minSquaredDistance;
    }
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    let index = offset + stride;
    for (; index < end;) {
      if (assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint), squaredDistance = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]), squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;
        for (i = 0; i < stride; ++i) {
          closestPoint[i] = tmpPoint[i];
        }
        closestPoint.length = stride;
        index += stride;
      } else {
        index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
      }
    }
    if (isRing && (assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint), squaredDistance = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]), squaredDistance < minSquaredDistance)) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
    return minSquaredDistance;
  }
  function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
      offset = end;
    }
    return minSquaredDistance;
  }
  function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i];
      minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
      offset = ends[ends.length - 1];
    }
    return minSquaredDistance;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, arrayMaxSquaredDelta:{enumerable:!0, get:function() {
    return arrayMaxSquaredDelta;
  }}, assignClosestArrayPoint:{enumerable:!0, get:function() {
    return assignClosestArrayPoint;
  }}, assignClosestMultiArrayPoint:{enumerable:!0, get:function() {
    return assignClosestMultiArrayPoint;
  }}, assignClosestPoint:{enumerable:!0, get:function() {
    return assignClosestPoint;
  }}, maxSquaredDelta:{enumerable:!0, get:function() {
    return maxSquaredDelta;
  }}, multiArrayMaxSquaredDelta:{enumerable:!0, get:function() {
    return multiArrayMaxSquaredDelta;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math");
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$closest.js.map
