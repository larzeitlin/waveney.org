shadow$provide.module$node_modules$ol$geom$MultiPoint = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math");
  global = require("module$node_modules$ol$geom$Point");
  module = require("module$node_modules$ol$geom$SimpleGeometry");
  var require$_DOT__SLASH_flat_SLASH_deflate_DOT_js = require("module$node_modules$ol$geom$flat$deflate"), require$_DOT__SLASH_flat_SLASH_inflate_DOT_js = require("module$node_modules$ol$geom$flat$inflate");
  module = require.esmDefault(module);
  var default$$require$_DOT__SLASH_Point_DOT_js = require.esmDefault(global);
  class MultiPoint extends module.default {
    constructor(coordinates, layout) {
      super();
      layout && !Array.isArray(coordinates[0]) ? this.setFlatCoordinates(layout, coordinates) : this.setCoordinates(coordinates, layout);
    }
    appendPoint(point) {
      (0,require$_DOT__DOT__SLASH_array_DOT_js.extend)(this.flatCoordinates, point.getFlatCoordinates());
      this.changed();
    }
    clone() {
      const multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
      multiPoint.applyProperties(this);
      return multiPoint;
    }
    closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0,require$_DOT__DOT__SLASH_extent_DOT_js.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      const flatCoordinates = this.flatCoordinates, stride = this.stride;
      for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        var squaredDistance = (0,require$_DOT__DOT__SLASH_math_DOT_js.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
        if (squaredDistance < minSquaredDistance) {
          minSquaredDistance = squaredDistance;
          for (squaredDistance = 0; squaredDistance < stride; ++squaredDistance) {
            closestPoint[squaredDistance] = flatCoordinates[i + squaredDistance];
          }
          closestPoint.length = stride;
        }
      }
      return minSquaredDistance;
    }
    getCoordinates() {
      return (0,require$_DOT__SLASH_flat_SLASH_inflate_DOT_js.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    getPoint(index) {
      const n = this.flatCoordinates.length / this.stride;
      return 0 > index || n <= index ? null : new default$$require$_DOT__SLASH_Point_DOT_js.default(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    }
    getPoints() {
      const flatCoordinates = this.flatCoordinates, layout = this.layout, stride = this.stride, points = [];
      for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        const point = new default$$require$_DOT__SLASH_Point_DOT_js.default(flatCoordinates.slice(i, i + stride), layout);
        points.push(point);
      }
      return points;
    }
    getType() {
      return "MultiPoint";
    }
    intersectsExtent(extent) {
      const flatCoordinates = this.flatCoordinates, stride = this.stride;
      for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
        if ((0,require$_DOT__DOT__SLASH_extent_DOT_js.containsXY)(extent, flatCoordinates[i], flatCoordinates[i + 1])) {
          return !0;
        }
      }
      return !1;
    }
    setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 1);
      this.flatCoordinates || (this.flatCoordinates = []);
      this.flatCoordinates.length = (0,require$_DOT__SLASH_flat_SLASH_deflate_DOT_js.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
      this.changed();
    }
  }
  const $$default = MultiPoint;
};

//# sourceMappingURL=module$node_modules$ol$geom$MultiPoint.js.map
