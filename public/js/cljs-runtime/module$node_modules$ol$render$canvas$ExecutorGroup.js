shadow$provide.module$node_modules$ol$render$canvas$ExecutorGroup = function(global, require, module, exports) {
  function getPixelIndexArray(radius) {
    if (void 0 !== circlePixelIndexArrayCache[radius]) {
      return circlePixelIndexArrayCache[radius];
    }
    var size = 2 * radius + 1;
    const maxDistanceSq = radius * radius, distances = Array(maxDistanceSq + 1);
    for (let i = 0; i <= radius; ++i) {
      for (let j = 0; j <= radius; ++j) {
        const distanceSq = i * i + j * j;
        if (distanceSq > maxDistanceSq) {
          break;
        }
        let distance = distances[distanceSq];
        distance || (distance = [], distances[distanceSq] = distance);
        distance.push(4 * ((radius + i) * size + (radius + j)) + 3);
        0 < i && distance.push(4 * ((radius - i) * size + (radius + j)) + 3);
        0 < j && (distance.push(4 * ((radius + i) * size + (radius - j)) + 3), 0 < i && distance.push(4 * ((radius - i) * size + (radius - j)) + 3));
      }
    }
    size = [];
    for (let i = 0, ii = distances.length; i < ii; ++i) {
      distances[i] && size.push(...distances[i]);
    }
    return circlePixelIndexArrayCache[radius] = size;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, ALL:{enumerable:!0, get:function() {
    return ALL;
  }}, DECLUTTER:{enumerable:!0, get:function() {
    return DECLUTTER;
  }}, NON_DECLUTTER:{enumerable:!0, get:function() {
    return NON_DECLUTTER;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}, getPixelIndexArray:{enumerable:!0, get:function() {
    return getPixelIndexArray;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js = require("module$node_modules$ol$geom$flat$transform"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_obj_DOT_js = require("module$node_modules$ol$obj"), 
  require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform");
  global = require("module$node_modules$ol$render$canvas$Executor");
  var default$$require$_DOT__SLASH_Executor_DOT_js = require.esmDefault(global);
  const ALL = "Polygon Circle LineString Image Text Default".split(" "), DECLUTTER = ["Image", "Text"], NON_DECLUTTER = ALL.filter(builderType => !DECLUTTER.includes(builderType));
  class ExecutorGroup {
    constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer, deferredRendering) {
      this.maxExtent_ = maxExtent;
      this.overlaps_ = overlaps;
      this.pixelRatio_ = pixelRatio;
      this.resolution_ = resolution;
      this.renderBuffer_ = renderBuffer;
      this.executorsByZIndex_ = {};
      this.hitDetectionContext_ = null;
      this.hitDetectionTransform_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)();
      this.renderedContext_ = null;
      this.deferredZIndexContexts_ = {};
      this.createExecutors_(allInstructions, deferredRendering);
    }
    clip(context, transform) {
      transform = this.getClipCoords(transform);
      context.beginPath();
      context.moveTo(transform[0], transform[1]);
      context.lineTo(transform[2], transform[3]);
      context.lineTo(transform[4], transform[5]);
      context.lineTo(transform[6], transform[7]);
      context.clip();
    }
    createExecutors_(allInstructions, deferredRendering) {
      for (const zIndex in allInstructions) {
        let executors = this.executorsByZIndex_[zIndex];
        void 0 === executors && (executors = {}, this.executorsByZIndex_[zIndex] = executors);
        const instructionByZindex = allInstructions[zIndex];
        for (const builderType in instructionByZindex) {
          executors[builderType] = new default$$require$_DOT__SLASH_Executor_DOT_js.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructionByZindex[builderType], deferredRendering);
        }
      }
    }
    hasExecutors(executors) {
      for (const zIndex in this.executorsByZIndex_) {
        const candidates = this.executorsByZIndex_[zIndex];
        for (let i = 0, ii = executors.length; i < ii; ++i) {
          if (executors[i] in candidates) {
            return !0;
          }
        }
      }
      return !1;
    }
    forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
      function featureCallback(feature, geometry, declutterMode) {
        var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
        for (let i = 0, ii = indexes.length; i < ii; i++) {
          if (0 < imageData[indexes[i]]) {
            if (!declutteredFeatures || "none" === declutterMode || "Image" !== builderType && "Text" !== builderType || declutteredFeatures.includes(feature)) {
              if (imageData = (indexes[i] - 3) / 4, declutterMode = hitTolerance - imageData % contextSize, imageData = hitTolerance - (imageData / contextSize | 0), feature = callback(feature, geometry, declutterMode * declutterMode + imageData * imageData)) {
                return feature;
              }
            }
            context.clearRect(0, 0, contextSize, contextSize);
            break;
          }
        }
      }
      hitTolerance = Math.round(hitTolerance);
      const contextSize = 2 * hitTolerance + 1, transform = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
      var newContext = !this.hitDetectionContext_;
      newContext && (this.hitDetectionContext_ = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(contextSize, contextSize, void 0, {willReadFrequently:!0}));
      const context = this.hitDetectionContext_;
      context.canvas.width !== contextSize || context.canvas.height !== contextSize ? (context.canvas.width = contextSize, context.canvas.height = contextSize) : newContext || context.clearRect(0, 0, contextSize, contextSize);
      let hitExtent;
      void 0 !== this.renderBuffer_ && (hitExtent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.createEmpty)(), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.extendCoordinate)(hitExtent, coordinate), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent));
      const indexes = getPixelIndexArray(hitTolerance);
      let builderType;
      coordinate = Object.keys(this.executorsByZIndex_).map(Number);
      coordinate.sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.ascending);
      let executors;
      for (resolution = coordinate.length - 1; 0 <= resolution; --resolution) {
        for (executors = this.executorsByZIndex_[coordinate[resolution].toString()], newContext = ALL.length - 1; 0 <= newContext; --newContext) {
          builderType = ALL[newContext];
          var executor = executors[builderType];
          if (void 0 !== executor && (executor = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent))) {
            return executor;
          }
        }
      }
    }
    getClipCoords(transform) {
      var maxExtent = this.maxExtent_;
      if (!maxExtent) {
        return null;
      }
      var minX = maxExtent[0];
      const minY = maxExtent[1], maxX = maxExtent[2];
      maxExtent = maxExtent[3];
      minX = [minX, minY, minX, maxExtent, maxX, maxExtent, maxX, minY];
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_geom_SLASH_flat_SLASH_transform_DOT_js.transform2D)(minX, 0, 8, 2, transform, minX);
      return minX;
    }
    isEmpty() {
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_obj_DOT_js.isEmpty)(this.executorsByZIndex_);
    }
    execute(targetContext, scaledCanvasSize, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {
      const zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(declutterTree ? require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.descending : require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.ascending);
      builderTypes = builderTypes ? builderTypes : ALL;
      const maxBuilderTypes = ALL.length;
      for (let i = 0, ii = zs.length; i < ii; ++i) {
        const replays = this.executorsByZIndex_[zs[i].toString()];
        for (let j = 0, jj = builderTypes.length; j < jj; ++j) {
          var builderType = builderTypes[j];
          const replay = replays[builderType];
          if (void 0 !== replay) {
            const zIndexContext = null === declutterTree ? void 0 : replay.getZIndexContext(), context = zIndexContext ? zIndexContext.getContext() : targetContext, requireClip = this.maxExtent_ && "Image" !== builderType && "Text" !== builderType;
            requireClip && (context.save(), this.clip(context, transform));
            zIndexContext && "Text" !== builderType && "Image" !== builderType ? zIndexContext.pushFunction(context => replay.execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree)) : replay.execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree);
            requireClip && context.restore();
            zIndexContext && (zIndexContext.offset(), builderType = zs[i] * maxBuilderTypes + j, this.deferredZIndexContexts_[builderType] || (this.deferredZIndexContexts_[builderType] = []), this.deferredZIndexContexts_[builderType].push(zIndexContext));
          }
        }
      }
      this.renderedContext_ = targetContext;
    }
    getDeferredZIndexContexts() {
      return this.deferredZIndexContexts_;
    }
    getRenderedContext() {
      return this.renderedContext_;
    }
    renderDeferred() {
      const deferredZIndexContexts = this.deferredZIndexContexts_, zs = Object.keys(deferredZIndexContexts).map(Number).sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.ascending);
      for (let i = 0, ii = zs.length; i < ii; ++i) {
        deferredZIndexContexts[zs[i]].forEach(zIndexContext => {
          zIndexContext.draw(this.renderedContext_);
          zIndexContext.clear();
        }), deferredZIndexContexts[zs[i]].length = 0;
      }
    }
  }
  const circlePixelIndexArrayCache = {}, $$default = ExecutorGroup;
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$ExecutorGroup.js.map
