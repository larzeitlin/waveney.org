shadow$provide.module$node_modules$ol$style$RegularShape = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  module = require("module$node_modules$ol$ImageState");
  var require$_DOT__DOT__SLASH_color_DOT_js = require("module$node_modules$ol$color"), require$_DOT__DOT__SLASH_colorlike_DOT_js = require("module$node_modules$ol$colorlike"), require$_DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js = require("module$node_modules$ol$render$canvas");
  global = require("module$node_modules$ol$style$IconImage");
  var require$_DOT__SLASH_IconImageCache_DOT_js = require("module$node_modules$ol$style$IconImageCache");
  exports = require("module$node_modules$ol$style$Image");
  var default$$require$_DOT__DOT__SLASH_ImageState_DOT_js = require.esmDefault(module);
  module = require.esmDefault(exports);
  var default$$require$_DOT__SLASH_IconImage_DOT_js = require.esmDefault(global);
  class RegularShape extends module.default {
    constructor(options) {
      super({opacity:1, rotateWithView:void 0 !== options.rotateWithView ? options.rotateWithView : !1, rotation:void 0 !== options.rotation ? options.rotation : 0, scale:void 0 !== options.scale ? options.scale : 1, displacement:void 0 !== options.displacement ? options.displacement : [0, 0], declutterMode:options.declutterMode});
      this.hitDetectionCanvas_ = null;
      this.fill_ = void 0 !== options.fill ? options.fill : null;
      this.origin_ = [0, 0];
      this.points_ = options.points;
      this.radius = options.radius;
      this.radius2_ = options.radius2;
      this.angle_ = void 0 !== options.angle ? options.angle : 0;
      this.stroke_ = void 0 !== options.stroke ? options.stroke : null;
      this.size_;
      this.renderOptions_;
      this.imageState_ = this.fill_ && this.fill_.loading() ? default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADING : default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADED;
      this.imageState_ === default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADING && this.ready().then(() => this.imageState_ = default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADED);
      this.render();
    }
    clone() {
      var scale = this.getScale();
      scale = new RegularShape({fill:this.getFill() ? this.getFill().clone() : void 0, points:this.getPoints(), radius:this.getRadius(), radius2:this.getRadius2(), angle:this.getAngle(), stroke:this.getStroke() ? this.getStroke().clone() : void 0, rotation:this.getRotation(), rotateWithView:this.getRotateWithView(), scale:Array.isArray(scale) ? scale.slice() : scale, displacement:this.getDisplacement().slice(), declutterMode:this.getDeclutterMode()});
      scale.setOpacity(this.getOpacity());
      return scale;
    }
    getAnchor() {
      const size = this.size_, displacement = this.getDisplacement(), scale = this.getScaleArray();
      return [size[0] / 2 - displacement[0] / scale[0], size[1] / 2 + displacement[1] / scale[1]];
    }
    getAngle() {
      return this.angle_;
    }
    getFill() {
      return this.fill_;
    }
    setFill(fill) {
      this.fill_ = fill;
      this.render();
    }
    getHitDetectionImage() {
      this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_));
      return this.hitDetectionCanvas_;
    }
    getImage(pixelRatio) {
      var fillKey = this.fill_?.getKey();
      fillKey = `${pixelRatio},${this.angle_},${this.radius},${this.radius2_},${this.points_},${fillKey}` + Object.values(this.renderOptions_).join(",");
      var image = require$_DOT__SLASH_IconImageCache_DOT_js.shared.get(fillKey, null, null)?.getImage(1);
      if (!image) {
        image = this.renderOptions_;
        var size = Math.ceil(image.size * pixelRatio);
        size = (0,require$_DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(size, size);
        this.draw_(image, size, pixelRatio);
        image = size.canvas;
        require$_DOT__SLASH_IconImageCache_DOT_js.shared.set(fillKey, null, null, new default$$require$_DOT__SLASH_IconImage_DOT_js.default(image, void 0, null, default$$require$_DOT__DOT__SLASH_ImageState_DOT_js.default.LOADED, null));
      }
      return image;
    }
    getPixelRatio(pixelRatio) {
      return pixelRatio;
    }
    getImageSize() {
      return this.size_;
    }
    getImageState() {
      return this.imageState_;
    }
    getOrigin() {
      return this.origin_;
    }
    getPoints() {
      return this.points_;
    }
    getRadius() {
      return this.radius;
    }
    getRadius2() {
      return this.radius2_;
    }
    getSize() {
      return this.size_;
    }
    getStroke() {
      return this.stroke_;
    }
    setStroke(stroke) {
      this.stroke_ = stroke;
      this.render();
    }
    listenImageChange(listener) {
    }
    load() {
    }
    unlistenImageChange(listener) {
    }
    calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
      if (0 === strokeWidth || Infinity === this.points_ || "bevel" !== lineJoin && "miter" !== lineJoin) {
        return strokeWidth;
      }
      let r1 = this.radius, r2 = void 0 === this.radius2_ ? r1 : this.radius2_;
      if (r1 < r2) {
        var tmp = r1;
        r1 = r2;
        r2 = tmp;
      }
      tmp = 2 * Math.PI / (void 0 === this.radius2_ ? this.points_ : 2 * this.points_);
      var a = r2 * Math.sin(tmp), d = r1 - Math.sqrt(r2 * r2 - a * a);
      const e = Math.sqrt(a * a + d * d);
      a = e / a;
      if ("miter" === lineJoin && a <= miterLimit) {
        return a * strokeWidth;
      }
      a = strokeWidth / 2 / a;
      d = strokeWidth / 2 * (d / e);
      d = Math.sqrt((r1 + a) * (r1 + a) + d * d) - r1;
      if (void 0 === this.radius2_ || "bevel" === lineJoin) {
        return 2 * d;
      }
      lineJoin = r1 * Math.sin(tmp);
      tmp = r2 - Math.sqrt(r1 * r1 - lineJoin * lineJoin);
      lineJoin = Math.sqrt(lineJoin * lineJoin + tmp * tmp) / lineJoin;
      return lineJoin <= miterLimit ? 2 * Math.max(d, lineJoin * strokeWidth / 2 - r2 - r1) : 2 * d;
    }
    createRenderOptions() {
      let lineCap = require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultLineCap, lineJoin = require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultLineJoin, miterLimit = 0, lineDash = null, lineDashOffset = 0, strokeStyle, strokeWidth = 0;
      this.stroke_ && (strokeStyle = (0,require$_DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(this.stroke_.getColor() ?? require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultStrokeStyle), strokeWidth = this.stroke_.getWidth() ?? require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultLineWidth, lineDash = this.stroke_.getLineDash(), lineDashOffset = this.stroke_.getLineDashOffset() ?? 0, lineJoin = this.stroke_.getLineJoin() ?? require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultLineJoin, 
      lineCap = this.stroke_.getLineCap() ?? require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultLineCap, miterLimit = this.stroke_.getMiterLimit() ?? require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultMiterLimit);
      const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
      return {strokeStyle, strokeWidth, size:Math.ceil(2 * Math.max(this.radius, this.radius2_ || 0) + add), lineCap, lineDash, lineDashOffset, lineJoin, miterLimit};
    }
    render() {
      this.renderOptions_ = this.createRenderOptions();
      const size = this.renderOptions_.size;
      this.hitDetectionCanvas_ = null;
      this.size_ = [size, size];
    }
    draw_(renderOptions, context, pixelRatio) {
      context.scale(pixelRatio, pixelRatio);
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      this.fill_ && (pixelRatio = this.fill_.getColor(), null === pixelRatio && (pixelRatio = require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultFillStyle), context.fillStyle = (0,require$_DOT__DOT__SLASH_colorlike_DOT_js.asColorLike)(pixelRatio), context.fill());
      renderOptions.strokeStyle && (context.strokeStyle = renderOptions.strokeStyle, context.lineWidth = renderOptions.strokeWidth, renderOptions.lineDash && (context.setLineDash(renderOptions.lineDash), context.lineDashOffset = renderOptions.lineDashOffset), context.lineCap = renderOptions.lineCap, context.lineJoin = renderOptions.lineJoin, context.miterLimit = renderOptions.miterLimit, context.stroke());
    }
    createHitDetectionCanvas_(renderOptions) {
      let context;
      if (this.fill_) {
        let color = this.fill_.getColor(), opacity = 0;
        "string" === typeof color && (color = (0,require$_DOT__DOT__SLASH_color_DOT_js.asArray)(color));
        null === color ? opacity = 1 : Array.isArray(color) && (opacity = 4 === color.length ? color[3] : 1);
        0 === opacity && (context = (0,require$_DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(renderOptions.size, renderOptions.size), this.drawHitDetectionCanvas_(renderOptions, context));
      }
      return context ? context.canvas : this.getImage(1);
    }
    createPath_(context) {
      let points = this.points_;
      const radius = this.radius;
      if (Infinity === points) {
        context.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        const radius2 = void 0 === this.radius2_ ? radius : this.radius2_;
        void 0 !== this.radius2_ && (points *= 2);
        const startAngle = this.angle_ - Math.PI / 2, step = 2 * Math.PI / points;
        for (let i = 0; i < points; i++) {
          const angle0 = startAngle + i * step, radiusC = 0 === i % 2 ? radius : radius2;
          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
        }
        context.closePath();
      }
    }
    drawHitDetectionCanvas_(renderOptions, context) {
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      context.fillStyle = require$_DOT__DOT__SLASH_render_SLASH_canvas_DOT_js.defaultFillStyle;
      context.fill();
      renderOptions.strokeStyle && (context.strokeStyle = renderOptions.strokeStyle, context.lineWidth = renderOptions.strokeWidth, renderOptions.lineDash && (context.setLineDash(renderOptions.lineDash), context.lineDashOffset = renderOptions.lineDashOffset), context.lineJoin = renderOptions.lineJoin, context.miterLimit = renderOptions.miterLimit, context.stroke());
    }
    ready() {
      return this.fill_ ? this.fill_.ready() : Promise.resolve();
    }
  }
  const $$default = RegularShape;
};

//# sourceMappingURL=module$node_modules$ol$style$RegularShape.js.map
