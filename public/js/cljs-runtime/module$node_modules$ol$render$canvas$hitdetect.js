shadow$provide.module$node_modules$ol$render$canvas$hitdetect = function(global, require, module, exports) {
  function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation, squaredTolerance, projection) {
    const userExtent = projection ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.toUserExtent)(extent, projection) : extent;
    size = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(0.5 * size[0], 0.5 * size[1]);
    size.imageSmoothingEnabled = !1;
    const canvas = size.canvas;
    extent = new default$$require$_DOT__SLASH_Immediate_DOT_js.default(size, 0.5, extent, null, rotation, squaredTolerance, projection ? (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getTransformFromProjections)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js.getUserProjection)(), projection) : null);
    squaredTolerance = features.length;
    projection = Math.floor(16777215 / squaredTolerance);
    rotation = {};
    for (let i = 1; i <= squaredTolerance; ++i) {
      const feature = features[i - 1];
      var featureStyleFunction = feature.getStyleFunction() || styleFunction;
      if (!featureStyleFunction) {
        continue;
      }
      featureStyleFunction = featureStyleFunction(feature, resolution);
      if (!featureStyleFunction) {
        continue;
      }
      Array.isArray(featureStyleFunction) || (featureStyleFunction = [featureStyleFunction]);
      const color = (i * projection).toString(16).padStart(7, "#00000");
      for (let j = 0, jj = featureStyleFunction.length; j < jj; ++j) {
        var originalStyle = featureStyleFunction[j], geometry = originalStyle.getGeometryFunction()(feature);
        if (!geometry || !(0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.intersects)(userExtent, geometry.getExtent())) {
          continue;
        }
        const style = originalStyle.clone();
        var fill = style.getFill();
        fill && fill.setColor(color);
        if (fill = style.getStroke()) {
          fill.setColor(color), fill.setLineDash(null);
        }
        style.setText(void 0);
        if (originalStyle = originalStyle.getImage()) {
          fill = originalStyle.getImageSize();
          if (!fill) {
            continue;
          }
          fill = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(fill[0], fill[1], void 0, {alpha:!1});
          const img = fill.canvas;
          fill.fillStyle = color;
          fill.fillRect(0, 0, img.width, img.height);
          style.setImage(new require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_DOT_js.Icon({img, anchor:originalStyle.getAnchor(), anchorXUnits:"pixels", anchorYUnits:"pixels", offset:originalStyle.getOrigin(), opacity:1, size:originalStyle.getSize(), scale:originalStyle.getScale(), rotation:originalStyle.getRotation(), rotateWithView:originalStyle.getRotateWithView()}));
        }
        fill = style.getZIndex() || 0;
        originalStyle = rotation[fill];
        originalStyle || (originalStyle = {}, rotation[fill] = originalStyle, originalStyle.Polygon = [], originalStyle.Circle = [], originalStyle.LineString = [], originalStyle.Point = []);
        fill = geometry.getType();
        if ("GeometryCollection" === fill) {
          geometry = geometry.getGeometriesArrayRecursive();
          for (let i = 0, ii = geometry.length; i < ii; ++i) {
            fill = geometry[i], originalStyle[fill.getType().replace("Multi", "")].push(fill, style);
          }
        } else {
          originalStyle[fill.replace("Multi", "")].push(geometry, style);
        }
      }
    }
    features = Object.keys(rotation).map(Number).sort(require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.ascending);
    for (let i = 0, ii = features.length; i < ii; ++i) {
      styleFunction = rotation[features[i]];
      for (const type in styleFunction) {
        resolution = styleFunction[type];
        for (let j = 0, jj = resolution.length; j < jj; j += 2) {
          extent.setStyle(resolution[j + 1]);
          for (let k = 0, kk = transforms.length; k < kk; ++k) {
            extent.setTransform(transforms[k]), extent.drawGeometry(resolution[j]);
          }
        }
      }
    }
    return size.getImageData(0, 0, canvas.width, canvas.height);
  }
  function hitDetect(pixel, features, imageData) {
    const resultFeatures = [];
    if (imageData) {
      const y = Math.floor(0.5 * Math.round(pixel[1]));
      pixel = 4 * ((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.clamp)(Math.floor(0.5 * Math.round(pixel[0])), 0, imageData.width - 1) + (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js.clamp)(y, 0, imageData.height - 1) * imageData.width);
      imageData = imageData.data[pixel + 2] + 256 * (imageData.data[pixel + 1] + 256 * imageData.data[pixel]);
      pixel = Math.floor(16777215 / features.length);
      imageData && 0 === imageData % pixel && resultFeatures.push(features[imageData / pixel - 1]);
    }
    return resultFeatures;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, HIT_DETECT_RESOLUTION:{enumerable:!0, get:function() {
    return 0.5;
  }}, createHitDetectionImageData:{enumerable:!0, get:function() {
    return createHitDetectionImageData;
  }}, hitDetect:{enumerable:!0, get:function() {
    return hitDetect;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_style_DOT_js = 
  require("module$node_modules$ol$style");
  global = require("module$node_modules$ol$render$canvas$Immediate");
  var default$$require$_DOT__SLASH_Immediate_DOT_js = require.esmDefault(global);
};

//# sourceMappingURL=module$node_modules$ol$render$canvas$hitdetect.js.map
