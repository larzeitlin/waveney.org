shadow$provide.module$node_modules$ol$extent = function(global, require, module, exports) {
  function boundingExtent(coordinates) {
    const extent = createEmpty();
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      extendCoordinate(extent, coordinates[i]);
    }
    return extent;
  }
  function buffer(extent, value, dest) {
    return dest ? (dest[0] = extent[0] - value, dest[1] = extent[1] - value, dest[2] = extent[2] + value, dest[3] = extent[3] + value, dest) : [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
  function clone(extent, dest) {
    return dest ? (dest[0] = extent[0], dest[1] = extent[1], dest[2] = extent[2], dest[3] = extent[3], dest) : extent.slice();
  }
  function closestSquaredDistanceXY(extent, x, y) {
    x = x < extent[0] ? extent[0] - x : extent[2] < x ? x - extent[2] : 0;
    extent = y < extent[1] ? extent[1] - y : extent[3] < y ? y - extent[3] : 0;
    return x * x + extent * extent;
  }
  function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
  }
  function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
  }
  function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
  }
  function coordinateRelationship(extent, coordinate) {
    const minY = extent[1], maxX = extent[2], maxY = extent[3], x = coordinate[0];
    coordinate = coordinate[1];
    let relationship = default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.UNKNOWN;
    x < extent[0] ? relationship |= default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.LEFT : x > maxX && (relationship |= default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.RIGHT);
    coordinate < minY ? relationship |= default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.BELOW : coordinate > maxY && (relationship |= default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.ABOVE);
    relationship === default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.UNKNOWN && (relationship = default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.INTERSECTING);
    return relationship;
  }
  function createEmpty() {
    return [Infinity, Infinity, -Infinity, -Infinity];
  }
  function createOrUpdate(minX, minY, maxX, maxY, dest) {
    return dest ? (dest[0] = minX, dest[1] = minY, dest[2] = maxX, dest[3] = maxY, dest) : [minX, minY, maxX, maxY];
  }
  function createOrUpdateEmpty(dest) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
  }
  function createOrUpdateFromCoordinate(coordinate, dest) {
    const x = coordinate[0];
    coordinate = coordinate[1];
    return createOrUpdate(x, coordinate, x, coordinate, dest);
  }
  function createOrUpdateFromCoordinates(coordinates, dest) {
    dest = createOrUpdateEmpty(dest);
    return extendCoordinates(dest, coordinates);
  }
  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
    dest = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(dest, flatCoordinates, offset, end, stride);
  }
  function createOrUpdateFromRings(rings, dest) {
    dest = createOrUpdateEmpty(dest);
    return extendRings(dest, rings);
  }
  function equals(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
  }
  function approximatelyEquals(extent1, extent2, tolerance) {
    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
  }
  function extend(extent1, extent2) {
    extent2[0] < extent1[0] && (extent1[0] = extent2[0]);
    extent2[2] > extent1[2] && (extent1[2] = extent2[2]);
    extent2[1] < extent1[1] && (extent1[1] = extent2[1]);
    extent2[3] > extent1[3] && (extent1[3] = extent2[3]);
    return extent1;
  }
  function extendCoordinate(extent, coordinate) {
    coordinate[0] < extent[0] && (extent[0] = coordinate[0]);
    coordinate[0] > extent[2] && (extent[2] = coordinate[0]);
    coordinate[1] < extent[1] && (extent[1] = coordinate[1]);
    coordinate[1] > extent[3] && (extent[3] = coordinate[1]);
  }
  function extendCoordinates(extent, coordinates) {
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      extendCoordinate(extent, coordinates[i]);
    }
    return extent;
  }
  function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for (; offset < end; offset += stride) {
      extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    }
    return extent;
  }
  function extendRings(extent, rings) {
    for (let i = 0, ii = rings.length; i < ii; ++i) {
      extendCoordinates(extent, rings[i]);
    }
    return extent;
  }
  function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
  }
  function forEachCorner(extent, callback) {
    let val;
    return (val = callback(getBottomLeft(extent))) || (val = callback(getBottomRight(extent))) || (val = callback(getTopRight(extent))) ? val : (val = callback(getTopLeft(extent))) ? val : !1;
  }
  function getArea(extent) {
    let area = 0;
    isEmpty(extent) || (area = getWidth(extent) * getHeight(extent));
    return area;
  }
  function getBottomLeft(extent) {
    return [extent[0], extent[1]];
  }
  function getBottomRight(extent) {
    return [extent[2], extent[1]];
  }
  function getCenter(extent) {
    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  function getCorner(extent, corner) {
    if ("bottom-left" === corner) {
      extent = getBottomLeft(extent);
    } else if ("bottom-right" === corner) {
      extent = getBottomRight(extent);
    } else if ("top-left" === corner) {
      extent = getTopLeft(extent);
    } else if ("top-right" === corner) {
      extent = getTopRight(extent);
    } else {
      throw Error("Invalid corner");
    }
    return extent;
  }
  function getEnlargedArea(extent1, extent2) {
    return (Math.max(extent1[2], extent2[2]) - Math.min(extent1[0], extent2[0])) * (Math.max(extent1[3], extent2[3]) - Math.min(extent1[1], extent2[1]));
  }
  function getForViewAndSize(center, resolution, rotation, size, dest) {
    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
  }
  function getRotatedViewport(center, resolution, rotation, size) {
    var dx = resolution * size[0] / 2;
    resolution = resolution * size[1] / 2;
    size = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    rotation = dx * size;
    dx *= sinRotation;
    size *= resolution;
    resolution *= sinRotation;
    sinRotation = center[0];
    center = center[1];
    return [sinRotation - rotation + resolution, center - dx - size, sinRotation - rotation - resolution, center - dx + size, sinRotation + rotation - resolution, center + dx + size, sinRotation + rotation + resolution, center + dx - size, sinRotation - rotation + resolution, center - dx - size];
  }
  function getHeight(extent) {
    return extent[3] - extent[1];
  }
  function getIntersectionArea(extent1, extent2) {
    extent1 = getIntersection(extent1, extent2);
    return getArea(extent1);
  }
  function getIntersection(extent1, extent2, dest) {
    dest = dest ? dest : createEmpty();
    intersects(extent1, extent2) ? (dest[0] = extent1[0] > extent2[0] ? extent1[0] : extent2[0], dest[1] = extent1[1] > extent2[1] ? extent1[1] : extent2[1], dest[2] = extent1[2] < extent2[2] ? extent1[2] : extent2[2], dest[3] = extent1[3] < extent2[3] ? extent1[3] : extent2[3]) : createOrUpdateEmpty(dest);
    return dest;
  }
  function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
  }
  function getSize(extent) {
    return [extent[2] - extent[0], extent[3] - extent[1]];
  }
  function getTopLeft(extent) {
    return [extent[0], extent[3]];
  }
  function getTopRight(extent) {
    return [extent[2], extent[3]];
  }
  function getWidth(extent) {
    return extent[2] - extent[0];
  }
  function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
  }
  function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
  }
  function returnOrUpdate(extent, dest) {
    return dest ? (dest[0] = extent[0], dest[1] = extent[1], dest[2] = extent[2], dest[3] = extent[3], dest) : extent;
  }
  function scaleFromCenter(extent, value) {
    const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
    value = (extent[3] - extent[1]) / 2 * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= value;
    extent[3] += value;
  }
  function intersectsSegment(extent, start, end) {
    var intersects = !1;
    const startRel = coordinateRelationship(extent, start), endRel = coordinateRelationship(extent, end);
    if (startRel === default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.INTERSECTING || endRel === default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.INTERSECTING) {
      intersects = !0;
    } else {
      const minX = extent[0], minY = extent[1], maxX = extent[2];
      extent = extent[3];
      const endX = end[0];
      end = end[1];
      start = (end - start[1]) / (endX - start[0]);
      endRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.ABOVE && !(startRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.ABOVE) && (intersects = endX - (end - extent) / start, intersects = intersects >= minX && intersects <= maxX);
      intersects || !(endRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.RIGHT) || startRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.RIGHT || (intersects = end - (endX - maxX) * start, intersects = intersects >= minY && intersects <= extent);
      intersects || !(endRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.BELOW) || startRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.BELOW || (intersects = endX - (end - minY) / start, intersects = intersects >= minX && intersects <= maxX);
      intersects || !(endRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.LEFT) || startRel & default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js.default.LEFT || (intersects = end - (endX - minX) * start, intersects = intersects >= minY && intersects <= extent);
    }
    return intersects;
  }
  function applyTransform(extent, transformFn, dest, stops) {
    if (isEmpty(extent)) {
      return createOrUpdateEmpty(dest);
    }
    var coordinates = [];
    if (1 < stops) {
      const width = extent[2] - extent[0], height = extent[3] - extent[1];
      for (let i = 0; i < stops; ++i) {
        coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
      }
    } else {
      coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];
    }
    transformFn(coordinates, coordinates, 2);
    stops = [];
    extent = [];
    for (let i = 0, l = coordinates.length; i < l; i += 2) {
      stops.push(coordinates[i]), extent.push(coordinates[i + 1]);
    }
    coordinates = Math.min.apply(null, stops);
    transformFn = Math.min.apply(null, extent);
    stops = Math.max.apply(null, stops);
    extent = Math.max.apply(null, extent);
    return createOrUpdate(coordinates, transformFn, stops, extent, dest);
  }
  function wrapX(extent, projection) {
    var projectionExtent = projection.getExtent();
    const center = getCenter(extent);
    projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2]) && (projection = getWidth(projectionExtent), projectionExtent = Math.floor((center[0] - projectionExtent[0]) / projection) * projection, extent[0] -= projectionExtent, extent[2] -= projectionExtent);
    return extent;
  }
  function wrapAndSliceX(extent, projection, multiWorld) {
    if (projection.canWrapX()) {
      const projectionExtent = projection.getExtent();
      if (!isFinite(extent[0]) || !isFinite(extent[2])) {
        return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
      }
      wrapX(extent, projection);
      projection = getWidth(projectionExtent);
      if (getWidth(extent) > projection && !multiWorld) {
        return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
      }
      if (extent[0] < projectionExtent[0]) {
        return [[extent[0] + projection, extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2], extent[3]]];
      }
      if (extent[2] > projectionExtent[2]) {
        return [[extent[0], extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2] - projection, extent[3]]];
      }
    }
    return [extent];
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, applyTransform:{enumerable:!0, get:function() {
    return applyTransform;
  }}, approximatelyEquals:{enumerable:!0, get:function() {
    return approximatelyEquals;
  }}, boundingExtent:{enumerable:!0, get:function() {
    return boundingExtent;
  }}, buffer:{enumerable:!0, get:function() {
    return buffer;
  }}, clone:{enumerable:!0, get:function() {
    return clone;
  }}, closestSquaredDistanceXY:{enumerable:!0, get:function() {
    return closestSquaredDistanceXY;
  }}, containsCoordinate:{enumerable:!0, get:function() {
    return containsCoordinate;
  }}, containsExtent:{enumerable:!0, get:function() {
    return containsExtent;
  }}, containsXY:{enumerable:!0, get:function() {
    return containsXY;
  }}, coordinateRelationship:{enumerable:!0, get:function() {
    return coordinateRelationship;
  }}, createEmpty:{enumerable:!0, get:function() {
    return createEmpty;
  }}, createOrUpdate:{enumerable:!0, get:function() {
    return createOrUpdate;
  }}, createOrUpdateEmpty:{enumerable:!0, get:function() {
    return createOrUpdateEmpty;
  }}, createOrUpdateFromCoordinate:{enumerable:!0, get:function() {
    return createOrUpdateFromCoordinate;
  }}, createOrUpdateFromCoordinates:{enumerable:!0, get:function() {
    return createOrUpdateFromCoordinates;
  }}, createOrUpdateFromFlatCoordinates:{enumerable:!0, get:function() {
    return createOrUpdateFromFlatCoordinates;
  }}, createOrUpdateFromRings:{enumerable:!0, get:function() {
    return createOrUpdateFromRings;
  }}, equals:{enumerable:!0, get:function() {
    return equals;
  }}, extend:{enumerable:!0, get:function() {
    return extend;
  }}, extendCoordinate:{enumerable:!0, get:function() {
    return extendCoordinate;
  }}, extendCoordinates:{enumerable:!0, get:function() {
    return extendCoordinates;
  }}, extendFlatCoordinates:{enumerable:!0, get:function() {
    return extendFlatCoordinates;
  }}, extendRings:{enumerable:!0, get:function() {
    return extendRings;
  }}, extendXY:{enumerable:!0, get:function() {
    return extendXY;
  }}, forEachCorner:{enumerable:!0, get:function() {
    return forEachCorner;
  }}, getArea:{enumerable:!0, get:function() {
    return getArea;
  }}, getBottomLeft:{enumerable:!0, get:function() {
    return getBottomLeft;
  }}, getBottomRight:{enumerable:!0, get:function() {
    return getBottomRight;
  }}, getCenter:{enumerable:!0, get:function() {
    return getCenter;
  }}, getCorner:{enumerable:!0, get:function() {
    return getCorner;
  }}, getEnlargedArea:{enumerable:!0, get:function() {
    return getEnlargedArea;
  }}, getForViewAndSize:{enumerable:!0, get:function() {
    return getForViewAndSize;
  }}, getHeight:{enumerable:!0, get:function() {
    return getHeight;
  }}, getIntersection:{enumerable:!0, get:function() {
    return getIntersection;
  }}, getIntersectionArea:{enumerable:!0, get:function() {
    return getIntersectionArea;
  }}, getMargin:{enumerable:!0, get:function() {
    return getMargin;
  }}, getRotatedViewport:{enumerable:!0, get:function() {
    return getRotatedViewport;
  }}, getSize:{enumerable:!0, get:function() {
    return getSize;
  }}, getTopLeft:{enumerable:!0, get:function() {
    return getTopLeft;
  }}, getTopRight:{enumerable:!0, get:function() {
    return getTopRight;
  }}, getWidth:{enumerable:!0, get:function() {
    return getWidth;
  }}, intersects:{enumerable:!0, get:function() {
    return intersects;
  }}, intersectsSegment:{enumerable:!0, get:function() {
    return intersectsSegment;
  }}, isEmpty:{enumerable:!0, get:function() {
    return isEmpty;
  }}, returnOrUpdate:{enumerable:!0, get:function() {
    return returnOrUpdate;
  }}, scaleFromCenter:{enumerable:!0, get:function() {
    return scaleFromCenter;
  }}, wrapAndSliceX:{enumerable:!0, get:function() {
    return wrapAndSliceX;
  }}, wrapX:{enumerable:!0, get:function() {
    return wrapX;
  }}});
  global = require("module$node_modules$ol$extent$Relationship");
  var default$$require$_DOT__SLASH_extent_SLASH_Relationship_DOT_js = require.esmDefault(global);
};

//# sourceMappingURL=module$node_modules$ol$extent.js.map
