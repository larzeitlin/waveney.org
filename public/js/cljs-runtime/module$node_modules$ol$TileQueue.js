shadow$provide.module$node_modules$ol$TileQueue = function(global, require, module, exports) {
  function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    if (!(frameState && tileSourceKey in frameState.wantedTiles && frameState.wantedTiles[tileSourceKey][tile.getKey()])) {
      return require$_DOT__SLASH_structs_SLASH_PriorityQueue_DOT_js.DROP;
    }
    tile = frameState.viewState.center;
    frameState = tileCenter[0] - tile[0];
    tileCenter = tileCenter[1] - tile[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(frameState * frameState + tileCenter * tileCenter) / tileResolution;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}, getTilePriority:{enumerable:!0, get:function() {
    return getTilePriority;
  }}});
  global = require("module$node_modules$ol$TileState");
  module = require("module$node_modules$ol$events$EventType");
  var require$_DOT__SLASH_structs_SLASH_PriorityQueue_DOT_js = require("module$node_modules$ol$structs$PriorityQueue");
  exports = require.esmDefault(require$_DOT__SLASH_structs_SLASH_PriorityQueue_DOT_js);
  var default$$require$_DOT__SLASH_TileState_DOT_js = require.esmDefault(global), default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js = require.esmDefault(module);
  class TileQueue extends exports.default {
    constructor(tilePriorityFunction, tileChangeCallback) {
      super(element => tilePriorityFunction.apply(null, element), element => element[0].getKey());
      this.boundHandleTileChange_ = this.handleTileChange.bind(this);
      this.tileChangeCallback_ = tileChangeCallback;
      this.tilesLoading_ = 0;
      this.tilesLoadingKeys_ = {};
    }
    enqueue(element) {
      const added = super.enqueue(element);
      added && element[0].addEventListener(default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE, this.boundHandleTileChange_);
      return added;
    }
    getTilesLoading() {
      return this.tilesLoading_;
    }
    handleTileChange(event) {
      event = event.target;
      const state = event.getState();
      if (state === default$$require$_DOT__SLASH_TileState_DOT_js.default.LOADED || state === default$$require$_DOT__SLASH_TileState_DOT_js.default.ERROR || state === default$$require$_DOT__SLASH_TileState_DOT_js.default.EMPTY) {
        state !== default$$require$_DOT__SLASH_TileState_DOT_js.default.ERROR && event.removeEventListener(default$$require$_DOT__SLASH_events_SLASH_EventType_DOT_js.default.CHANGE, this.boundHandleTileChange_), event = event.getKey(), event in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[event], --this.tilesLoading_), this.tileChangeCallback_();
      }
    }
    loadMoreTiles(maxTotalLoading, maxNewLoads) {
      let newLoads = 0;
      for (; this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && 0 < this.getCount();) {
        const tile = this.dequeue()[0], tileKey = tile.getKey();
        tile.getState() !== default$$require$_DOT__SLASH_TileState_DOT_js.default.IDLE || tileKey in this.tilesLoadingKeys_ || (this.tilesLoadingKeys_[tileKey] = !0, ++this.tilesLoading_, ++newLoads, tile.load());
      }
    }
  }
  const $$default = TileQueue;
};

//# sourceMappingURL=module$node_modules$ol$TileQueue.js.map
