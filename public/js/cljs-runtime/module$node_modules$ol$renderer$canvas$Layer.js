shadow$provide.module$node_modules$ol$renderer$canvas$Layer = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, canvasPool:{enumerable:!0, get:function() {
    return canvasPool;
  }}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_color_DOT_js = require("module$node_modules$ol$color"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent");
  module = require("module$node_modules$ol$render$Event");
  global = require("module$node_modules$ol$render$EventType");
  exports = require("module$node_modules$ol$render$canvas$ZIndexContext");
  var require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js = require("module$node_modules$ol$transform"), require$_DOT__DOT__SLASH_Layer_DOT_js = require("module$node_modules$ol$renderer$Layer"), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ZIndexContext_DOT_js = require.esmDefault(exports), default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_Event_DOT_js = require.esmDefault(module);
  module = require.esmDefault(require$_DOT__DOT__SLASH_Layer_DOT_js);
  var default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js = require.esmDefault(global);
  const canvasPool = [];
  let pixelContext = null;
  class CanvasLayerRenderer extends module.default {
    constructor(layer) {
      super(layer);
      this.container = null;
      this.renderedResolution;
      this.tempTransform = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)();
      this.pixelTransform = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)();
      this.inversePixelTransform = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.create)();
      this.deferredContext_ = this.context = null;
      this.containerReused = !1;
      this.frameState = null;
    }
    getImageData(image, col, row) {
      pixelContext || (pixelContext = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(1, 1, void 0, {willReadFrequently:!0}));
      pixelContext.clearRect(0, 0, 1, 1);
      let data;
      try {
        pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1), data = pixelContext.getImageData(0, 0, 1, 1).data;
      } catch {
        return pixelContext = null;
      }
      return data;
    }
    getBackground(frameState) {
      let background = this.getLayer().getBackground();
      "function" === typeof background && (background = background(frameState.viewState.resolution));
      return background || void 0;
    }
    useContainer(target, transform, backgroundColor) {
      var layerClassName = this.getLayer().getClassName();
      let context;
      if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_array_DOT_js.equals)((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_color_DOT_js.asArray)(target.style.backgroundColor), (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_color_DOT_js.asArray)(backgroundColor)))) {
        const canvas = target.firstElementChild;
        canvas instanceof HTMLCanvasElement && (context = canvas.getContext("2d"));
      }
      context && context.canvas.style.transform === transform ? (this.container = target, this.context = context, this.containerReused = !0) : this.containerReused ? (this.context = this.container = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null);
      this.container || (target = document.createElement("div"), target.className = layerClassName, layerClassName = target.style, layerClassName.position = "absolute", layerClassName.width = "100%", layerClassName.height = "100%", context = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_dom_DOT_js.createCanvasContext2D)(), layerClassName = context.canvas, target.appendChild(layerClassName), layerClassName = layerClassName.style, layerClassName.position = "absolute", layerClassName.left = "0", layerClassName.transformOrigin = 
      "top left", this.container = target, this.context = context);
      this.containerReused || !backgroundColor || this.container.style.backgroundColor || (this.container.style.backgroundColor = backgroundColor);
    }
    clipUnrotated(context, frameState, extent) {
      const topLeft = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getTopLeft)(extent), topRight = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getTopRight)(extent), bottomRight = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getBottomRight)(extent);
      extent = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getBottomLeft)(extent);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState.coordinateToPixelTransform, topLeft);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState.coordinateToPixelTransform, topRight);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState.coordinateToPixelTransform, bottomRight);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState.coordinateToPixelTransform, extent);
      frameState = this.inversePixelTransform;
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState, topLeft);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState, topRight);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState, bottomRight);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.apply)(frameState, extent);
      context.save();
      context.beginPath();
      context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
      context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
      context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
      context.lineTo(Math.round(extent[0]), Math.round(extent[1]));
      context.clip();
    }
    prepareContainer(frameState, target) {
      var extent = frameState.extent;
      const resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      const pixelRatio = frameState.pixelRatio, width = Math.round((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getWidth)(extent) / resolution * pixelRatio);
      extent = Math.round((0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_extent_DOT_js.getHeight)(extent) / resolution * pixelRatio);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -extent / 2);
      (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.makeInverse)(this.inversePixelTransform, this.pixelTransform);
      rotation = (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.toString)(this.pixelTransform);
      this.useContainer(target, rotation, this.getBackground(frameState));
      this.containerReused || (frameState = this.context.canvas, frameState.width != width || frameState.height != extent ? (frameState.width = width, frameState.height = extent) : this.context.clearRect(0, 0, width, extent), rotation !== frameState.style.transform && (frameState.style.transform = rotation));
    }
    dispatchRenderEvent_(type, context, frameState) {
      const layer = this.getLayer();
      layer.hasListener(type) && (type = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_Event_DOT_js.default(type, this.inversePixelTransform, frameState, context), layer.dispatchEvent(type));
    }
    preRender(context, frameState) {
      this.frameState = frameState;
      frameState.declutter || this.dispatchRenderEvent_(default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.PRERENDER, context, frameState);
    }
    postRender(context, frameState) {
      frameState.declutter || this.dispatchRenderEvent_(default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.POSTRENDER, context, frameState);
    }
    renderDeferredInternal(frameState) {
    }
    getRenderContext(frameState) {
      frameState.declutter && !this.deferredContext_ && (this.deferredContext_ = new default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_canvas_SLASH_ZIndexContext_DOT_js.default());
      return frameState.declutter ? this.deferredContext_.getContext() : this.context;
    }
    renderDeferred(frameState) {
      frameState.declutter && (this.dispatchRenderEvent_(default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.PRERENDER, this.context, frameState), frameState.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(frameState), this.dispatchRenderEvent_(default$$require$_DOT__DOT__SLASH__DOT__DOT__SLASH_render_SLASH_EventType_DOT_js.default.POSTRENDER, this.context, frameState));
    }
    getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
      resolution = pixelRatio / resolution;
      return (0,require$_DOT__DOT__SLASH__DOT__DOT__SLASH_transform_DOT_js.compose)(this.tempTransform, width / 2, height / 2, resolution, -resolution, -rotation, -center[0] + offsetX, -center[1]);
    }
    disposeInternal() {
      delete this.frameState;
      super.disposeInternal();
    }
  }
  const $$default = CanvasLayerRenderer;
};

//# sourceMappingURL=module$node_modules$ol$renderer$canvas$Layer.js.map
