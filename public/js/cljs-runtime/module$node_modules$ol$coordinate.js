shadow$provide.module$node_modules$ol$coordinate = function(global, require, module, exports) {
  function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
  }
  function closestOnCircle(coordinate, circle) {
    const r = circle.getRadius();
    var center = circle.getCenter();
    circle = center[0];
    center = center[1];
    let dx = coordinate[0] - circle;
    coordinate = coordinate[1] - center;
    0 === dx && 0 === coordinate && (dx = 1);
    const d = Math.sqrt(dx * dx + coordinate * coordinate);
    return [circle + r * dx / d, center + r * coordinate / d];
  }
  function closestOnSegment(coordinate, segment) {
    var x0 = coordinate[0];
    coordinate = coordinate[1];
    var start = segment[0], end = segment[1];
    segment = start[0];
    start = start[1];
    const x2 = end[0];
    end = end[1];
    const dx = x2 - segment, dy = end - start;
    x0 = 0 === dx && 0 === dy ? 0 : (dx * (x0 - segment) + dy * (coordinate - start)) / (dx * dx + dy * dy || 0);
    0 >= x0 ? (coordinate = segment, x0 = start) : 1 <= x0 ? (coordinate = x2, x0 = end) : (coordinate = segment + x0 * dx, x0 = start + x0 * dy);
    return [coordinate, x0];
  }
  function createStringXY(fractionDigits) {
    return function(coordinate) {
      return toStringXY(coordinate, fractionDigits);
    };
  }
  function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
    degrees = (0,require$_DOT__SLASH_math_DOT_js.modulo)(degrees + 180, 360) - 180;
    var x = Math.abs(3600 * degrees);
    fractionDigits = fractionDigits || 0;
    var deg = Math.floor(x / 3600);
    let min = Math.floor((x - 3600 * deg) / 60);
    x = (0,require$_DOT__SLASH_math_DOT_js.toFixed)(x - 3600 * deg - 60 * min, fractionDigits);
    60 <= x && (x = 0, min += 1);
    60 <= min && (min = 0, deg += 1);
    deg += "°";
    if (0 !== min || 0 !== x) {
      deg += " " + (0,require$_DOT__SLASH_string_DOT_js.padNumber)(min, 2) + "′";
    }
    0 !== x && (deg += " " + (0,require$_DOT__SLASH_string_DOT_js.padNumber)(x, 2, fractionDigits) + "″");
    0 !== degrees && (deg += " " + hemispheres.charAt(0 > degrees ? 1 : 0));
    return deg;
  }
  function format(coordinate, template, fractionDigits) {
    return coordinate ? template.replace("{x}", coordinate[0].toFixed(fractionDigits)).replace("{y}", coordinate[1].toFixed(fractionDigits)) : "";
  }
  function equals(coordinate1, coordinate2) {
    let equals = !0;
    for (let i = coordinate1.length - 1; 0 <= i; --i) {
      if (coordinate1[i] != coordinate2[i]) {
        equals = !1;
        break;
      }
    }
    return equals;
  }
  function rotate(coordinate, angle) {
    const cosAngle = Math.cos(angle);
    angle = Math.sin(angle);
    const y = coordinate[1] * cosAngle + coordinate[0] * angle;
    coordinate[0] = coordinate[0] * cosAngle - coordinate[1] * angle;
    coordinate[1] = y;
    return coordinate;
  }
  function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
  }
  function squaredDistance(coord1, coord2) {
    const dx = coord1[0] - coord2[0];
    coord1 = coord1[1] - coord2[1];
    return dx * dx + coord1 * coord1;
  }
  function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
  }
  function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
  }
  function toStringHDMS(coordinate, fractionDigits) {
    return coordinate ? degreesToStringHDMS("NS", coordinate[1], fractionDigits) + " " + degreesToStringHDMS("EW", coordinate[0], fractionDigits) : "";
  }
  function toStringXY(coordinate, fractionDigits) {
    return format(coordinate, "{x}, {y}", fractionDigits);
  }
  function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
      const worldWidth = (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(projection.getExtent());
      (projection = getWorldsAway(coordinate, projection, worldWidth)) && (coordinate[0] -= projection * worldWidth);
    }
    return coordinate;
  }
  function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    const projectionExtent = projection.getExtent();
    let worldsAway = 0;
    projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2]) && (sourceExtentWidth = sourceExtentWidth || (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(projectionExtent), worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth));
    return worldsAway;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, add:{enumerable:!0, get:function() {
    return add;
  }}, closestOnCircle:{enumerable:!0, get:function() {
    return closestOnCircle;
  }}, closestOnSegment:{enumerable:!0, get:function() {
    return closestOnSegment;
  }}, createStringXY:{enumerable:!0, get:function() {
    return createStringXY;
  }}, degreesToStringHDMS:{enumerable:!0, get:function() {
    return degreesToStringHDMS;
  }}, distance:{enumerable:!0, get:function() {
    return distance;
  }}, equals:{enumerable:!0, get:function() {
    return equals;
  }}, format:{enumerable:!0, get:function() {
    return format;
  }}, getWorldsAway:{enumerable:!0, get:function() {
    return getWorldsAway;
  }}, rotate:{enumerable:!0, get:function() {
    return rotate;
  }}, scale:{enumerable:!0, get:function() {
    return scale;
  }}, squaredDistance:{enumerable:!0, get:function() {
    return squaredDistance;
  }}, squaredDistanceToSegment:{enumerable:!0, get:function() {
    return squaredDistanceToSegment;
  }}, toStringHDMS:{enumerable:!0, get:function() {
    return toStringHDMS;
  }}, toStringXY:{enumerable:!0, get:function() {
    return toStringXY;
  }}, wrapX:{enumerable:!0, get:function() {
    return wrapX;
  }}});
  var require$_DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__SLASH_string_DOT_js = require("module$node_modules$ol$string");
};

//# sourceMappingURL=module$node_modules$ol$coordinate.js.map
