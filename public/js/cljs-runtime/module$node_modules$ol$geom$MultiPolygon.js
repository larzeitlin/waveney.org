shadow$provide.module$node_modules$ol$geom$MultiPolygon = function(global, require, module, exports) {
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, default:{enumerable:!0, get:function() {
    return $$default;
  }}});
  var require$_DOT__DOT__SLASH_array_DOT_js = require("module$node_modules$ol$array"), require$_DOT__DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent");
  global = require("module$node_modules$ol$geom$MultiPoint");
  module = require("module$node_modules$ol$geom$Polygon");
  exports = require("module$node_modules$ol$geom$SimpleGeometry");
  var require$_DOT__SLASH_flat_SLASH_area_DOT_js = require("module$node_modules$ol$geom$flat$area"), require$_DOT__SLASH_flat_SLASH_center_DOT_js = require("module$node_modules$ol$geom$flat$center"), require$_DOT__SLASH_flat_SLASH_closest_DOT_js = require("module$node_modules$ol$geom$flat$closest"), require$_DOT__SLASH_flat_SLASH_contains_DOT_js = require("module$node_modules$ol$geom$flat$contains"), require$_DOT__SLASH_flat_SLASH_deflate_DOT_js = require("module$node_modules$ol$geom$flat$deflate"), 
  require$_DOT__SLASH_flat_SLASH_inflate_DOT_js = require("module$node_modules$ol$geom$flat$inflate"), require$_DOT__SLASH_flat_SLASH_interiorpoint_DOT_js = require("module$node_modules$ol$geom$flat$interiorpoint"), require$_DOT__SLASH_flat_SLASH_intersectsextent_DOT_js = require("module$node_modules$ol$geom$flat$intersectsextent"), require$_DOT__SLASH_flat_SLASH_orient_DOT_js = require("module$node_modules$ol$geom$flat$orient"), require$_DOT__SLASH_flat_SLASH_simplify_DOT_js = require("module$node_modules$ol$geom$flat$simplify");
  exports = require.esmDefault(exports);
  var default$$require$_DOT__SLASH_Polygon_DOT_js = require.esmDefault(module), default$$require$_DOT__SLASH_MultiPoint_DOT_js = require.esmDefault(global);
  class MultiPolygon extends exports.default {
    constructor(coordinates, layout, endss) {
      super();
      this.endss_ = [];
      this.flatInteriorPointsRevision_ = -1;
      this.flatInteriorPoints_ = null;
      this.orientedRevision_ = this.maxDeltaRevision_ = this.maxDelta_ = -1;
      this.orientedFlatCoordinates_ = null;
      if (!endss && !Array.isArray(coordinates[0])) {
        layout = coordinates;
        coordinates = [];
        endss = [];
        for (let i = 0, ii = layout.length; i < ii; ++i) {
          const polygon = layout[i], offset = coordinates.length, ends = polygon.getEnds();
          for (let j = 0, jj = ends.length; j < jj; ++j) {
            ends[j] += offset;
          }
          (0,require$_DOT__DOT__SLASH_array_DOT_js.extend)(coordinates, polygon.getFlatCoordinates());
          endss.push(ends);
        }
        layout = 0 === layout.length ? this.getLayout() : layout[0].getLayout();
      }
      void 0 !== layout && endss ? (this.setFlatCoordinates(layout, coordinates), this.endss_ = endss) : this.setCoordinates(coordinates, layout);
    }
    appendPolygon(polygon) {
      if (this.flatCoordinates) {
        const offset = this.flatCoordinates.length;
        (0,require$_DOT__DOT__SLASH_array_DOT_js.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
        polygon = polygon.getEnds().slice();
        for (let i = 0, ii = polygon.length; i < ii; ++i) {
          polygon[i] += offset;
        }
      } else {
        this.flatCoordinates = polygon.getFlatCoordinates().slice(), polygon = polygon.getEnds().slice(), this.endss_.push();
      }
      this.endss_.push(polygon);
      this.changed();
    }
    clone() {
      var len = this.endss_.length;
      const newEndss = Array(len);
      for (let i = 0; i < len; ++i) {
        newEndss[i] = this.endss_[i].slice();
      }
      len = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
      len.applyProperties(this);
      return len;
    }
    closestPointXY(x, y, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < (0,require$_DOT__DOT__SLASH_extent_DOT_js.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
        return minSquaredDistance;
      }
      this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,require$_DOT__SLASH_flat_SLASH_closest_DOT_js.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision());
      return (0,require$_DOT__SLASH_flat_SLASH_closest_DOT_js.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, x, y, closestPoint, minSquaredDistance);
    }
    containsXY(x, y) {
      return (0,require$_DOT__SLASH_flat_SLASH_contains_DOT_js.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    }
    getArea() {
      return (0,require$_DOT__SLASH_flat_SLASH_area_DOT_js.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    }
    getCoordinates(right) {
      let flatCoordinates;
      void 0 !== right ? (flatCoordinates = this.getOrientedFlatCoordinates().slice(), (0,require$_DOT__SLASH_flat_SLASH_orient_DOT_js.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, right)) : flatCoordinates = this.flatCoordinates;
      return (0,require$_DOT__SLASH_flat_SLASH_inflate_DOT_js.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
    }
    getEndss() {
      return this.endss_;
    }
    getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        const flatCenters = (0,require$_DOT__SLASH_flat_SLASH_center_DOT_js.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
        this.flatInteriorPoints_ = (0,require$_DOT__SLASH_flat_SLASH_interiorpoint_DOT_js.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
        this.flatInteriorPointsRevision_ = this.getRevision();
      }
      return this.flatInteriorPoints_;
    }
    getInteriorPoints() {
      return new default$$require$_DOT__SLASH_MultiPoint_DOT_js.default(this.getFlatInteriorPoints().slice(), "XYM");
    }
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const flatCoordinates = this.flatCoordinates;
        (0,require$_DOT__SLASH_flat_SLASH_orient_DOT_js.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = flatCoordinates : (this.orientedFlatCoordinates_ = flatCoordinates.slice(), this.orientedFlatCoordinates_.length = (0,require$_DOT__SLASH_flat_SLASH_orient_DOT_js.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride));
        this.orientedRevision_ = this.getRevision();
      }
      return this.orientedFlatCoordinates_;
    }
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [], simplifiedEndss = [];
      simplifiedFlatCoordinates.length = (0,require$_DOT__SLASH_flat_SLASH_simplify_DOT_js.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
      return new MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
    }
    getPolygon(index) {
      if (0 > index || this.endss_.length <= index) {
        return null;
      }
      if (0 === index) {
        var offset = 0;
      } else {
        offset = this.endss_[index - 1], offset = offset[offset.length - 1];
      }
      index = this.endss_[index].slice();
      const end = index[index.length - 1];
      if (0 !== offset) {
        for (let i = 0, ii = index.length; i < ii; ++i) {
          index[i] -= offset;
        }
      }
      return new default$$require$_DOT__SLASH_Polygon_DOT_js.default(this.flatCoordinates.slice(offset, end), this.layout, index);
    }
    getPolygons() {
      const layout = this.layout, flatCoordinates = this.flatCoordinates, endss = this.endss_, polygons = [];
      var offset = 0;
      for (let i = 0, ii = endss.length; i < ii; ++i) {
        const ends = endss[i].slice(), end = ends[ends.length - 1];
        if (0 !== offset) {
          for (let j = 0, jj = ends.length; j < jj; ++j) {
            ends[j] -= offset;
          }
        }
        offset = new default$$require$_DOT__SLASH_Polygon_DOT_js.default(flatCoordinates.slice(offset, end), layout, ends);
        polygons.push(offset);
        offset = end;
      }
      return polygons;
    }
    getType() {
      return "MultiPolygon";
    }
    intersectsExtent(extent) {
      return (0,require$_DOT__SLASH_flat_SLASH_intersectsextent_DOT_js.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    }
    setCoordinates(coordinates, layout) {
      this.setLayout(layout, coordinates, 3);
      this.flatCoordinates || (this.flatCoordinates = []);
      coordinates = (0,require$_DOT__SLASH_flat_SLASH_deflate_DOT_js.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
      0 === coordinates.length ? this.flatCoordinates.length = 0 : (coordinates = coordinates[coordinates.length - 1], this.flatCoordinates.length = 0 === coordinates.length ? 0 : coordinates[coordinates.length - 1]);
      this.changed();
    }
  }
  const $$default = MultiPolygon;
};

//# sourceMappingURL=module$node_modules$ol$geom$MultiPolygon.js.map
