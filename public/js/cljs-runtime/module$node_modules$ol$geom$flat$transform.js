shadow$provide.module$node_modules$ol$geom$flat$transform = function(global, require, module, exports) {
  function transform2D(flatCoordinates, offset, end, stride, transform, dest, destinationStride) {
    dest = dest ? dest : [];
    destinationStride = destinationStride ? destinationStride : 2;
    let i = 0;
    for (; offset < end; offset += stride) {
      var x = flatCoordinates[offset];
      const y = flatCoordinates[offset + 1];
      dest[i++] = transform[0] * x + transform[2] * y + transform[4];
      dest[i++] = transform[1] * x + transform[3] * y + transform[5];
      for (x = 2; x < destinationStride; x++) {
        dest[i++] = flatCoordinates[offset + x];
      }
    }
    dest && dest.length != i && (dest.length = i);
    return dest;
  }
  function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
    dest = dest ? dest : [];
    const cos = Math.cos(angle);
    angle = Math.sin(angle);
    const anchorX = anchor[0];
    anchor = anchor[1];
    let i = 0;
    for (; offset < end; offset += stride) {
      var deltaX = flatCoordinates[offset] - anchorX;
      const deltaY = flatCoordinates[offset + 1] - anchor;
      dest[i++] = anchorX + deltaX * cos - deltaY * angle;
      dest[i++] = anchor + deltaX * angle + deltaY * cos;
      for (deltaX = offset + 2; deltaX < offset + stride; ++deltaX) {
        dest[i++] = flatCoordinates[deltaX];
      }
    }
    dest && dest.length != i && (dest.length = i);
    return dest;
  }
  function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
    dest = dest ? dest : [];
    const anchorX = anchor[0];
    anchor = anchor[1];
    let i = 0;
    for (; offset < end; offset += stride) {
      var deltaX = flatCoordinates[offset] - anchorX;
      const deltaY = flatCoordinates[offset + 1] - anchor;
      dest[i++] = anchorX + sx * deltaX;
      dest[i++] = anchor + sy * deltaY;
      for (deltaX = offset + 2; deltaX < offset + stride; ++deltaX) {
        dest[i++] = flatCoordinates[deltaX];
      }
    }
    dest && dest.length != i && (dest.length = i);
    return dest;
  }
  function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for (; offset < end; offset += stride) {
      dest[i++] = flatCoordinates[offset] + deltaX;
      dest[i++] = flatCoordinates[offset + 1] + deltaY;
      for (let k = offset + 2; k < offset + stride; ++k) {
        dest[i++] = flatCoordinates[k];
      }
    }
    dest && dest.length != i && (dest.length = i);
    return dest;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, rotate:{enumerable:!0, get:function() {
    return rotate;
  }}, scale:{enumerable:!0, get:function() {
    return scale;
  }}, transform2D:{enumerable:!0, get:function() {
    return transform2D;
  }}, translate:{enumerable:!0, get:function() {
    return translate;
  }}});
};

//# sourceMappingURL=module$node_modules$ol$geom$flat$transform.js.map
