shadow$provide.module$node_modules$ol$reproj = function(global, require, module, exports) {
  function drawTestTriangle(ctx, u1, v1, u2, v2) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(u1, v1);
    ctx.lineTo(u2, v2);
    ctx.closePath();
    ctx.save();
    ctx.clip();
    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
    ctx.restore();
  }
  function verifyBrokenDiagonalRendering(data, offset) {
    return 2 < Math.abs(data[4 * offset] - 210) || 2 < Math.abs(data[4 * offset + 3] - 191.25);
  }
  function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
    const sourceCenter = (0,require$_DOT__SLASH_proj_DOT_js.transform)(targetCenter, targetProj, sourceProj);
    targetCenter = (0,require$_DOT__SLASH_proj_DOT_js.getPointResolution)(targetProj, targetResolution, targetCenter);
    targetProj = targetProj.getMetersPerUnit();
    void 0 !== targetProj && (targetCenter *= targetProj);
    targetProj = sourceProj.getMetersPerUnit();
    void 0 !== targetProj && (targetCenter /= targetProj);
    targetProj = sourceProj.getExtent();
    if (!targetProj || (0,require$_DOT__SLASH_extent_DOT_js.containsCoordinate)(targetProj, sourceCenter)) {
      sourceProj = (0,require$_DOT__SLASH_proj_DOT_js.getPointResolution)(sourceProj, targetCenter, sourceCenter) / targetCenter, isFinite(sourceProj) && 0 < sourceProj && (targetCenter /= sourceProj);
    }
    return targetCenter;
  }
  function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
    const targetCenter = (0,require$_DOT__SLASH_extent_DOT_js.getCenter)(targetExtent);
    let sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    (!isFinite(sourceResolution) || 0 >= sourceResolution) && (0,require$_DOT__SLASH_extent_DOT_js.forEachCorner)(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && 0 < sourceResolution;
    });
    return sourceResolution;
  }
  function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
    function pixelRound(value) {
      return Math.round(value * pixelRatio) / pixelRatio;
    }
    const context = (0,require$_DOT__SLASH_dom_DOT_js.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);
    interpolate || (context.imageSmoothingEnabled = !1);
    if (0 === sources.length) {
      return context.canvas;
    }
    context.scale(pixelRatio, pixelRatio);
    context.globalCompositeOperation = "lighter";
    const sourceDataExtent = (0,require$_DOT__SLASH_extent_DOT_js.createEmpty)();
    sources.forEach(function(src, i, arr) {
      (0,require$_DOT__SLASH_extent_DOT_js.extend)(sourceDataExtent, src.extent);
    });
    let stitchContext;
    const stitchScale = pixelRatio / sourceResolution, inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
    drawSingle && 1 === sources.length && 0 === gutter || (stitchContext = (0,require$_DOT__SLASH_dom_DOT_js.createCanvasContext2D)(Math.round((0,require$_DOT__SLASH_extent_DOT_js.getWidth)(sourceDataExtent) * stitchScale), Math.round((0,require$_DOT__SLASH_extent_DOT_js.getHeight)(sourceDataExtent) * stitchScale), canvasPool), interpolate || (stitchContext.imageSmoothingEnabled = !1), sourceExtent && clipExtent && (width = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale, height = -(sourceExtent[3] - 
    sourceDataExtent[3]) * stitchScale, sourceResolution = (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(sourceExtent) * stitchScale, sourceExtent = (0,require$_DOT__SLASH_extent_DOT_js.getHeight)(sourceExtent) * stitchScale, stitchContext.rect(width, height, sourceResolution, sourceExtent), stitchContext.clip()), sources.forEach(function(src, i, arr) {
      if (0 < src.image.width && 0 < src.image.height) {
        if (src.clipExtent) {
          stitchContext.save();
          i = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          arr = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          var width = (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(src.clipExtent) * stitchScale, height = (0,require$_DOT__SLASH_extent_DOT_js.getHeight)(src.clipExtent) * stitchScale;
          stitchContext.rect(interpolate ? i : Math.round(i), interpolate ? arr : Math.round(arr), interpolate ? width : Math.round(i + width) - Math.round(i), interpolate ? height : Math.round(arr + height) - Math.round(arr));
          stitchContext.clip();
        }
        i = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        arr = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        width = (0,require$_DOT__SLASH_extent_DOT_js.getWidth)(src.extent) * stitchScale;
        height = (0,require$_DOT__SLASH_extent_DOT_js.getHeight)(src.extent) * stitchScale;
        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, interpolate ? i : Math.round(i), interpolate ? arr : Math.round(arr), interpolate ? width : Math.round(i + width) - Math.round(i), interpolate ? height : Math.round(arr + height) - Math.round(arr));
        src.clipExtent && stitchContext.restore();
      }
    }));
    const targetTopLeft = (0,require$_DOT__SLASH_extent_DOT_js.getTopLeft)(targetExtent);
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      arr = triangle.source;
      var target = triangle.target;
      triangle = arr[0][0];
      i = arr[0][1];
      var x1 = arr[1][0], y1 = arr[1][1], x2 = arr[2][0], y2 = arr[2][1];
      arr = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
      const v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution), u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution), v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution), u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
      target = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
      x1 -= triangle;
      y1 -= i;
      x2 -= triangle;
      y2 -= i;
      if (x1 = (0,require$_DOT__SLASH_math_DOT_js.solveLinearSystem)([[x1, y1, 0, 0, u1 - arr], [x2, y2, 0, 0, u2 - arr], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, target - v0]])) {
        context.save();
        context.beginPath();
        void 0 === brokenDiagonalRendering_ && (y1 = (0,require$_DOT__SLASH_dom_DOT_js.createCanvasContext2D)(6, 6, canvasPool), y1.globalCompositeOperation = "lighter", y1.fillStyle = "rgba(210, 0, 0, 0.75)", drawTestTriangle(y1, 4, 5, 4, 0), drawTestTriangle(y1, 4, 5, 0, 5), x2 = y1.getImageData(0, 0, 3, 3).data, brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(x2, 0) || verifyBrokenDiagonalRendering(x2, 4) || verifyBrokenDiagonalRendering(x2, 8), (0,require$_DOT__SLASH_dom_DOT_js.releaseCanvas)(y1), 
        canvasPool.push(y1.canvas));
        if (brokenDiagonalRendering_ || !interpolate) {
          for (context.moveTo(u1, v1), y1 = arr - u1, x2 = v0 - v1, y2 = 0; 4 > y2; y2++) {
            context.lineTo(u1 + pixelRound((y2 + 1) * y1 / 4), v1 + pixelRound(y2 * x2 / 3)), 3 != y2 && context.lineTo(u1 + pixelRound((y2 + 1) * y1 / 4), v1 + pixelRound((y2 + 1) * x2 / 3));
          }
        } else {
          context.moveTo(u1, v1), context.lineTo(arr, v0);
        }
        context.lineTo(u2, target);
        context.clip();
        context.transform(x1[0], x1[2], x1[1], x1[3], arr, v0);
        context.translate(sourceDataExtent[0] - triangle, sourceDataExtent[3] - i);
        stitchContext ? (i = stitchContext.canvas, context.scale(inverseScale, -inverseScale)) : (i = sources[0], triangle = i.extent, i = i.image, context.scale((0,require$_DOT__SLASH_extent_DOT_js.getWidth)(triangle) / i.width, -(0,require$_DOT__SLASH_extent_DOT_js.getHeight)(triangle) / i.height));
        context.drawImage(i, 0, 0);
        context.restore();
      }
    });
    stitchContext && ((0,require$_DOT__SLASH_dom_DOT_js.releaseCanvas)(stitchContext), canvasPool.push(stitchContext.canvas));
    renderEdges && (context.save(), context.globalCompositeOperation = "source-over", context.strokeStyle = "black", context.lineWidth = 1, triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      triangle = (target[0][0] - targetTopLeft[0]) / targetResolution;
      i = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      arr = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution, u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      target = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(arr, v1);
      context.lineTo(triangle, i);
      context.lineTo(u2, target);
      context.closePath();
      context.stroke();
    }), context.restore());
    return context.canvas;
  }
  Object.defineProperties(exports, {__esModule:{enumerable:!0, value:!0}, calculateSourceExtentResolution:{enumerable:!0, get:function() {
    return calculateSourceExtentResolution;
  }}, calculateSourceResolution:{enumerable:!0, get:function() {
    return calculateSourceResolution;
  }}, canvasPool:{enumerable:!0, get:function() {
    return canvasPool;
  }}, render:{enumerable:!0, get:function() {
    return render;
  }}});
  var require$_DOT__SLASH_dom_DOT_js = require("module$node_modules$ol$dom"), require$_DOT__SLASH_extent_DOT_js = require("module$node_modules$ol$extent"), require$_DOT__SLASH_math_DOT_js = require("module$node_modules$ol$math"), require$_DOT__SLASH_proj_DOT_js = require("module$node_modules$ol$proj");
  let brokenDiagonalRendering_;
  const canvasPool = [];
};

//# sourceMappingURL=module$node_modules$ol$reproj.js.map
